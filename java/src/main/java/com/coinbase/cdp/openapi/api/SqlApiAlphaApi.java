/*
 * Coinbase Developer Platform APIs
 * The Coinbase Developer Platform APIs - leading the world's transition onchain.
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: cdp@coinbase.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.coinbase.cdp.openapi.api;

import com.coinbase.cdp.openapi.ApiClient;
import com.coinbase.cdp.openapi.ApiException;
import com.coinbase.cdp.openapi.ApiResponse;
import com.coinbase.cdp.openapi.Pair;

import com.coinbase.cdp.openapi.model.Error;
import com.coinbase.cdp.openapi.model.OnchainDataQuery;
import com.coinbase.cdp.openapi.model.OnchainDataResult;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.io.InputStream;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.OutputStream;
import java.net.http.HttpRequest;
import java.nio.channels.Channels;
import java.nio.channels.Pipe;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.Duration;

import java.util.ArrayList;
import java.util.StringJoiner;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Consumer;

@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", comments = "Generator version: 7.11.0")
public class SqlApiAlphaApi {
  private final HttpClient memberVarHttpClient;
  private final ObjectMapper memberVarObjectMapper;
  private final String memberVarBaseUri;
  private final Consumer<HttpRequest.Builder> memberVarInterceptor;
  private final Duration memberVarReadTimeout;
  private final Consumer<HttpResponse<InputStream>> memberVarResponseInterceptor;
  private final Consumer<HttpResponse<String>> memberVarAsyncResponseInterceptor;

  public SqlApiAlphaApi() {
    this(new ApiClient());
  }

  public SqlApiAlphaApi(ApiClient apiClient) {
    memberVarHttpClient = apiClient.getHttpClient();
    memberVarObjectMapper = apiClient.getObjectMapper();
    memberVarBaseUri = apiClient.getBaseUri();
    memberVarInterceptor = apiClient.getRequestInterceptor();
    memberVarReadTimeout = apiClient.getReadTimeout();
    memberVarResponseInterceptor = apiClient.getResponseInterceptor();
    memberVarAsyncResponseInterceptor = apiClient.getAsyncResponseInterceptor();
  }

  protected ApiException getApiException(String operationId, HttpResponse<InputStream> response) throws IOException {
    String body = response.body() == null ? null : new String(response.body().readAllBytes());
    String message = formatExceptionMessage(operationId, response.statusCode(), body);
    return new ApiException(response.statusCode(), message, response.headers(), body);
  }

  private String formatExceptionMessage(String operationId, int statusCode, String body) {
    if (body == null || body.isEmpty()) {
      body = "[no body]";
    }
    return operationId + " call failed with: " + statusCode + " - " + body;
  }

  /**
   * Get SQL grammar
   * Retrieve the SQL grammar for the SQL API.  The SQL queries that are supported by the SQL API are defined via an ANTLR4 grammar which is evaluated by server before executing the query. This ensures the safety and soundness of the SQL API.  This endpoint returns the ANTLR4 grammar that is used to evaluate the SQL queries so that developers can understand the SQL API and build SQL queries with high confidence and correctness. LLMs interact well with ANTLR4 grammar as well. 
   * @return String
   * @throws ApiException if fails to make API call
   */
  public String getSQLGrammar() throws ApiException {
    ApiResponse<String> localVarResponse = getSQLGrammarWithHttpInfo();
    return localVarResponse.getData();
  }

  /**
   * Get SQL grammar
   * Retrieve the SQL grammar for the SQL API.  The SQL queries that are supported by the SQL API are defined via an ANTLR4 grammar which is evaluated by server before executing the query. This ensures the safety and soundness of the SQL API.  This endpoint returns the ANTLR4 grammar that is used to evaluate the SQL queries so that developers can understand the SQL API and build SQL queries with high confidence and correctness. LLMs interact well with ANTLR4 grammar as well. 
   * @return ApiResponse&lt;String&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<String> getSQLGrammarWithHttpInfo() throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = getSQLGrammarRequestBuilder();
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("getSQLGrammar", localVarResponse);
        }
        if (localVarResponse.body() == null) {
          return new ApiResponse<String>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        String responseBody = new String(localVarResponse.body().readAllBytes());
        localVarResponse.body().close();

        return new ApiResponse<String>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<String>() {})
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder getSQLGrammarRequestBuilder() throws ApiException {

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v2/data/query/grammar";

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Run SQL Query
   * Run a read-only SQL query against indexed blockchain data including transactions, events, and decoded logs.  This endpoint provides direct SQL access to comprehensive blockchain data across supported networks. Queries are executed against optimized data structures for high-performance analytics.  ### Allowed Queries    - Standard SQL syntax (ClickHouse dialect)   - Read-only queries (SELECT statements)   - No DDL or DML operations   - No cartesian products  ### Supported Tables    - &#x60;base.events&#x60; - Base mainnet decoded event logs with parameters, event signature, topics, and more.   - &#x60;base.transactions&#x60; - Base mainnet transaction data including hash, block number, gas usage.   - &#x60;base.blocks&#x60; - Base mainnet block information.   - &#x60;base.encoded_logs&#x60; - Encoded log data of event logs that aren&#39;t able to be decoded by our event decoder (ex: log0 opcode).   - &#x60;base.transfers&#x60; - All event logs with event signature &#x60;Transfer(address,address,uint256)&#x60;. ERC-20, ERC-721, and ERC-1155 transfers are all included.  ### Query Limits    - Maximum result set: 100,000 rows   - Query timeout: 30 seconds 
   * @param onchainDataQuery  (required)
   * @return OnchainDataResult
   * @throws ApiException if fails to make API call
   */
  public OnchainDataResult runSQLQuery(OnchainDataQuery onchainDataQuery) throws ApiException {
    ApiResponse<OnchainDataResult> localVarResponse = runSQLQueryWithHttpInfo(onchainDataQuery);
    return localVarResponse.getData();
  }

  /**
   * Run SQL Query
   * Run a read-only SQL query against indexed blockchain data including transactions, events, and decoded logs.  This endpoint provides direct SQL access to comprehensive blockchain data across supported networks. Queries are executed against optimized data structures for high-performance analytics.  ### Allowed Queries    - Standard SQL syntax (ClickHouse dialect)   - Read-only queries (SELECT statements)   - No DDL or DML operations   - No cartesian products  ### Supported Tables    - &#x60;base.events&#x60; - Base mainnet decoded event logs with parameters, event signature, topics, and more.   - &#x60;base.transactions&#x60; - Base mainnet transaction data including hash, block number, gas usage.   - &#x60;base.blocks&#x60; - Base mainnet block information.   - &#x60;base.encoded_logs&#x60; - Encoded log data of event logs that aren&#39;t able to be decoded by our event decoder (ex: log0 opcode).   - &#x60;base.transfers&#x60; - All event logs with event signature &#x60;Transfer(address,address,uint256)&#x60;. ERC-20, ERC-721, and ERC-1155 transfers are all included.  ### Query Limits    - Maximum result set: 100,000 rows   - Query timeout: 30 seconds 
   * @param onchainDataQuery  (required)
   * @return ApiResponse&lt;OnchainDataResult&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<OnchainDataResult> runSQLQueryWithHttpInfo(OnchainDataQuery onchainDataQuery) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = runSQLQueryRequestBuilder(onchainDataQuery);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("runSQLQuery", localVarResponse);
        }
        if (localVarResponse.body() == null) {
          return new ApiResponse<OnchainDataResult>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        String responseBody = new String(localVarResponse.body().readAllBytes());
        localVarResponse.body().close();

        return new ApiResponse<OnchainDataResult>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<OnchainDataResult>() {})
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder runSQLQueryRequestBuilder(OnchainDataQuery onchainDataQuery) throws ApiException {
    // verify the required parameter 'onchainDataQuery' is set
    if (onchainDataQuery == null) {
      throw new ApiException(400, "Missing the required parameter 'onchainDataQuery' when calling runSQLQuery");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v2/data/query/run";

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(onchainDataQuery);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

}
