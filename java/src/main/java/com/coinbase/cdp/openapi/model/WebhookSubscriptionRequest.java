/*
 * Coinbase Developer Platform APIs
 * The Coinbase Developer Platform APIs - leading the world's transition onchain.
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: cdp@coinbase.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.coinbase.cdp.openapi.model;

import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.StringJoiner;
import java.util.Objects;
import java.util.Map;
import java.util.HashMap;
import com.coinbase.cdp.openapi.model.WebhookTarget;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;


import com.coinbase.cdp.openapi.ApiClient;
/**
 * Request to create a new webhook subscription with support for both traditional single-label  and multi-label filtering formats. 
 */
@JsonPropertyOrder({
  WebhookSubscriptionRequest.JSON_PROPERTY_DESCRIPTION,
  WebhookSubscriptionRequest.JSON_PROPERTY_EVENT_TYPES,
  WebhookSubscriptionRequest.JSON_PROPERTY_IS_ENABLED,
  WebhookSubscriptionRequest.JSON_PROPERTY_TARGET,
  WebhookSubscriptionRequest.JSON_PROPERTY_METADATA,
  WebhookSubscriptionRequest.JSON_PROPERTY_LABEL_KEY,
  WebhookSubscriptionRequest.JSON_PROPERTY_LABEL_VALUE,
  WebhookSubscriptionRequest.JSON_PROPERTY_LABELS
})
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", comments = "Generator version: 7.11.0")
public class WebhookSubscriptionRequest {
  public static final String JSON_PROPERTY_DESCRIPTION = "description";
  @jakarta.annotation.Nullable
  private String description;

  public static final String JSON_PROPERTY_EVENT_TYPES = "eventTypes";
  @jakarta.annotation.Nullable
  private List<String> eventTypes = new ArrayList<>();

  public static final String JSON_PROPERTY_IS_ENABLED = "isEnabled";
  @jakarta.annotation.Nullable
  private Boolean isEnabled;

  public static final String JSON_PROPERTY_TARGET = "target";
  @jakarta.annotation.Nullable
  private WebhookTarget target;

  public static final String JSON_PROPERTY_METADATA = "metadata";
  @jakarta.annotation.Nullable
  private Map<String, Object> metadata = new HashMap<>();

  public static final String JSON_PROPERTY_LABEL_KEY = "labelKey";
  @jakarta.annotation.Nullable
  private String labelKey;

  public static final String JSON_PROPERTY_LABEL_VALUE = "labelValue";
  @jakarta.annotation.Nullable
  private String labelValue;

  public static final String JSON_PROPERTY_LABELS = "labels";
  @jakarta.annotation.Nullable
  private Map<String, String> labels = new HashMap<>();

  public WebhookSubscriptionRequest() { 
  }

  public WebhookSubscriptionRequest description(@jakarta.annotation.Nullable String description) {
    this.description = description;
    return this;
  }

  /**
   * Description of the webhook subscription.
   * @return description
   */
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_DESCRIPTION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public String getDescription() {
    return description;
  }


  @JsonProperty(JSON_PROPERTY_DESCRIPTION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setDescription(@jakarta.annotation.Nullable String description) {
    this.description = description;
  }


  public WebhookSubscriptionRequest eventTypes(@jakarta.annotation.Nullable List<String> eventTypes) {
    this.eventTypes = eventTypes;
    return this;
  }

  public WebhookSubscriptionRequest addEventTypesItem(String eventTypesItem) {
    if (this.eventTypes == null) {
      this.eventTypes = new ArrayList<>();
    }
    this.eventTypes.add(eventTypesItem);
    return this;
  }

  /**
   * Types of events to subscribe to. Event types follow a three-part dot-separated format:  service.resource.verb (e.g., \&quot;onchain.activity.detected\&quot;, \&quot;wallet.activity.detected\&quot;, \&quot;onramp.transaction.created\&quot;). The subscription will only receive events matching these types AND the label filter(s). 
   * @return eventTypes
   */
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_EVENT_TYPES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public List<String> getEventTypes() {
    return eventTypes;
  }


  @JsonProperty(JSON_PROPERTY_EVENT_TYPES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setEventTypes(@jakarta.annotation.Nullable List<String> eventTypes) {
    this.eventTypes = eventTypes;
  }


  public WebhookSubscriptionRequest isEnabled(@jakarta.annotation.Nullable Boolean isEnabled) {
    this.isEnabled = isEnabled;
    return this;
  }

  /**
   * Whether the subscription is enabled.
   * @return isEnabled
   */
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_IS_ENABLED)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public Boolean getIsEnabled() {
    return isEnabled;
  }


  @JsonProperty(JSON_PROPERTY_IS_ENABLED)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setIsEnabled(@jakarta.annotation.Nullable Boolean isEnabled) {
    this.isEnabled = isEnabled;
  }


  public WebhookSubscriptionRequest target(@jakarta.annotation.Nullable WebhookTarget target) {
    this.target = target;
    return this;
  }

  /**
   * Get target
   * @return target
   */
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_TARGET)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public WebhookTarget getTarget() {
    return target;
  }


  @JsonProperty(JSON_PROPERTY_TARGET)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setTarget(@jakarta.annotation.Nullable WebhookTarget target) {
    this.target = target;
  }


  public WebhookSubscriptionRequest metadata(@jakarta.annotation.Nullable Map<String, Object> metadata) {
    this.metadata = metadata;
    return this;
  }

  public WebhookSubscriptionRequest putMetadataItem(String key, Object metadataItem) {
    if (this.metadata == null) {
      this.metadata = new HashMap<>();
    }
    this.metadata.put(key, metadataItem);
    return this;
  }

  /**
   * Additional metadata for the subscription.
   * @return metadata
   */
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_METADATA)
  @JsonInclude(content = JsonInclude.Include.ALWAYS, value = JsonInclude.Include.USE_DEFAULTS)
  public Map<String, Object> getMetadata() {
    return metadata;
  }


  @JsonProperty(JSON_PROPERTY_METADATA)
  @JsonInclude(content = JsonInclude.Include.ALWAYS, value = JsonInclude.Include.USE_DEFAULTS)
  public void setMetadata(@jakarta.annotation.Nullable Map<String, Object> metadata) {
    this.metadata = metadata;
  }


  public WebhookSubscriptionRequest labelKey(@jakarta.annotation.Nullable String labelKey) {
    this.labelKey = labelKey;
    return this;
  }

  /**
   * (Deprecated) Use &#x60;labels&#x60; instead for better filtering capabilities, including filtering on multiple labels simultaneously.  Label key for filtering events. Each subscription filters on exactly one (labelKey, labelValue) pair  in addition to the event types. Only events matching both the event types AND this label filter will be delivered. NOTE: Use either (labelKey + labelValue) OR labels, not both.  Maintained for backward compatibility only. 
   * @return labelKey
   * @deprecated
   */
  @Deprecated
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_LABEL_KEY)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public String getLabelKey() {
    return labelKey;
  }


  @JsonProperty(JSON_PROPERTY_LABEL_KEY)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setLabelKey(@jakarta.annotation.Nullable String labelKey) {
    this.labelKey = labelKey;
  }


  public WebhookSubscriptionRequest labelValue(@jakarta.annotation.Nullable String labelValue) {
    this.labelValue = labelValue;
    return this;
  }

  /**
   * (Deprecated) Use &#x60;labels&#x60; instead for better filtering capabilities, including filtering on multiple labels simultaneously.  Label value for filtering events. Must correspond to the labelKey (e.g., contract address for contract_address key). Only events with this exact label value will be delivered. NOTE: Use either (labelKey + labelValue) OR labels, not both.  Maintained for backward compatibility only. 
   * @return labelValue
   * @deprecated
   */
  @Deprecated
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_LABEL_VALUE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public String getLabelValue() {
    return labelValue;
  }


  @JsonProperty(JSON_PROPERTY_LABEL_VALUE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setLabelValue(@jakarta.annotation.Nullable String labelValue) {
    this.labelValue = labelValue;
  }


  public WebhookSubscriptionRequest labels(@jakarta.annotation.Nullable Map<String, String> labels) {
    this.labels = labels;
    return this;
  }

  public WebhookSubscriptionRequest putLabelsItem(String key, String labelsItem) {
    if (this.labels == null) {
      this.labels = new HashMap<>();
    }
    this.labels.put(key, labelsItem);
    return this;
  }

  /**
   * Multi-label filters using total overlap logic. Total overlap means the subscription will only trigger when  an event contains ALL the key-value pairs specified here. Additional labels on  the event are allowed and will not prevent matching.  **Note:** Currently, labels are supported for onchain webhooks only.  See [allowed labels for onchain webhooks](https://docs.cdp.coinbase.com/api-reference/v2/rest-api/webhooks/create-webhook-subscription#onchain-label-filtering). 
   * @return labels
   */
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_LABELS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public Map<String, String> getLabels() {
    return labels;
  }


  @JsonProperty(JSON_PROPERTY_LABELS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setLabels(@jakarta.annotation.Nullable Map<String, String> labels) {
    this.labels = labels;
  }


  /**
   * Return true if this WebhookSubscriptionRequest object is equal to o.
   */
  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    WebhookSubscriptionRequest webhookSubscriptionRequest = (WebhookSubscriptionRequest) o;
    return Objects.equals(this.description, webhookSubscriptionRequest.description) &&
        Objects.equals(this.eventTypes, webhookSubscriptionRequest.eventTypes) &&
        Objects.equals(this.isEnabled, webhookSubscriptionRequest.isEnabled) &&
        Objects.equals(this.target, webhookSubscriptionRequest.target) &&
        Objects.equals(this.metadata, webhookSubscriptionRequest.metadata) &&
        Objects.equals(this.labelKey, webhookSubscriptionRequest.labelKey) &&
        Objects.equals(this.labelValue, webhookSubscriptionRequest.labelValue) &&
        Objects.equals(this.labels, webhookSubscriptionRequest.labels);
  }

  @Override
  public int hashCode() {
    return Objects.hash(description, eventTypes, isEnabled, target, metadata, labelKey, labelValue, labels);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class WebhookSubscriptionRequest {\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    eventTypes: ").append(toIndentedString(eventTypes)).append("\n");
    sb.append("    isEnabled: ").append(toIndentedString(isEnabled)).append("\n");
    sb.append("    target: ").append(toIndentedString(target)).append("\n");
    sb.append("    metadata: ").append(toIndentedString(metadata)).append("\n");
    sb.append("    labelKey: ").append(toIndentedString(labelKey)).append("\n");
    sb.append("    labelValue: ").append(toIndentedString(labelValue)).append("\n");
    sb.append("    labels: ").append(toIndentedString(labels)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

  /**
   * Convert the instance into URL query string.
   *
   * @return URL query string
   */
  public String toUrlQueryString() {
    return toUrlQueryString(null);
  }

  /**
   * Convert the instance into URL query string.
   *
   * @param prefix prefix of the query string
   * @return URL query string
   */
  public String toUrlQueryString(String prefix) {
    String suffix = "";
    String containerSuffix = "";
    String containerPrefix = "";
    if (prefix == null) {
      // style=form, explode=true, e.g. /pet?name=cat&type=manx
      prefix = "";
    } else {
      // deepObject style e.g. /pet?id[name]=cat&id[type]=manx
      prefix = prefix + "[";
      suffix = "]";
      containerSuffix = "]";
      containerPrefix = "[";
    }

    StringJoiner joiner = new StringJoiner("&");

    return joiner.toString();
  }

    public static class Builder {

    private WebhookSubscriptionRequest instance;

    public Builder() {
      this(new WebhookSubscriptionRequest());
    }

    protected Builder(WebhookSubscriptionRequest instance) {
      this.instance = instance;
    }

    public WebhookSubscriptionRequest.Builder description(String description) {
      this.instance.description = description;
      return this;
    }
    public WebhookSubscriptionRequest.Builder eventTypes(List<String> eventTypes) {
      this.instance.eventTypes = eventTypes;
      return this;
    }
    public WebhookSubscriptionRequest.Builder isEnabled(Boolean isEnabled) {
      this.instance.isEnabled = isEnabled;
      return this;
    }
    public WebhookSubscriptionRequest.Builder target(WebhookTarget target) {
      this.instance.target = target;
      return this;
    }
    public WebhookSubscriptionRequest.Builder metadata(Map<String, Object> metadata) {
      this.instance.metadata = metadata;
      return this;
    }
    public WebhookSubscriptionRequest.Builder labelKey(String labelKey) {
      this.instance.labelKey = labelKey;
      return this;
    }
    public WebhookSubscriptionRequest.Builder labelValue(String labelValue) {
      this.instance.labelValue = labelValue;
      return this;
    }
    public WebhookSubscriptionRequest.Builder labels(Map<String, String> labels) {
      this.instance.labels = labels;
      return this;
    }


    /**
    * returns a built WebhookSubscriptionRequest instance.
    *
    * The builder is not reusable.
    */
    public WebhookSubscriptionRequest build() {
      try {
        return this.instance;
      } finally {
        // ensure that this.instance is not reused
        this.instance = null;
      }
    }

    @Override
    public String toString() {
      return getClass() + "=(" + instance + ")";
    }
  }

  /**
  * Create a builder with no initialized field.
  */
  public static WebhookSubscriptionRequest.Builder builder() {
    return new WebhookSubscriptionRequest.Builder();
  }

  /**
  * Create a builder with a shallow copy of this instance.
  */
  public WebhookSubscriptionRequest.Builder toBuilder() {
    return new WebhookSubscriptionRequest.Builder();
  }

}

