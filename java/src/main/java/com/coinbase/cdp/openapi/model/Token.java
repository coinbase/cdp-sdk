/*
 * Coinbase Developer Platform APIs
 * The Coinbase Developer Platform APIs - leading the world's transition onchain.
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: cdp@coinbase.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.coinbase.cdp.openapi.model;

import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.StringJoiner;
import java.util.Objects;
import java.util.Map;
import java.util.HashMap;
import com.coinbase.cdp.openapi.model.ListEvmTokenBalancesNetwork;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import java.util.Arrays;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;


import com.coinbase.cdp.openapi.ApiClient;
/**
 * General information about a token. Includes the type, the network, and other identifying information.
 */
@JsonPropertyOrder({
  Token.JSON_PROPERTY_NETWORK,
  Token.JSON_PROPERTY_SYMBOL,
  Token.JSON_PROPERTY_NAME,
  Token.JSON_PROPERTY_CONTRACT_ADDRESS
})
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", comments = "Generator version: 7.11.0")
public class Token {
  public static final String JSON_PROPERTY_NETWORK = "network";
  @jakarta.annotation.Nonnull
  private ListEvmTokenBalancesNetwork network;

  public static final String JSON_PROPERTY_SYMBOL = "symbol";
  @jakarta.annotation.Nullable
  private String symbol;

  public static final String JSON_PROPERTY_NAME = "name";
  @jakarta.annotation.Nullable
  private String name;

  public static final String JSON_PROPERTY_CONTRACT_ADDRESS = "contractAddress";
  @jakarta.annotation.Nonnull
  private String contractAddress;

  public Token() { 
  }

  public Token network(@jakarta.annotation.Nonnull ListEvmTokenBalancesNetwork network) {
    this.network = network;
    return this;
  }

  /**
   * Get network
   * @return network
   */
  @jakarta.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_NETWORK)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public ListEvmTokenBalancesNetwork getNetwork() {
    return network;
  }


  @JsonProperty(JSON_PROPERTY_NETWORK)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setNetwork(@jakarta.annotation.Nonnull ListEvmTokenBalancesNetwork network) {
    this.network = network;
  }


  public Token symbol(@jakarta.annotation.Nullable String symbol) {
    this.symbol = symbol;
    return this;
  }

  /**
   * The symbol of this token (ex: SOL, ETH, USDC). The token symbol is not unique. It is possible for two different tokens to have the same symbol. For native gas tokens, this symbol is defined via convention. As an example, for ETH on Ethereum mainnet, the symbol is \&quot;ETH\&quot;. For ERC-20 tokens, this symbol is defined via configuration. &#x60;symbol&#x60; will be the string returned by &#x60;function symbol() public view returns (string)&#x60; on the underlying token contract. Not all tokens have a symbol, as this function is [optional in the ERC-20 specification](https://eips.ethereum.org/EIPS/eip-20#symbol). This field will only be populated when the token&#39;s underlying ERC-20 contract has a &#x60;symbol()&#x60; function. Further, this endpoint will only populate this value for a small subset of whitelisted ERC-20 tokens at this time. We intend to improve coverage in the future.
   * @return symbol
   */
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_SYMBOL)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public String getSymbol() {
    return symbol;
  }


  @JsonProperty(JSON_PROPERTY_SYMBOL)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setSymbol(@jakarta.annotation.Nullable String symbol) {
    this.symbol = symbol;
  }


  public Token name(@jakarta.annotation.Nullable String name) {
    this.name = name;
    return this;
  }

  /**
   * The name of this token (ex: \&quot;Solana\&quot;, \&quot;Ether\&quot;, \&quot;USD Coin\&quot;). The token name is not unique. It is possible for two different tokens to have the same name. For native gas tokens, this name is defined via convention. As an example, for ETH on Ethereum mainnet, the name is \&quot;Ether\&quot;. For ERC-20 tokens, this name is defined via configuration. &#x60;name&#x60; will be the string returned by &#x60;function name() public view returns (string)&#x60; on the underlying token contract. Not all tokens have a name, as this function is [optional in the ERC-20 specification](https://eips.ethereum.org/EIPS/eip-20#name). This field will only be populated when the token&#39;s underlying ERC-20 contract has a &#x60;name()&#x60; function. Further, this endpoint will only populate this value for a small subset of whitelisted ERC-20 tokens at this time. We intend to improve coverage in the future.
   * @return name
   */
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_NAME)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public String getName() {
    return name;
  }


  @JsonProperty(JSON_PROPERTY_NAME)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setName(@jakarta.annotation.Nullable String name) {
    this.name = name;
  }


  public Token contractAddress(@jakarta.annotation.Nonnull String contractAddress) {
    this.contractAddress = contractAddress;
    return this;
  }

  /**
   * The contract address of the token. For Ether, the contract address is &#x60;0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE&#x60; per [EIP-7528](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-7528.md). For ERC-20 tokens, this is the contract address where the token is deployed.
   * @return contractAddress
   */
  @jakarta.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_CONTRACT_ADDRESS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public String getContractAddress() {
    return contractAddress;
  }


  @JsonProperty(JSON_PROPERTY_CONTRACT_ADDRESS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setContractAddress(@jakarta.annotation.Nonnull String contractAddress) {
    this.contractAddress = contractAddress;
  }


  /**
   * Return true if this Token object is equal to o.
   */
  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Token token = (Token) o;
    return Objects.equals(this.network, token.network) &&
        Objects.equals(this.symbol, token.symbol) &&
        Objects.equals(this.name, token.name) &&
        Objects.equals(this.contractAddress, token.contractAddress);
  }

  @Override
  public int hashCode() {
    return Objects.hash(network, symbol, name, contractAddress);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Token {\n");
    sb.append("    network: ").append(toIndentedString(network)).append("\n");
    sb.append("    symbol: ").append(toIndentedString(symbol)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    contractAddress: ").append(toIndentedString(contractAddress)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

  /**
   * Convert the instance into URL query string.
   *
   * @return URL query string
   */
  public String toUrlQueryString() {
    return toUrlQueryString(null);
  }

  /**
   * Convert the instance into URL query string.
   *
   * @param prefix prefix of the query string
   * @return URL query string
   */
  public String toUrlQueryString(String prefix) {
    String suffix = "";
    String containerSuffix = "";
    String containerPrefix = "";
    if (prefix == null) {
      // style=form, explode=true, e.g. /pet?name=cat&type=manx
      prefix = "";
    } else {
      // deepObject style e.g. /pet?id[name]=cat&id[type]=manx
      prefix = prefix + "[";
      suffix = "]";
      containerSuffix = "]";
      containerPrefix = "[";
    }

    StringJoiner joiner = new StringJoiner("&");

    // add `network` to the URL query string
    if (getNetwork() != null) {
      joiner.add(String.format("%snetwork%s=%s", prefix, suffix, URLEncoder.encode(ApiClient.valueToString(getNetwork()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    // add `symbol` to the URL query string
    if (getSymbol() != null) {
      joiner.add(String.format("%ssymbol%s=%s", prefix, suffix, URLEncoder.encode(ApiClient.valueToString(getSymbol()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    // add `name` to the URL query string
    if (getName() != null) {
      joiner.add(String.format("%sname%s=%s", prefix, suffix, URLEncoder.encode(ApiClient.valueToString(getName()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    // add `contractAddress` to the URL query string
    if (getContractAddress() != null) {
      joiner.add(String.format("%scontractAddress%s=%s", prefix, suffix, URLEncoder.encode(ApiClient.valueToString(getContractAddress()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    return joiner.toString();
  }

    public static class Builder {

    private Token instance;

    public Builder() {
      this(new Token());
    }

    protected Builder(Token instance) {
      this.instance = instance;
    }

    public Token.Builder network(ListEvmTokenBalancesNetwork network) {
      this.instance.network = network;
      return this;
    }
    public Token.Builder symbol(String symbol) {
      this.instance.symbol = symbol;
      return this;
    }
    public Token.Builder name(String name) {
      this.instance.name = name;
      return this;
    }
    public Token.Builder contractAddress(String contractAddress) {
      this.instance.contractAddress = contractAddress;
      return this;
    }


    /**
    * returns a built Token instance.
    *
    * The builder is not reusable.
    */
    public Token build() {
      try {
        return this.instance;
      } finally {
        // ensure that this.instance is not reused
        this.instance = null;
      }
    }

    @Override
    public String toString() {
      return getClass() + "=(" + instance + ")";
    }
  }

  /**
  * Create a builder with no initialized field.
  */
  public static Token.Builder builder() {
    return new Token.Builder();
  }

  /**
  * Create a builder with a shallow copy of this instance.
  */
  public Token.Builder toBuilder() {
    return new Token.Builder()
      .network(getNetwork())
      .symbol(getSymbol())
      .name(getName())
      .contractAddress(getContractAddress());
  }

}

