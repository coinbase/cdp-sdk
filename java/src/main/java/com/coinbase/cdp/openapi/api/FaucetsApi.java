/*
 * Coinbase Developer Platform APIs
 * The Coinbase Developer Platform APIs - leading the world's transition onchain.
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: cdp@coinbase.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.coinbase.cdp.openapi.api;

import com.coinbase.cdp.openapi.ApiClient;
import com.coinbase.cdp.openapi.ApiException;
import com.coinbase.cdp.openapi.ApiResponse;
import com.coinbase.cdp.openapi.Pair;

import com.coinbase.cdp.openapi.model.Error;
import com.coinbase.cdp.openapi.model.RequestEvmFaucet200Response;
import com.coinbase.cdp.openapi.model.RequestEvmFaucetRequest;
import com.coinbase.cdp.openapi.model.RequestSolanaFaucet200Response;
import com.coinbase.cdp.openapi.model.RequestSolanaFaucetRequest;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.io.InputStream;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.OutputStream;
import java.net.http.HttpRequest;
import java.nio.channels.Channels;
import java.nio.channels.Pipe;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.Duration;

import java.util.ArrayList;
import java.util.StringJoiner;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Consumer;

@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", comments = "Generator version: 7.11.0")
public class FaucetsApi {
  private final HttpClient memberVarHttpClient;
  private final ObjectMapper memberVarObjectMapper;
  private final String memberVarBaseUri;
  private final Consumer<HttpRequest.Builder> memberVarInterceptor;
  private final Duration memberVarReadTimeout;
  private final Consumer<HttpResponse<InputStream>> memberVarResponseInterceptor;
  private final Consumer<HttpResponse<String>> memberVarAsyncResponseInterceptor;

  public FaucetsApi() {
    this(new ApiClient());
  }

  public FaucetsApi(ApiClient apiClient) {
    memberVarHttpClient = apiClient.getHttpClient();
    memberVarObjectMapper = apiClient.getObjectMapper();
    memberVarBaseUri = apiClient.getBaseUri();
    memberVarInterceptor = apiClient.getRequestInterceptor();
    memberVarReadTimeout = apiClient.getReadTimeout();
    memberVarResponseInterceptor = apiClient.getResponseInterceptor();
    memberVarAsyncResponseInterceptor = apiClient.getAsyncResponseInterceptor();
  }

  protected ApiException getApiException(String operationId, HttpResponse<InputStream> response) throws IOException {
    String body = response.body() == null ? null : new String(response.body().readAllBytes());
    String message = formatExceptionMessage(operationId, response.statusCode(), body);
    return new ApiException(response.statusCode(), message, response.headers(), body);
  }

  private String formatExceptionMessage(String operationId, int statusCode, String body) {
    if (body == null || body.isEmpty()) {
      body = "[no body]";
    }
    return operationId + " call failed with: " + statusCode + " - " + body;
  }

  /**
   * Request funds on EVM test networks
   * Request funds from the CDP Faucet on supported EVM test networks.  Faucets are available for ETH, USDC, EURC, and cbBTC on Base Sepolia and Ethereum Sepolia, and for ETH only on Ethereum Hoodi.  To prevent abuse, we enforce rate limits within a rolling 24-hour window to control the amount of funds that can be requested. These limits are applied at both the CDP User level and the blockchain address level. A single blockchain address cannot exceed the specified limits, even if multiple users submit requests to the same address.  | Token | Amount per Faucet Request |Rolling 24-hour window Rate Limits| |:-----:|:-------------------------:|:--------------------------------:| | ETH   | 0.0001 ETH                | 0.1 ETH                          | | USDC  | 1 USDC                    | 10 USDC                          | | EURC  | 1 EURC                    | 10 EURC                          | | cbBTC | 0.0001 cbBTC              | 0.001 cbBTC                      | 
   * @param requestEvmFaucetRequest  (optional)
   * @return RequestEvmFaucet200Response
   * @throws ApiException if fails to make API call
   */
  public RequestEvmFaucet200Response requestEvmFaucet(RequestEvmFaucetRequest requestEvmFaucetRequest) throws ApiException {
    ApiResponse<RequestEvmFaucet200Response> localVarResponse = requestEvmFaucetWithHttpInfo(requestEvmFaucetRequest);
    return localVarResponse.getData();
  }

  /**
   * Request funds on EVM test networks
   * Request funds from the CDP Faucet on supported EVM test networks.  Faucets are available for ETH, USDC, EURC, and cbBTC on Base Sepolia and Ethereum Sepolia, and for ETH only on Ethereum Hoodi.  To prevent abuse, we enforce rate limits within a rolling 24-hour window to control the amount of funds that can be requested. These limits are applied at both the CDP User level and the blockchain address level. A single blockchain address cannot exceed the specified limits, even if multiple users submit requests to the same address.  | Token | Amount per Faucet Request |Rolling 24-hour window Rate Limits| |:-----:|:-------------------------:|:--------------------------------:| | ETH   | 0.0001 ETH                | 0.1 ETH                          | | USDC  | 1 USDC                    | 10 USDC                          | | EURC  | 1 EURC                    | 10 EURC                          | | cbBTC | 0.0001 cbBTC              | 0.001 cbBTC                      | 
   * @param requestEvmFaucetRequest  (optional)
   * @return ApiResponse&lt;RequestEvmFaucet200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<RequestEvmFaucet200Response> requestEvmFaucetWithHttpInfo(RequestEvmFaucetRequest requestEvmFaucetRequest) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = requestEvmFaucetRequestBuilder(requestEvmFaucetRequest);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("requestEvmFaucet", localVarResponse);
        }
        if (localVarResponse.body() == null) {
          return new ApiResponse<RequestEvmFaucet200Response>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        String responseBody = new String(localVarResponse.body().readAllBytes());
        localVarResponse.body().close();

        return new ApiResponse<RequestEvmFaucet200Response>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<RequestEvmFaucet200Response>() {})
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder requestEvmFaucetRequestBuilder(RequestEvmFaucetRequest requestEvmFaucetRequest) throws ApiException {

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v2/evm/faucet";

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(requestEvmFaucetRequest);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Request funds on Solana devnet
   * Request funds from the CDP Faucet on Solana devnet.  Faucets are available for SOL.  To prevent abuse, we enforce rate limits within a rolling 24-hour window to control the amount of funds that can be requested. These limits are applied at both the CDP Project level and the blockchain address level. A single blockchain address cannot exceed the specified limits, even if multiple users submit requests to the same address.  | Token | Amount per Faucet Request |Rolling 24-hour window Rate Limits| |:-----:|:-------------------------:|:--------------------------------:| | SOL   | 0.00125 SOL               | 0.0125 SOL                       | | USDC  | 1 USDC                    | 10 USDC                          | 
   * @param requestSolanaFaucetRequest  (optional)
   * @return RequestSolanaFaucet200Response
   * @throws ApiException if fails to make API call
   */
  public RequestSolanaFaucet200Response requestSolanaFaucet(RequestSolanaFaucetRequest requestSolanaFaucetRequest) throws ApiException {
    ApiResponse<RequestSolanaFaucet200Response> localVarResponse = requestSolanaFaucetWithHttpInfo(requestSolanaFaucetRequest);
    return localVarResponse.getData();
  }

  /**
   * Request funds on Solana devnet
   * Request funds from the CDP Faucet on Solana devnet.  Faucets are available for SOL.  To prevent abuse, we enforce rate limits within a rolling 24-hour window to control the amount of funds that can be requested. These limits are applied at both the CDP Project level and the blockchain address level. A single blockchain address cannot exceed the specified limits, even if multiple users submit requests to the same address.  | Token | Amount per Faucet Request |Rolling 24-hour window Rate Limits| |:-----:|:-------------------------:|:--------------------------------:| | SOL   | 0.00125 SOL               | 0.0125 SOL                       | | USDC  | 1 USDC                    | 10 USDC                          | 
   * @param requestSolanaFaucetRequest  (optional)
   * @return ApiResponse&lt;RequestSolanaFaucet200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<RequestSolanaFaucet200Response> requestSolanaFaucetWithHttpInfo(RequestSolanaFaucetRequest requestSolanaFaucetRequest) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = requestSolanaFaucetRequestBuilder(requestSolanaFaucetRequest);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("requestSolanaFaucet", localVarResponse);
        }
        if (localVarResponse.body() == null) {
          return new ApiResponse<RequestSolanaFaucet200Response>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        String responseBody = new String(localVarResponse.body().readAllBytes());
        localVarResponse.body().close();

        return new ApiResponse<RequestSolanaFaucet200Response>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<RequestSolanaFaucet200Response>() {})
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder requestSolanaFaucetRequestBuilder(RequestSolanaFaucetRequest requestSolanaFaucetRequest) throws ApiException {

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v2/solana/faucet";

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(requestSolanaFaucetRequest);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

}
