/*
 * Coinbase Developer Platform APIs
 * The Coinbase Developer Platform APIs - leading the world's transition onchain.
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: cdp@coinbase.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.coinbase.cdp.openapi.model;

import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.StringJoiner;
import java.util.Objects;
import java.util.Map;
import java.util.HashMap;
import com.coinbase.cdp.openapi.model.MintAddressCriterion;
import com.coinbase.cdp.openapi.model.ProgramIdCriterion;
import com.coinbase.cdp.openapi.model.SolAddressCriterion;
import com.coinbase.cdp.openapi.model.SolDataCondition;
import com.coinbase.cdp.openapi.model.SolDataCriterion;
import com.coinbase.cdp.openapi.model.SolDataCriterionIdlsInner;
import com.coinbase.cdp.openapi.model.SolNetworkCriterion;
import com.coinbase.cdp.openapi.model.SolValueCriterion;
import com.coinbase.cdp.openapi.model.SplAddressCriterion;
import com.coinbase.cdp.openapi.model.SplValueCriterion;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import com.fasterxml.jackson.core.type.TypeReference;

import java.io.IOException;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;

import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.JsonToken;
import com.fasterxml.jackson.databind.DeserializationContext;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.MapperFeature;
import com.fasterxml.jackson.databind.SerializerProvider;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import com.fasterxml.jackson.databind.deser.std.StdDeserializer;
import com.fasterxml.jackson.databind.ser.std.StdSerializer;
import com.coinbase.cdp.openapi.JSON;

@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", comments = "Generator version: 7.11.0")
@JsonDeserialize(using = SendSolTransactionCriteriaInner.SendSolTransactionCriteriaInnerDeserializer.class)
@JsonSerialize(using = SendSolTransactionCriteriaInner.SendSolTransactionCriteriaInnerSerializer.class)
public class SendSolTransactionCriteriaInner extends AbstractOpenApiSchema {
    private static final Logger log = Logger.getLogger(SendSolTransactionCriteriaInner.class.getName());

    public static class SendSolTransactionCriteriaInnerSerializer extends StdSerializer<SendSolTransactionCriteriaInner> {
        public SendSolTransactionCriteriaInnerSerializer(Class<SendSolTransactionCriteriaInner> t) {
            super(t);
        }

        public SendSolTransactionCriteriaInnerSerializer() {
            this(null);
        }

        @Override
        public void serialize(SendSolTransactionCriteriaInner value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonProcessingException {
            jgen.writeObject(value.getActualInstance());
        }
    }

    public static class SendSolTransactionCriteriaInnerDeserializer extends StdDeserializer<SendSolTransactionCriteriaInner> {
        public SendSolTransactionCriteriaInnerDeserializer() {
            this(SendSolTransactionCriteriaInner.class);
        }

        public SendSolTransactionCriteriaInnerDeserializer(Class<?> vc) {
            super(vc);
        }

        @Override
        public SendSolTransactionCriteriaInner deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {
            JsonNode tree = jp.readValueAsTree();
            Object deserialized = null;
            boolean typeCoercion = ctxt.isEnabled(MapperFeature.ALLOW_COERCION_OF_SCALARS);
            int match = 0;
            JsonToken token = tree.traverse(jp.getCodec()).nextToken();
            // deserialize MintAddressCriterion
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (MintAddressCriterion.class.equals(Integer.class) || MintAddressCriterion.class.equals(Long.class) || MintAddressCriterion.class.equals(Float.class) || MintAddressCriterion.class.equals(Double.class) || MintAddressCriterion.class.equals(Boolean.class) || MintAddressCriterion.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((MintAddressCriterion.class.equals(Integer.class) || MintAddressCriterion.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((MintAddressCriterion.class.equals(Float.class) || MintAddressCriterion.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (MintAddressCriterion.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (MintAddressCriterion.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(MintAddressCriterion.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'MintAddressCriterion'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'MintAddressCriterion'", e);
            }

            // deserialize ProgramIdCriterion
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (ProgramIdCriterion.class.equals(Integer.class) || ProgramIdCriterion.class.equals(Long.class) || ProgramIdCriterion.class.equals(Float.class) || ProgramIdCriterion.class.equals(Double.class) || ProgramIdCriterion.class.equals(Boolean.class) || ProgramIdCriterion.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((ProgramIdCriterion.class.equals(Integer.class) || ProgramIdCriterion.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((ProgramIdCriterion.class.equals(Float.class) || ProgramIdCriterion.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (ProgramIdCriterion.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (ProgramIdCriterion.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(ProgramIdCriterion.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'ProgramIdCriterion'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'ProgramIdCriterion'", e);
            }

            // deserialize SolAddressCriterion
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (SolAddressCriterion.class.equals(Integer.class) || SolAddressCriterion.class.equals(Long.class) || SolAddressCriterion.class.equals(Float.class) || SolAddressCriterion.class.equals(Double.class) || SolAddressCriterion.class.equals(Boolean.class) || SolAddressCriterion.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((SolAddressCriterion.class.equals(Integer.class) || SolAddressCriterion.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((SolAddressCriterion.class.equals(Float.class) || SolAddressCriterion.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (SolAddressCriterion.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (SolAddressCriterion.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(SolAddressCriterion.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'SolAddressCriterion'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'SolAddressCriterion'", e);
            }

            // deserialize SolDataCriterion
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (SolDataCriterion.class.equals(Integer.class) || SolDataCriterion.class.equals(Long.class) || SolDataCriterion.class.equals(Float.class) || SolDataCriterion.class.equals(Double.class) || SolDataCriterion.class.equals(Boolean.class) || SolDataCriterion.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((SolDataCriterion.class.equals(Integer.class) || SolDataCriterion.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((SolDataCriterion.class.equals(Float.class) || SolDataCriterion.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (SolDataCriterion.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (SolDataCriterion.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(SolDataCriterion.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'SolDataCriterion'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'SolDataCriterion'", e);
            }

            // deserialize SolNetworkCriterion
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (SolNetworkCriterion.class.equals(Integer.class) || SolNetworkCriterion.class.equals(Long.class) || SolNetworkCriterion.class.equals(Float.class) || SolNetworkCriterion.class.equals(Double.class) || SolNetworkCriterion.class.equals(Boolean.class) || SolNetworkCriterion.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((SolNetworkCriterion.class.equals(Integer.class) || SolNetworkCriterion.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((SolNetworkCriterion.class.equals(Float.class) || SolNetworkCriterion.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (SolNetworkCriterion.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (SolNetworkCriterion.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(SolNetworkCriterion.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'SolNetworkCriterion'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'SolNetworkCriterion'", e);
            }

            // deserialize SolValueCriterion
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (SolValueCriterion.class.equals(Integer.class) || SolValueCriterion.class.equals(Long.class) || SolValueCriterion.class.equals(Float.class) || SolValueCriterion.class.equals(Double.class) || SolValueCriterion.class.equals(Boolean.class) || SolValueCriterion.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((SolValueCriterion.class.equals(Integer.class) || SolValueCriterion.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((SolValueCriterion.class.equals(Float.class) || SolValueCriterion.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (SolValueCriterion.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (SolValueCriterion.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(SolValueCriterion.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'SolValueCriterion'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'SolValueCriterion'", e);
            }

            // deserialize SplAddressCriterion
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (SplAddressCriterion.class.equals(Integer.class) || SplAddressCriterion.class.equals(Long.class) || SplAddressCriterion.class.equals(Float.class) || SplAddressCriterion.class.equals(Double.class) || SplAddressCriterion.class.equals(Boolean.class) || SplAddressCriterion.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((SplAddressCriterion.class.equals(Integer.class) || SplAddressCriterion.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((SplAddressCriterion.class.equals(Float.class) || SplAddressCriterion.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (SplAddressCriterion.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (SplAddressCriterion.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(SplAddressCriterion.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'SplAddressCriterion'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'SplAddressCriterion'", e);
            }

            // deserialize SplValueCriterion
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (SplValueCriterion.class.equals(Integer.class) || SplValueCriterion.class.equals(Long.class) || SplValueCriterion.class.equals(Float.class) || SplValueCriterion.class.equals(Double.class) || SplValueCriterion.class.equals(Boolean.class) || SplValueCriterion.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((SplValueCriterion.class.equals(Integer.class) || SplValueCriterion.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((SplValueCriterion.class.equals(Float.class) || SplValueCriterion.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (SplValueCriterion.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (SplValueCriterion.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(SplValueCriterion.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'SplValueCriterion'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'SplValueCriterion'", e);
            }

            if (match == 1) {
                SendSolTransactionCriteriaInner ret = new SendSolTransactionCriteriaInner();
                ret.setActualInstance(deserialized);
                return ret;
            }
            throw new IOException(String.format("Failed deserialization for SendSolTransactionCriteriaInner: %d classes match result, expected 1", match));
        }

        /**
         * Handle deserialization of the 'null' value.
         */
        @Override
        public SendSolTransactionCriteriaInner getNullValue(DeserializationContext ctxt) throws JsonMappingException {
            throw new JsonMappingException(ctxt.getParser(), "SendSolTransactionCriteriaInner cannot be null");
        }
    }

    // store a list of schema names defined in oneOf
    public static final Map<String, Class<?>> schemas = new HashMap<>();

    public SendSolTransactionCriteriaInner() {
        super("oneOf", Boolean.FALSE);
    }

    public SendSolTransactionCriteriaInner(MintAddressCriterion o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public SendSolTransactionCriteriaInner(ProgramIdCriterion o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public SendSolTransactionCriteriaInner(SolAddressCriterion o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public SendSolTransactionCriteriaInner(SolDataCriterion o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public SendSolTransactionCriteriaInner(SolNetworkCriterion o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public SendSolTransactionCriteriaInner(SolValueCriterion o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public SendSolTransactionCriteriaInner(SplAddressCriterion o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public SendSolTransactionCriteriaInner(SplValueCriterion o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    static {
        schemas.put("MintAddressCriterion", MintAddressCriterion.class);
        schemas.put("ProgramIdCriterion", ProgramIdCriterion.class);
        schemas.put("SolAddressCriterion", SolAddressCriterion.class);
        schemas.put("SolDataCriterion", SolDataCriterion.class);
        schemas.put("SolNetworkCriterion", SolNetworkCriterion.class);
        schemas.put("SolValueCriterion", SolValueCriterion.class);
        schemas.put("SplAddressCriterion", SplAddressCriterion.class);
        schemas.put("SplValueCriterion", SplValueCriterion.class);
        JSON.registerDescendants(SendSolTransactionCriteriaInner.class, Collections.unmodifiableMap(schemas));
    }

    @Override
    public Map<String, Class<?>> getSchemas() {
        return SendSolTransactionCriteriaInner.schemas;
    }

    /**
     * Set the instance that matches the oneOf child schema, check
     * the instance parameter is valid against the oneOf child schemas:
     * MintAddressCriterion, ProgramIdCriterion, SolAddressCriterion, SolDataCriterion, SolNetworkCriterion, SolValueCriterion, SplAddressCriterion, SplValueCriterion
     *
     * It could be an instance of the 'oneOf' schemas.
     * The oneOf child schemas may themselves be a composed schema (allOf, anyOf, oneOf).
     */
    @Override
    public void setActualInstance(Object instance) {
        if (JSON.isInstanceOf(MintAddressCriterion.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(ProgramIdCriterion.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(SolAddressCriterion.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(SolDataCriterion.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(SolNetworkCriterion.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(SolValueCriterion.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(SplAddressCriterion.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(SplValueCriterion.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        throw new RuntimeException("Invalid instance type. Must be MintAddressCriterion, ProgramIdCriterion, SolAddressCriterion, SolDataCriterion, SolNetworkCriterion, SolValueCriterion, SplAddressCriterion, SplValueCriterion");
    }

    /**
     * Get the actual instance, which can be the following:
     * MintAddressCriterion, ProgramIdCriterion, SolAddressCriterion, SolDataCriterion, SolNetworkCriterion, SolValueCriterion, SplAddressCriterion, SplValueCriterion
     *
     * @return The actual instance (MintAddressCriterion, ProgramIdCriterion, SolAddressCriterion, SolDataCriterion, SolNetworkCriterion, SolValueCriterion, SplAddressCriterion, SplValueCriterion)
     */
    @Override
    public Object getActualInstance() {
        return super.getActualInstance();
    }

    /**
     * Get the actual instance of `MintAddressCriterion`. If the actual instance is not `MintAddressCriterion`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `MintAddressCriterion`
     * @throws ClassCastException if the instance is not `MintAddressCriterion`
     */
    public MintAddressCriterion getMintAddressCriterion() throws ClassCastException {
        return (MintAddressCriterion)super.getActualInstance();
    }

    /**
     * Get the actual instance of `ProgramIdCriterion`. If the actual instance is not `ProgramIdCriterion`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `ProgramIdCriterion`
     * @throws ClassCastException if the instance is not `ProgramIdCriterion`
     */
    public ProgramIdCriterion getProgramIdCriterion() throws ClassCastException {
        return (ProgramIdCriterion)super.getActualInstance();
    }

    /**
     * Get the actual instance of `SolAddressCriterion`. If the actual instance is not `SolAddressCriterion`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `SolAddressCriterion`
     * @throws ClassCastException if the instance is not `SolAddressCriterion`
     */
    public SolAddressCriterion getSolAddressCriterion() throws ClassCastException {
        return (SolAddressCriterion)super.getActualInstance();
    }

    /**
     * Get the actual instance of `SolDataCriterion`. If the actual instance is not `SolDataCriterion`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `SolDataCriterion`
     * @throws ClassCastException if the instance is not `SolDataCriterion`
     */
    public SolDataCriterion getSolDataCriterion() throws ClassCastException {
        return (SolDataCriterion)super.getActualInstance();
    }

    /**
     * Get the actual instance of `SolNetworkCriterion`. If the actual instance is not `SolNetworkCriterion`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `SolNetworkCriterion`
     * @throws ClassCastException if the instance is not `SolNetworkCriterion`
     */
    public SolNetworkCriterion getSolNetworkCriterion() throws ClassCastException {
        return (SolNetworkCriterion)super.getActualInstance();
    }

    /**
     * Get the actual instance of `SolValueCriterion`. If the actual instance is not `SolValueCriterion`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `SolValueCriterion`
     * @throws ClassCastException if the instance is not `SolValueCriterion`
     */
    public SolValueCriterion getSolValueCriterion() throws ClassCastException {
        return (SolValueCriterion)super.getActualInstance();
    }

    /**
     * Get the actual instance of `SplAddressCriterion`. If the actual instance is not `SplAddressCriterion`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `SplAddressCriterion`
     * @throws ClassCastException if the instance is not `SplAddressCriterion`
     */
    public SplAddressCriterion getSplAddressCriterion() throws ClassCastException {
        return (SplAddressCriterion)super.getActualInstance();
    }

    /**
     * Get the actual instance of `SplValueCriterion`. If the actual instance is not `SplValueCriterion`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `SplValueCriterion`
     * @throws ClassCastException if the instance is not `SplValueCriterion`
     */
    public SplValueCriterion getSplValueCriterion() throws ClassCastException {
        return (SplValueCriterion)super.getActualInstance();
    }



  /**
   * Convert the instance into URL query string.
   *
   * @return URL query string
   */
  public String toUrlQueryString() {
    return toUrlQueryString(null);
  }

  /**
   * Convert the instance into URL query string.
   *
   * @param prefix prefix of the query string
   * @return URL query string
   */
  public String toUrlQueryString(String prefix) {
    String suffix = "";
    String containerSuffix = "";
    String containerPrefix = "";
    if (prefix == null) {
      // style=form, explode=true, e.g. /pet?name=cat&type=manx
      prefix = "";
    } else {
      // deepObject style e.g. /pet?id[name]=cat&id[type]=manx
      prefix = prefix + "[";
      suffix = "]";
      containerSuffix = "]";
      containerPrefix = "[";
    }

    StringJoiner joiner = new StringJoiner("&");

    if (getActualInstance() instanceof SolAddressCriterion) {
        if (getActualInstance() != null) {
          joiner.add(((SolAddressCriterion)getActualInstance()).toUrlQueryString(prefix + "one_of_0" + suffix));
        }
        return joiner.toString();
    }
    if (getActualInstance() instanceof SolValueCriterion) {
        if (getActualInstance() != null) {
          joiner.add(((SolValueCriterion)getActualInstance()).toUrlQueryString(prefix + "one_of_1" + suffix));
        }
        return joiner.toString();
    }
    if (getActualInstance() instanceof SplAddressCriterion) {
        if (getActualInstance() != null) {
          joiner.add(((SplAddressCriterion)getActualInstance()).toUrlQueryString(prefix + "one_of_2" + suffix));
        }
        return joiner.toString();
    }
    if (getActualInstance() instanceof SplValueCriterion) {
        if (getActualInstance() != null) {
          joiner.add(((SplValueCriterion)getActualInstance()).toUrlQueryString(prefix + "one_of_3" + suffix));
        }
        return joiner.toString();
    }
    if (getActualInstance() instanceof MintAddressCriterion) {
        if (getActualInstance() != null) {
          joiner.add(((MintAddressCriterion)getActualInstance()).toUrlQueryString(prefix + "one_of_4" + suffix));
        }
        return joiner.toString();
    }
    if (getActualInstance() instanceof SolDataCriterion) {
        if (getActualInstance() != null) {
          joiner.add(((SolDataCriterion)getActualInstance()).toUrlQueryString(prefix + "one_of_5" + suffix));
        }
        return joiner.toString();
    }
    if (getActualInstance() instanceof ProgramIdCriterion) {
        if (getActualInstance() != null) {
          joiner.add(((ProgramIdCriterion)getActualInstance()).toUrlQueryString(prefix + "one_of_6" + suffix));
        }
        return joiner.toString();
    }
    if (getActualInstance() instanceof SolNetworkCriterion) {
        if (getActualInstance() != null) {
          joiner.add(((SolNetworkCriterion)getActualInstance()).toUrlQueryString(prefix + "one_of_7" + suffix));
        }
        return joiner.toString();
    }
    return null;
  }

}

