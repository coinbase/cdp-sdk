// Package openapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.16.3 DO NOT EDIT.
package openapi

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

const (
	ApiKeyAuthScopes = "apiKeyAuth.Scopes"
)

// Defines values for AbiFunctionType.
const (
	Function AbiFunctionType = "function"
)

// Defines values for AbiInputType.
const (
	AbiInputTypeConstructor AbiInputType = "constructor"
	AbiInputTypeError       AbiInputType = "error"
	AbiInputTypeEvent       AbiInputType = "event"
	AbiInputTypeFallback    AbiInputType = "fallback"
	AbiInputTypeReceive     AbiInputType = "receive"
)

// Defines values for AbiStateMutability.
const (
	Nonpayable AbiStateMutability = "nonpayable"
	Payable    AbiStateMutability = "payable"
	Pure       AbiStateMutability = "pure"
	View       AbiStateMutability = "view"
)

// Defines values for CommonSwapResponseLiquidityAvailable.
const (
	CommonSwapResponseLiquidityAvailableTrue CommonSwapResponseLiquidityAvailable = true
)

// Defines values for CreateSpendPermissionRequestNetwork.
const (
	CreateSpendPermissionRequestNetworkArbitrum        CreateSpendPermissionRequestNetwork = "arbitrum"
	CreateSpendPermissionRequestNetworkAvalanche       CreateSpendPermissionRequestNetwork = "avalanche"
	CreateSpendPermissionRequestNetworkBase            CreateSpendPermissionRequestNetwork = "base"
	CreateSpendPermissionRequestNetworkBaseSepolia     CreateSpendPermissionRequestNetwork = "base-sepolia"
	CreateSpendPermissionRequestNetworkBnb             CreateSpendPermissionRequestNetwork = "bnb"
	CreateSpendPermissionRequestNetworkEthereum        CreateSpendPermissionRequestNetwork = "ethereum"
	CreateSpendPermissionRequestNetworkEthereumSepolia CreateSpendPermissionRequestNetwork = "ethereum-sepolia"
	CreateSpendPermissionRequestNetworkOptimism        CreateSpendPermissionRequestNetwork = "optimism"
	CreateSpendPermissionRequestNetworkOptimismSepolia CreateSpendPermissionRequestNetwork = "optimism-sepolia"
	CreateSpendPermissionRequestNetworkPolygon         CreateSpendPermissionRequestNetwork = "polygon"
	CreateSpendPermissionRequestNetworkZora            CreateSpendPermissionRequestNetwork = "zora"
)

// Defines values for CreateSwapQuoteResponseLiquidityAvailable.
const (
	CreateSwapQuoteResponseLiquidityAvailableTrue CreateSwapQuoteResponseLiquidityAvailable = true
)

// Defines values for ErrorType.
const (
	ErrorTypeAccountLimitExceeded           ErrorType = "account_limit_exceeded"
	ErrorTypeAlreadyExists                  ErrorType = "already_exists"
	ErrorTypeBadGateway                     ErrorType = "bad_gateway"
	ErrorTypeFaucetLimitExceeded            ErrorType = "faucet_limit_exceeded"
	ErrorTypeForbidden                      ErrorType = "forbidden"
	ErrorTypeGuestPermissionDenied          ErrorType = "guest_permission_denied"
	ErrorTypeGuestRegionForbidden           ErrorType = "guest_region_forbidden"
	ErrorTypeGuestTransactionCount          ErrorType = "guest_transaction_count"
	ErrorTypeGuestTransactionLimit          ErrorType = "guest_transaction_limit"
	ErrorTypeIdempotencyError               ErrorType = "idempotency_error"
	ErrorTypeInternalServerError            ErrorType = "internal_server_error"
	ErrorTypeInvalidRequest                 ErrorType = "invalid_request"
	ErrorTypeInvalidSignature               ErrorType = "invalid_signature"
	ErrorTypeInvalidSqlQuery                ErrorType = "invalid_sql_query"
	ErrorTypeMalformedTransaction           ErrorType = "malformed_transaction"
	ErrorTypeNetworkNotTradable             ErrorType = "network_not_tradable"
	ErrorTypeNotFound                       ErrorType = "not_found"
	ErrorTypePaymentMethodRequired          ErrorType = "payment_method_required"
	ErrorTypePhoneNumberVerificationExpired ErrorType = "phone_number_verification_expired"
	ErrorTypePolicyInUse                    ErrorType = "policy_in_use"
	ErrorTypePolicyViolation                ErrorType = "policy_violation"
	ErrorTypeRateLimitExceeded              ErrorType = "rate_limit_exceeded"
	ErrorTypeRequestCanceled                ErrorType = "request_canceled"
	ErrorTypeServiceUnavailable             ErrorType = "service_unavailable"
	ErrorTypeTimedOut                       ErrorType = "timed_out"
	ErrorTypeUnauthorized                   ErrorType = "unauthorized"
)

// Defines values for EthValueCriterionOperator.
const (
	EthValueCriterionOperatorEmpty      EthValueCriterionOperator = ">"
	EthValueCriterionOperatorEqualEqual EthValueCriterionOperator = "=="
	EthValueCriterionOperatorN1         EthValueCriterionOperator = ">="
	EthValueCriterionOperatorN2         EthValueCriterionOperator = "<"
	EthValueCriterionOperatorN3         EthValueCriterionOperator = "<="
)

// Defines values for EthValueCriterionType.
const (
	EthValue EthValueCriterionType = "ethValue"
)

// Defines values for EvmAddressCriterionOperator.
const (
	EvmAddressCriterionOperatorIn    EvmAddressCriterionOperator = "in"
	EvmAddressCriterionOperatorNotIn EvmAddressCriterionOperator = "not in"
)

// Defines values for EvmAddressCriterionType.
const (
	EvmAddress EvmAddressCriterionType = "evmAddress"
)

// Defines values for EvmDataCriterionType.
const (
	EvmData EvmDataCriterionType = "evmData"
)

// Defines values for EvmDataParameterConditionOperator.
const (
	EvmDataParameterConditionOperatorEmpty      EvmDataParameterConditionOperator = ">"
	EvmDataParameterConditionOperatorEqualEqual EvmDataParameterConditionOperator = "=="
	EvmDataParameterConditionOperatorN1         EvmDataParameterConditionOperator = ">="
	EvmDataParameterConditionOperatorN2         EvmDataParameterConditionOperator = "<"
	EvmDataParameterConditionOperatorN3         EvmDataParameterConditionOperator = "<="
)

// Defines values for EvmDataParameterConditionListOperator.
const (
	EvmDataParameterConditionListOperatorIn    EvmDataParameterConditionListOperator = "in"
	EvmDataParameterConditionListOperatorNotIn EvmDataParameterConditionListOperator = "not in"
)

// Defines values for EvmMessageCriterionType.
const (
	EvmMessage EvmMessageCriterionType = "evmMessage"
)

// Defines values for EvmNetworkCriterionNetworks.
const (
	EvmNetworkCriterionNetworksArbitrum        EvmNetworkCriterionNetworks = "arbitrum"
	EvmNetworkCriterionNetworksAvalanche       EvmNetworkCriterionNetworks = "avalanche"
	EvmNetworkCriterionNetworksBase            EvmNetworkCriterionNetworks = "base"
	EvmNetworkCriterionNetworksBaseSepolia     EvmNetworkCriterionNetworks = "base-sepolia"
	EvmNetworkCriterionNetworksBnb             EvmNetworkCriterionNetworks = "bnb"
	EvmNetworkCriterionNetworksEthereum        EvmNetworkCriterionNetworks = "ethereum"
	EvmNetworkCriterionNetworksEthereumSepolia EvmNetworkCriterionNetworks = "ethereum-sepolia"
	EvmNetworkCriterionNetworksOptimism        EvmNetworkCriterionNetworks = "optimism"
	EvmNetworkCriterionNetworksPolygon         EvmNetworkCriterionNetworks = "polygon"
	EvmNetworkCriterionNetworksZora            EvmNetworkCriterionNetworks = "zora"
)

// Defines values for EvmNetworkCriterionOperator.
const (
	EvmNetworkCriterionOperatorIn    EvmNetworkCriterionOperator = "in"
	EvmNetworkCriterionOperatorNotIn EvmNetworkCriterionOperator = "not in"
)

// Defines values for EvmNetworkCriterionType.
const (
	EvmNetwork EvmNetworkCriterionType = "evmNetwork"
)

// Defines values for EvmSwapsNetwork.
const (
	EvmSwapsNetworkArbitrum EvmSwapsNetwork = "arbitrum"
	EvmSwapsNetworkBase     EvmSwapsNetwork = "base"
	EvmSwapsNetworkEthereum EvmSwapsNetwork = "ethereum"
	EvmSwapsNetworkOptimism EvmSwapsNetwork = "optimism"
)

// Defines values for EvmTypedAddressConditionOperator.
const (
	EvmTypedAddressConditionOperatorIn    EvmTypedAddressConditionOperator = "in"
	EvmTypedAddressConditionOperatorNotIn EvmTypedAddressConditionOperator = "not in"
)

// Defines values for EvmTypedNumericalConditionOperator.
const (
	EvmTypedNumericalConditionOperatorEmpty      EvmTypedNumericalConditionOperator = ">"
	EvmTypedNumericalConditionOperatorEqualEqual EvmTypedNumericalConditionOperator = "=="
	EvmTypedNumericalConditionOperatorN1         EvmTypedNumericalConditionOperator = ">="
	EvmTypedNumericalConditionOperatorN2         EvmTypedNumericalConditionOperator = "<"
	EvmTypedNumericalConditionOperatorN3         EvmTypedNumericalConditionOperator = "<="
)

// Defines values for EvmUserOperationStatus.
const (
	EvmUserOperationStatusBroadcast EvmUserOperationStatus = "broadcast"
	EvmUserOperationStatusComplete  EvmUserOperationStatus = "complete"
	EvmUserOperationStatusDropped   EvmUserOperationStatus = "dropped"
	EvmUserOperationStatusFailed    EvmUserOperationStatus = "failed"
	EvmUserOperationStatusPending   EvmUserOperationStatus = "pending"
	EvmUserOperationStatusSigned    EvmUserOperationStatus = "signed"
)

// Defines values for EvmUserOperationNetwork.
const (
	EvmUserOperationNetworkArbitrum        EvmUserOperationNetwork = "arbitrum"
	EvmUserOperationNetworkAvalanche       EvmUserOperationNetwork = "avalanche"
	EvmUserOperationNetworkBase            EvmUserOperationNetwork = "base"
	EvmUserOperationNetworkBaseSepolia     EvmUserOperationNetwork = "base-sepolia"
	EvmUserOperationNetworkBnb             EvmUserOperationNetwork = "bnb"
	EvmUserOperationNetworkEthereum        EvmUserOperationNetwork = "ethereum"
	EvmUserOperationNetworkEthereumSepolia EvmUserOperationNetwork = "ethereum-sepolia"
	EvmUserOperationNetworkOptimism        EvmUserOperationNetwork = "optimism"
	EvmUserOperationNetworkPolygon         EvmUserOperationNetwork = "polygon"
	EvmUserOperationNetworkZora            EvmUserOperationNetwork = "zora"
)

// Defines values for FeeType.
const (
	ExchangeFee FeeType = "exchange_fee"
	NetworkFee  FeeType = "network_fee"
)

// Defines values for GetSwapPriceResponseLiquidityAvailable.
const (
	True GetSwapPriceResponseLiquidityAvailable = true
)

// Defines values for KnownAbiType.
const (
	Erc1155 KnownAbiType = "erc1155"
	Erc20   KnownAbiType = "erc20"
	Erc721  KnownAbiType = "erc721"
)

// Defines values for ListEvmTokenBalancesNetwork.
const (
	ListEvmTokenBalancesNetworkBase        ListEvmTokenBalancesNetwork = "base"
	ListEvmTokenBalancesNetworkBaseSepolia ListEvmTokenBalancesNetwork = "base-sepolia"
	ListEvmTokenBalancesNetworkEthereum    ListEvmTokenBalancesNetwork = "ethereum"
)

// Defines values for ListSolanaTokenBalancesNetwork.
const (
	ListSolanaTokenBalancesNetworkSolana       ListSolanaTokenBalancesNetwork = "solana"
	ListSolanaTokenBalancesNetworkSolanaDevnet ListSolanaTokenBalancesNetwork = "solana-devnet"
)

// Defines values for MintAddressCriterionOperator.
const (
	MintAddressCriterionOperatorIn    MintAddressCriterionOperator = "in"
	MintAddressCriterionOperatorNotIn MintAddressCriterionOperator = "not in"
)

// Defines values for MintAddressCriterionType.
const (
	MintAddress MintAddressCriterionType = "mintAddress"
)

// Defines values for NetUSDChangeCriterionOperator.
const (
	NetUSDChangeCriterionOperatorEmpty      NetUSDChangeCriterionOperator = ">"
	NetUSDChangeCriterionOperatorEqualEqual NetUSDChangeCriterionOperator = "=="
	NetUSDChangeCriterionOperatorN1         NetUSDChangeCriterionOperator = ">="
	NetUSDChangeCriterionOperatorN2         NetUSDChangeCriterionOperator = "<"
	NetUSDChangeCriterionOperatorN3         NetUSDChangeCriterionOperator = "<="
)

// Defines values for NetUSDChangeCriterionType.
const (
	NetUSDChange NetUSDChangeCriterionType = "netUSDChange"
)

// Defines values for OnchainDataResultSchemaColumnsType.
const (
	Bool       OnchainDataResultSchemaColumnsType = "Bool"
	Date       OnchainDataResultSchemaColumnsType = "Date"
	DateTime   OnchainDataResultSchemaColumnsType = "DateTime"
	DateTime64 OnchainDataResultSchemaColumnsType = "DateTime64"
	Float32    OnchainDataResultSchemaColumnsType = "Float32"
	Float64    OnchainDataResultSchemaColumnsType = "Float64"
	Int128     OnchainDataResultSchemaColumnsType = "Int128"
	Int16      OnchainDataResultSchemaColumnsType = "Int16"
	Int256     OnchainDataResultSchemaColumnsType = "Int256"
	Int32      OnchainDataResultSchemaColumnsType = "Int32"
	Int64      OnchainDataResultSchemaColumnsType = "Int64"
	Int8       OnchainDataResultSchemaColumnsType = "Int8"
	String     OnchainDataResultSchemaColumnsType = "String"
	UInt128    OnchainDataResultSchemaColumnsType = "UInt128"
	UInt16     OnchainDataResultSchemaColumnsType = "UInt16"
	UInt256    OnchainDataResultSchemaColumnsType = "UInt256"
	UInt32     OnchainDataResultSchemaColumnsType = "UInt32"
	UInt64     OnchainDataResultSchemaColumnsType = "UInt64"
	UInt8      OnchainDataResultSchemaColumnsType = "UInt8"
	UUID       OnchainDataResultSchemaColumnsType = "UUID"
)

// Defines values for OnrampOrderFeeType.
const (
	FEETYPEEXCHANGE OnrampOrderFeeType = "FEE_TYPE_EXCHANGE"
	FEETYPENETWORK  OnrampOrderFeeType = "FEE_TYPE_NETWORK"
)

// Defines values for OnrampOrderStatus.
const (
	ONRAMPORDERSTATUSCOMPLETED      OnrampOrderStatus = "ONRAMP_ORDER_STATUS_COMPLETED"
	ONRAMPORDERSTATUSFAILED         OnrampOrderStatus = "ONRAMP_ORDER_STATUS_FAILED"
	ONRAMPORDERSTATUSPENDINGAUTH    OnrampOrderStatus = "ONRAMP_ORDER_STATUS_PENDING_AUTH"
	ONRAMPORDERSTATUSPENDINGPAYMENT OnrampOrderStatus = "ONRAMP_ORDER_STATUS_PENDING_PAYMENT"
	ONRAMPORDERSTATUSPROCESSING     OnrampOrderStatus = "ONRAMP_ORDER_STATUS_PROCESSING"
)

// Defines values for OnrampPaymentLinkType.
const (
	PAYMENTLINKTYPEAPPLEPAYBUTTON OnrampPaymentLinkType = "PAYMENT_LINK_TYPE_APPLE_PAY_BUTTON"
)

// Defines values for OnrampPaymentMethodTypeId.
const (
	GUESTCHECKOUTAPPLEPAY OnrampPaymentMethodTypeId = "GUEST_CHECKOUT_APPLE_PAY"
)

// Defines values for PaymentMethodType.
const (
	Card        PaymentMethodType = "card"
	FiatAccount PaymentMethodType = "fiat_account"
)

// Defines values for PaymentRailAction.
const (
	Source PaymentRailAction = "source"
	Target PaymentRailAction = "target"
)

// Defines values for PolicyScope.
const (
	PolicyScopeAccount PolicyScope = "account"
	PolicyScopeProject PolicyScope = "project"
)

// Defines values for PrepareUserOperationRuleAction.
const (
	PrepareUserOperationRuleActionAccept PrepareUserOperationRuleAction = "accept"
	PrepareUserOperationRuleActionReject PrepareUserOperationRuleAction = "reject"
)

// Defines values for PrepareUserOperationRuleOperation.
const (
	PrepareUserOperation PrepareUserOperationRuleOperation = "prepareUserOperation"
)

// Defines values for SendEvmTransactionRuleAction.
const (
	SendEvmTransactionRuleActionAccept SendEvmTransactionRuleAction = "accept"
	SendEvmTransactionRuleActionReject SendEvmTransactionRuleAction = "reject"
)

// Defines values for SendEvmTransactionRuleOperation.
const (
	SendEvmTransaction SendEvmTransactionRuleOperation = "sendEvmTransaction"
)

// Defines values for SendSolTransactionRuleAction.
const (
	SendSolTransactionRuleActionAccept SendSolTransactionRuleAction = "accept"
	SendSolTransactionRuleActionReject SendSolTransactionRuleAction = "reject"
)

// Defines values for SendSolTransactionRuleOperation.
const (
	SendSolTransaction SendSolTransactionRuleOperation = "sendSolTransaction"
)

// Defines values for SendUserOperationRuleAction.
const (
	SendUserOperationRuleActionAccept SendUserOperationRuleAction = "accept"
	SendUserOperationRuleActionReject SendUserOperationRuleAction = "reject"
)

// Defines values for SendUserOperationRuleOperation.
const (
	SendUserOperation SendUserOperationRuleOperation = "sendUserOperation"
)

// Defines values for SignEvmHashRuleAction.
const (
	SignEvmHashRuleActionAccept SignEvmHashRuleAction = "accept"
	SignEvmHashRuleActionReject SignEvmHashRuleAction = "reject"
)

// Defines values for SignEvmHashRuleOperation.
const (
	SignEvmHash SignEvmHashRuleOperation = "signEvmHash"
)

// Defines values for SignEvmMessageRuleAction.
const (
	SignEvmMessageRuleActionAccept SignEvmMessageRuleAction = "accept"
	SignEvmMessageRuleActionReject SignEvmMessageRuleAction = "reject"
)

// Defines values for SignEvmMessageRuleOperation.
const (
	SignEvmMessage SignEvmMessageRuleOperation = "signEvmMessage"
)

// Defines values for SignEvmTransactionRuleAction.
const (
	SignEvmTransactionRuleActionAccept SignEvmTransactionRuleAction = "accept"
	SignEvmTransactionRuleActionReject SignEvmTransactionRuleAction = "reject"
)

// Defines values for SignEvmTransactionRuleOperation.
const (
	SignEvmTransaction SignEvmTransactionRuleOperation = "signEvmTransaction"
)

// Defines values for SignEvmTypedDataFieldCriterionType.
const (
	EvmTypedDataField SignEvmTypedDataFieldCriterionType = "evmTypedDataField"
)

// Defines values for SignEvmTypedDataRuleAction.
const (
	SignEvmTypedDataRuleActionAccept SignEvmTypedDataRuleAction = "accept"
	SignEvmTypedDataRuleActionReject SignEvmTypedDataRuleAction = "reject"
)

// Defines values for SignEvmTypedDataRuleOperation.
const (
	SignEvmTypedData SignEvmTypedDataRuleOperation = "signEvmTypedData"
)

// Defines values for SignEvmTypedDataVerifyingContractCriterionOperator.
const (
	SignEvmTypedDataVerifyingContractCriterionOperatorIn    SignEvmTypedDataVerifyingContractCriterionOperator = "in"
	SignEvmTypedDataVerifyingContractCriterionOperatorNotIn SignEvmTypedDataVerifyingContractCriterionOperator = "not in"
)

// Defines values for SignEvmTypedDataVerifyingContractCriterionType.
const (
	EvmTypedDataVerifyingContract SignEvmTypedDataVerifyingContractCriterionType = "evmTypedDataVerifyingContract"
)

// Defines values for SignSolTransactionRuleAction.
const (
	Accept SignSolTransactionRuleAction = "accept"
	Reject SignSolTransactionRuleAction = "reject"
)

// Defines values for SignSolTransactionRuleOperation.
const (
	SignSolTransaction SignSolTransactionRuleOperation = "signSolTransaction"
)

// Defines values for SolAddressCriterionOperator.
const (
	SolAddressCriterionOperatorIn    SolAddressCriterionOperator = "in"
	SolAddressCriterionOperatorNotIn SolAddressCriterionOperator = "not in"
)

// Defines values for SolAddressCriterionType.
const (
	SolAddress SolAddressCriterionType = "solAddress"
)

// Defines values for SolValueCriterionOperator.
const (
	SolValueCriterionOperatorEmpty      SolValueCriterionOperator = ">"
	SolValueCriterionOperatorEqualEqual SolValueCriterionOperator = "=="
	SolValueCriterionOperatorN1         SolValueCriterionOperator = ">="
	SolValueCriterionOperatorN2         SolValueCriterionOperator = "<"
	SolValueCriterionOperatorN3         SolValueCriterionOperator = "<="
)

// Defines values for SolValueCriterionType.
const (
	SolValue SolValueCriterionType = "solValue"
)

// Defines values for SplAddressCriterionOperator.
const (
	SplAddressCriterionOperatorIn    SplAddressCriterionOperator = "in"
	SplAddressCriterionOperatorNotIn SplAddressCriterionOperator = "not in"
)

// Defines values for SplAddressCriterionType.
const (
	SplAddress SplAddressCriterionType = "splAddress"
)

// Defines values for SplValueCriterionOperator.
const (
	SplValueCriterionOperatorEmpty      SplValueCriterionOperator = ">"
	SplValueCriterionOperatorEqualEqual SplValueCriterionOperator = "=="
	SplValueCriterionOperatorN1         SplValueCriterionOperator = ">="
	SplValueCriterionOperatorN2         SplValueCriterionOperator = "<"
	SplValueCriterionOperatorN3         SplValueCriterionOperator = "<="
)

// Defines values for SplValueCriterionType.
const (
	SplValue SplValueCriterionType = "splValue"
)

// Defines values for SwapUnavailableResponseLiquidityAvailable.
const (
	False SwapUnavailableResponseLiquidityAvailable = false
)

// Defines values for TransferSourceType.
const (
	TransferSourceTypePaymentMethod TransferSourceType = "payment_method"
)

// Defines values for TransferStatus.
const (
	TransferStatusCompleted TransferStatus = "completed"
	TransferStatusCreated   TransferStatus = "created"
	TransferStatusFailed    TransferStatus = "failed"
	TransferStatusPending   TransferStatus = "pending"
	TransferStatusStarted   TransferStatus = "started"
)

// Defines values for TransferTargetType.
const (
	TransferTargetTypeCryptoRail TransferTargetType = "crypto_rail"
)

// Defines values for SendEvmTransactionJSONBodyNetwork.
const (
	SendEvmTransactionJSONBodyNetworkArbitrum        SendEvmTransactionJSONBodyNetwork = "arbitrum"
	SendEvmTransactionJSONBodyNetworkAvalanche       SendEvmTransactionJSONBodyNetwork = "avalanche"
	SendEvmTransactionJSONBodyNetworkBase            SendEvmTransactionJSONBodyNetwork = "base"
	SendEvmTransactionJSONBodyNetworkBaseSepolia     SendEvmTransactionJSONBodyNetwork = "base-sepolia"
	SendEvmTransactionJSONBodyNetworkEthereum        SendEvmTransactionJSONBodyNetwork = "ethereum"
	SendEvmTransactionJSONBodyNetworkEthereumSepolia SendEvmTransactionJSONBodyNetwork = "ethereum-sepolia"
	SendEvmTransactionJSONBodyNetworkOptimism        SendEvmTransactionJSONBodyNetwork = "optimism"
	SendEvmTransactionJSONBodyNetworkPolygon         SendEvmTransactionJSONBodyNetwork = "polygon"
)

// Defines values for RequestEvmFaucetJSONBodyNetwork.
const (
	BaseSepolia     RequestEvmFaucetJSONBodyNetwork = "base-sepolia"
	EthereumHoodi   RequestEvmFaucetJSONBodyNetwork = "ethereum-hoodi"
	EthereumSepolia RequestEvmFaucetJSONBodyNetwork = "ethereum-sepolia"
)

// Defines values for RequestEvmFaucetJSONBodyToken.
const (
	RequestEvmFaucetJSONBodyTokenCbbtc RequestEvmFaucetJSONBodyToken = "cbbtc"
	RequestEvmFaucetJSONBodyTokenEth   RequestEvmFaucetJSONBodyToken = "eth"
	RequestEvmFaucetJSONBodyTokenEurc  RequestEvmFaucetJSONBodyToken = "eurc"
	RequestEvmFaucetJSONBodyTokenUsdc  RequestEvmFaucetJSONBodyToken = "usdc"
)

// Defines values for CreatePaymentTransferQuoteJSONBodySourceType.
const (
	CreatePaymentTransferQuoteJSONBodySourceTypePaymentMethod CreatePaymentTransferQuoteJSONBodySourceType = "payment_method"
)

// Defines values for CreatePaymentTransferQuoteJSONBodyTargetType.
const (
	CreatePaymentTransferQuoteJSONBodyTargetTypeCryptoRail CreatePaymentTransferQuoteJSONBodyTargetType = "crypto_rail"
)

// Defines values for ListPoliciesParamsScope.
const (
	ListPoliciesParamsScopeAccount ListPoliciesParamsScope = "account"
	ListPoliciesParamsScopeProject ListPoliciesParamsScope = "project"
)

// Defines values for CreatePolicyJSONBodyScope.
const (
	Account CreatePolicyJSONBodyScope = "account"
	Project CreatePolicyJSONBodyScope = "project"
)

// Defines values for SendSolanaTransactionJSONBodyNetwork.
const (
	SendSolanaTransactionJSONBodyNetworkSolana       SendSolanaTransactionJSONBodyNetwork = "solana"
	SendSolanaTransactionJSONBodyNetworkSolanaDevnet SendSolanaTransactionJSONBodyNetwork = "solana-devnet"
)

// Defines values for RequestSolanaFaucetJSONBodyToken.
const (
	RequestSolanaFaucetJSONBodyTokenSol  RequestSolanaFaucetJSONBodyToken = "sol"
	RequestSolanaFaucetJSONBodyTokenUsdc RequestSolanaFaucetJSONBodyToken = "usdc"
)

// Abi Contract ABI Specification following Solidity's external JSON interface format.
type Abi = []Abi_Item

// Abi_Item defines model for Abi.Item.
type Abi_Item struct {
	union json.RawMessage
}

// AbiFunction ABI function type for contract functions.
type AbiFunction struct {
	// Constant Deprecated. Use pure or view from stateMutability instead.
	Constant *bool `json:"constant,omitempty"`

	// Gas Deprecated. Vyper used to provide gas estimates.
	Gas *int `json:"gas,omitempty"`

	// Inputs The list of ABI parameters used for this function.
	Inputs []AbiParameter `json:"inputs"`

	// Name The name of the ABI function.
	Name string `json:"name"`

	// Outputs The values returned by this function.
	Outputs []AbiParameter `json:"outputs"`

	// Payable Deprecated. Use payable or nonpayable from `stateMutability` instead.
	Payable *bool `json:"payable,omitempty"`

	// StateMutability State mutability of a function in Solidity.
	StateMutability AbiStateMutability `json:"stateMutability"`

	// Type The type of the ABI item, must be `function`.
	Type AbiFunctionType `json:"type"`
}

// AbiFunctionType The type of the ABI item, must be `function`.
type AbiFunctionType string

// AbiInput Generic ABI item type encapsulating all other types besides `function`.
type AbiInput struct {
	// AdditionalProperties For additional information on the ABI JSON specification, see [the Solidity documentation](https://docs.soliditylang.org/en/latest/abi-spec.html#json).
	AdditionalProperties *interface{} `json:"additionalProperties,omitempty"`

	// Type The type of the ABI item.
	Type AbiInputType `json:"type"`
}

// AbiInputType The type of the ABI item.
type AbiInputType string

// AbiParameter Parameter definition for ABI functions, errors, and constructors.
type AbiParameter struct {
	// Components Used for tuple types.
	Components *[]AbiParameter `json:"components,omitempty"`

	// InternalType The internal Solidity type used by the compiler.
	InternalType *string `json:"internalType,omitempty"`

	// Name The name of the parameter.
	Name *string `json:"name,omitempty"`

	// Type The canonical type of the parameter.
	Type string `json:"type"`
}

// AbiStateMutability State mutability of a function in Solidity.
type AbiStateMutability string

// CommonSwapResponse defines model for CommonSwapResponse.
type CommonSwapResponse struct {
	// BlockNumber The block number at which the liquidity conditions were examined.
	BlockNumber string `json:"blockNumber"`

	// Fees The estimated fees for the swap.
	Fees struct {
		// GasFee The estimated gas fee for the swap.
		GasFee *TokenFee `json:"gasFee"`

		// ProtocolFee The estimated protocol fee for the swap.
		ProtocolFee *TokenFee `json:"protocolFee"`
	} `json:"fees"`

	// FromAmount The amount of the `fromToken` that will be sent in this swap, in atomic units of the `fromToken`. For example, `1000000000000000000` when sending ETH equates to 1 ETH, `1000000` when sending USDC equates to 1 USDC, etc.
	FromAmount string `json:"fromAmount"`

	// FromToken The 0x-prefixed contract address of the token that will be sent.
	FromToken string `json:"fromToken"`

	// Issues An object containing potential issues discovered during validation that could prevent the swap from being executed successfully.
	Issues struct {
		// Allowance Details of the allowances that the taker must set in order to execute the swap successfully. Null if no allowance is required.
		Allowance *struct {
			// CurrentAllowance The current allowance of the `fromToken` by the `taker`.
			CurrentAllowance string `json:"currentAllowance"`

			// Spender The 0x-prefixed address of to set the allowance on.
			Spender string `json:"spender"`
		} `json:"allowance"`

		// Balance Details of the balance of the `fromToken` that the `taker` must hold. Null if the `taker` has a sufficient balance.
		Balance *struct {
			// CurrentBalance The current balance of the `fromToken` by the `taker`.
			CurrentBalance string `json:"currentBalance"`

			// RequiredBalance The amount of the token that the `taker` must hold.
			RequiredBalance string `json:"requiredBalance"`

			// Token The 0x-prefixed contract address of the token.
			Token string `json:"token"`
		} `json:"balance"`

		// SimulationIncomplete This is set to true when the transaction cannot be validated. This can happen when the taker has an insufficient balance of the `fromToken`. Note that this does not necessarily mean that the trade will revert.
		SimulationIncomplete bool `json:"simulationIncomplete"`
	} `json:"issues"`

	// LiquidityAvailable Whether sufficient liquidity is available to settle the swap. All other fields in the response will be empty if this is false.
	LiquidityAvailable CommonSwapResponseLiquidityAvailable `json:"liquidityAvailable"`

	// MinToAmount The minimum amount of the `toToken` that must be received for the swap to succeed, in atomic units of the `toToken`.  For example, `1000000000000000000` when receiving ETH equates to 1 ETH, `1000000` when receiving USDC equates to 1 USDC, etc. This value is influenced by the `slippageBps` parameter.
	MinToAmount string `json:"minToAmount"`

	// ToAmount The amount of the `toToken` that will be received in atomic units of the `toToken`. For example, `1000000000000000000` when receiving ETH equates to 1 ETH, `1000000` when receiving USDC equates to 1 USDC, etc.
	ToAmount string `json:"toAmount"`

	// ToToken The 0x-prefixed contract address of the token that will be received.
	ToToken string `json:"toToken"`
}

// CommonSwapResponseLiquidityAvailable Whether sufficient liquidity is available to settle the swap. All other fields in the response will be empty if this is false.
type CommonSwapResponseLiquidityAvailable bool

// CreateSpendPermissionRequest defines model for CreateSpendPermissionRequest.
type CreateSpendPermissionRequest struct {
	// Allowance Maximum allowed value to spend, in atomic units for the specified token, within each period.
	Allowance string `json:"allowance"`

	// End The expiration time for this spend permission, in Unix seconds.
	End string `json:"end"`

	// ExtraData Arbitrary data to include in the permission.
	ExtraData *string `json:"extraData,omitempty"`

	// Network The network to create the spend permission on.
	Network CreateSpendPermissionRequestNetwork `json:"network"`

	// PaymasterUrl The paymaster URL of the spend permission.
	PaymasterUrl *string `json:"paymasterUrl,omitempty"`

	// Period Time duration for resetting used allowance on a recurring basis (seconds).
	Period string `json:"period"`

	// Salt An arbitrary salt to differentiate unique spend permissions with otherwise identical data.
	Salt *string `json:"salt,omitempty"`

	// Spender Entity that can spend account's tokens. Can be either a Smart Account or an EOA.
	Spender string `json:"spender"`

	// Start The start time for this spend permission, in Unix seconds.
	Start string `json:"start"`

	// Token ERC-7528 native token address (e.g. "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE" for native ETH), or an  ERC-20 contract address.
	Token string `json:"token"`
}

// CreateSpendPermissionRequestNetwork The network to create the spend permission on.
type CreateSpendPermissionRequestNetwork string

// CreateSwapQuoteResponse defines model for CreateSwapQuoteResponse.
type CreateSwapQuoteResponse struct {
	// BlockNumber The block number at which the liquidity conditions were examined.
	BlockNumber string `json:"blockNumber"`

	// Fees The estimated fees for the swap.
	Fees struct {
		// GasFee The estimated gas fee for the swap.
		GasFee *TokenFee `json:"gasFee"`

		// ProtocolFee The estimated protocol fee for the swap.
		ProtocolFee *TokenFee `json:"protocolFee"`
	} `json:"fees"`

	// FromAmount The amount of the `fromToken` that will be sent in this swap, in atomic units of the `fromToken`. For example, `1000000000000000000` when sending ETH equates to 1 ETH, `1000000` when sending USDC equates to 1 USDC, etc.
	FromAmount string `json:"fromAmount"`

	// FromToken The 0x-prefixed contract address of the token that will be sent.
	FromToken string `json:"fromToken"`

	// Issues An object containing potential issues discovered during validation that could prevent the swap from being executed successfully.
	Issues struct {
		// Allowance Details of the allowances that the taker must set in order to execute the swap successfully. Null if no allowance is required.
		Allowance *struct {
			// CurrentAllowance The current allowance of the `fromToken` by the `taker`.
			CurrentAllowance string `json:"currentAllowance"`

			// Spender The 0x-prefixed address of to set the allowance on.
			Spender string `json:"spender"`
		} `json:"allowance"`

		// Balance Details of the balance of the `fromToken` that the `taker` must hold. Null if the `taker` has a sufficient balance.
		Balance *struct {
			// CurrentBalance The current balance of the `fromToken` by the `taker`.
			CurrentBalance string `json:"currentBalance"`

			// RequiredBalance The amount of the token that the `taker` must hold.
			RequiredBalance string `json:"requiredBalance"`

			// Token The 0x-prefixed contract address of the token.
			Token string `json:"token"`
		} `json:"balance"`

		// SimulationIncomplete This is set to true when the transaction cannot be validated. This can happen when the taker has an insufficient balance of the `fromToken`. Note that this does not necessarily mean that the trade will revert.
		SimulationIncomplete bool `json:"simulationIncomplete"`
	} `json:"issues"`

	// LiquidityAvailable Whether sufficient liquidity is available to settle the swap. All other fields in the response will be empty if this is false.
	LiquidityAvailable CreateSwapQuoteResponseLiquidityAvailable `json:"liquidityAvailable"`

	// MinToAmount The minimum amount of the `toToken` that must be received for the swap to succeed, in atomic units of the `toToken`.  For example, `1000000000000000000` when receiving ETH equates to 1 ETH, `1000000` when receiving USDC equates to 1 USDC, etc. This value is influenced by the `slippageBps` parameter.
	MinToAmount string `json:"minToAmount"`

	// Permit2 The approval object which contains the necessary fields to submit an approval for this transaction. Null if the `fromToken` is the native token or the transaction is a native token wrap / unwrap.
	Permit2 *struct {
		// Eip712 The message to sign using EIP-712.
		Eip712 EIP712Message `json:"eip712"`

		// Hash The hash for the approval according to [EIP-712](https://eips.ethereum.org/EIPS/eip-712). Computing the hash of the `eip712` field should match the value of this field.
		Hash string `json:"hash"`
	} `json:"permit2"`

	// ToAmount The amount of the `toToken` that will be received in atomic units of the `toToken`. For example, `1000000000000000000` when receiving ETH equates to 1 ETH, `1000000` when receiving USDC equates to 1 USDC, etc.
	ToAmount string `json:"toAmount"`

	// ToToken The 0x-prefixed contract address of the token that will be received.
	ToToken string `json:"toToken"`

	// Transaction The details of the transaction to be signed and submitted to execute the swap.
	Transaction struct {
		// Data The hex-encoded call data to send to the contract.
		Data string `json:"data"`

		// Gas The estimated gas limit that should be used to send the transaction to guarantee settlement.
		Gas string `json:"gas"`

		// GasPrice The gas price, in Wei, that should be used to send the transaction. For EIP-1559 transactions, this value should be seen as the `maxFeePerGas` value. The transaction should be sent with this gas price to guarantee settlement.
		GasPrice string `json:"gasPrice"`

		// To The 0x-prefixed address of the contract to call.
		To string `json:"to"`

		// Value The value of the transaction in Wei.
		Value string `json:"value"`
	} `json:"transaction"`
}

// CreateSwapQuoteResponseLiquidityAvailable Whether sufficient liquidity is available to settle the swap. All other fields in the response will be empty if this is false.
type CreateSwapQuoteResponseLiquidityAvailable bool

// CreateSwapQuoteResponseWrapper A wrapper for the response of a swap quote operation.
type CreateSwapQuoteResponseWrapper struct {
	union json.RawMessage
}

// CryptoRail The crypto rails available.
type CryptoRail struct {
	// Actions The actions for the crypto rail.
	Actions []PaymentRailAction `json:"actions"`

	// Currency The currency symbol of the asset.
	Currency string `json:"currency"`

	// Name The name of the asset.
	Name string `json:"name"`

	// Networks All available networks of the asset.
	Networks []struct {
		// ChainId The chain ID of the network.
		ChainId *int64 `json:"chainId,omitempty"`

		// ContractAddress The contract address of the asset on the network.
		ContractAddress *string `json:"contractAddress,omitempty"`

		// Name The name of the network.
		Name *string `json:"name,omitempty"`
	} `json:"networks"`
}

// CryptoRailAddress The crypto rail input object which specifies the symbol, network, and address which is the source or destination wallet address.
type CryptoRailAddress struct {
	// Address The address of the payment rail. This is the source or destination wallet address. It is not a contract address.
	Address string `json:"address"`

	// Currency The symbol of the currency of the payment rail.
	Currency string `json:"currency"`

	// Network The network of the payment rail.
	Network string `json:"network"`
}

// EIP712Domain The domain of the EIP-712 typed data.
type EIP712Domain struct {
	// ChainId The chain ID of the EVM network.
	ChainId *int64 `json:"chainId,omitempty"`

	// Name The name of the DApp or protocol.
	Name *string `json:"name,omitempty"`

	// Salt The optional 32-byte 0x-prefixed hex salt for domain separation.
	Salt *string `json:"salt,omitempty"`

	// VerifyingContract The 0x-prefixed EVM address of the verifying smart contract.
	VerifyingContract *string `json:"verifyingContract,omitempty"`

	// Version The version of the DApp or protocol.
	Version *string `json:"version,omitempty"`
}

// EIP712Message The message to sign using EIP-712.
type EIP712Message struct {
	// Domain The domain of the EIP-712 typed data.
	Domain EIP712Domain `json:"domain"`

	// Message The message to sign. The structure of this message must match the `primaryType` struct in the `types` object.
	Message map[string]interface{} `json:"message"`

	// PrimaryType The primary type of the message. This is the name of the struct in the `types` object that is the root of the message.
	PrimaryType string `json:"primaryType"`

	// Types A mapping of struct names to an array of type objects (name + type).
	// Each key corresponds to a type name (e.g., "`EIP712Domain`", "`PermitTransferFrom`").
	Types EIP712Types `json:"types"`
}

// EIP712Types A mapping of struct names to an array of type objects (name + type).
// Each key corresponds to a type name (e.g., "`EIP712Domain`", "`PermitTransferFrom`").
type EIP712Types = map[string]interface{}

// Error An error response including the code for the type of error and a human-readable message describing the error.
type Error struct {
	// CorrelationId A unique identifier for the request that generated the error. This can be used to help debug issues with the API.
	CorrelationId *string `json:"correlationId,omitempty"`

	// ErrorLink A link to the corresponding error documentation.
	ErrorLink *string `json:"errorLink,omitempty"`

	// ErrorMessage The error message.
	ErrorMessage string `json:"errorMessage"`

	// ErrorType The code that indicates the type of error that occurred. These error codes can be used to determine how to handle the error.
	ErrorType ErrorType `json:"errorType"`
}

// ErrorType The code that indicates the type of error that occurred. These error codes can be used to determine how to handle the error.
type ErrorType string

// EthValueCriterion A schema for specifying a criterion for the `value` field of an EVM transaction.
type EthValueCriterion struct {
	// EthValue The amount of ETH, in wei, that the transaction's `value` field should be compared to.
	EthValue string `json:"ethValue"`

	// Operator The operator to use for the comparison. The transaction's `value` field will be on the left-hand side of the operator, and the `ethValue` field will be on the right-hand side.
	Operator EthValueCriterionOperator `json:"operator"`

	// Type The type of criterion to use. This should be `ethValue`.
	Type EthValueCriterionType `json:"type"`
}

// EthValueCriterionOperator The operator to use for the comparison. The transaction's `value` field will be on the left-hand side of the operator, and the `ethValue` field will be on the right-hand side.
type EthValueCriterionOperator string

// EthValueCriterionType The type of criterion to use. This should be `ethValue`.
type EthValueCriterionType string

// EvmAccount defines model for EvmAccount.
type EvmAccount struct {
	// Address The 0x-prefixed, checksum EVM address.
	Address string `json:"address"`

	// CreatedAt The UTC ISO 8601 timestamp at which the account was created.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Name An optional name for the account.
	// Account names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.
	// Account names are guaranteed to be unique across all EVM accounts in the developer's CDP Project.
	Name *string `json:"name,omitempty"`

	// Policies The list of policy IDs that apply to the account. This will include both the project-level policy and the account-level policy, if one exists.
	Policies *[]string `json:"policies,omitempty"`

	// UpdatedAt The UTC ISO 8601 timestamp at which the account was last updated.
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
}

// EvmAddressCriterion A schema for specifying a criterion for the `to` field of an EVM transaction.
type EvmAddressCriterion struct {
	// Addresses A list of 0x-prefixed EVM addresses that the transaction's `to` field should be compared to. There is a limit of 300 addresses per criterion.
	Addresses []string `json:"addresses"`

	// Operator The operator to use for the comparison. The transaction's `to` field will be on the left-hand side of the operator, and the `addresses` field will be on the right-hand side.
	Operator EvmAddressCriterionOperator `json:"operator"`

	// Type The type of criterion to use. This should be `evmAddress`.
	Type EvmAddressCriterionType `json:"type"`
}

// EvmAddressCriterionOperator The operator to use for the comparison. The transaction's `to` field will be on the left-hand side of the operator, and the `addresses` field will be on the right-hand side.
type EvmAddressCriterionOperator string

// EvmAddressCriterionType The type of criterion to use. This should be `evmAddress`.
type EvmAddressCriterionType string

// EvmCall defines model for EvmCall.
type EvmCall struct {
	// Data The call data to send. This is the hex-encoded data of the function call consisting of the method selector and the function arguments.
	Data string `json:"data"`

	// To The address the call is directed to.
	To string `json:"to"`

	// Value The amount of ETH to send with the call, in wei.
	Value string `json:"value"`
}

// EvmDataCondition A single condition to apply against the function and encoded arguments in the transaction's `data` field. Each `parameter` configuration must be successfully evaluated against the corresponding function argument in order for a policy to be accepted.
type EvmDataCondition struct {
	// Function The name of a smart contract function being called.
	Function string `json:"function"`

	// Params An optional list of parameter conditions to apply against encoded arguments in the transaction's `data` field.
	Params *[]EvmDataCondition_Params_Item `json:"params,omitempty"`
}

// EvmDataCondition_Params_Item A list of parameter conditions to apply against encoded arguments in the transaction's `data` field.
type EvmDataCondition_Params_Item struct {
	union json.RawMessage
}

// EvmDataCriterion A schema for specifying a criterion for the `data` field of an EVM transaction.
type EvmDataCriterion struct {
	// Abi The ABI of the smart contract being called. This can be a partial structure with only specific functions.
	Abi EvmDataCriterion_Abi `json:"abi"`

	// Conditions A list of conditions to apply against the function and encoded arguments in the transaction's `data` field. Each condition must be met in order for this policy to be accepted or rejected.
	Conditions []EvmDataCondition `json:"conditions"`

	// Type The type of criterion to use. This should be `evmData`.
	Type EvmDataCriterionType `json:"type"`
}

// EvmDataCriterion_Abi The ABI of the smart contract being called. This can be a partial structure with only specific functions.
type EvmDataCriterion_Abi struct {
	union json.RawMessage
}

// EvmDataCriterionType The type of criterion to use. This should be `evmData`.
type EvmDataCriterionType string

// EvmDataParameterCondition defines model for EvmDataParameterCondition.
type EvmDataParameterCondition struct {
	// Name The name of the parameter to check against a transaction's calldata. If name is unknown, or is not named, you may supply an array index, e.g., `0` for first parameter.
	Name string `json:"name"`

	// Operator The operator to use for the comparison. The value resolved at the `name` will be on the left-hand side of the operator, and the `value` field will be on the right-hand side.
	Operator EvmDataParameterConditionOperator `json:"operator"`

	// Value A single value to compare the value resolved at `name` to. All values are encoded as strings. Refer to the table in the documentation for how values should be encoded, and which operators are supported for each type.
	Value string `json:"value"`
}

// EvmDataParameterConditionOperator The operator to use for the comparison. The value resolved at the `name` will be on the left-hand side of the operator, and the `value` field will be on the right-hand side.
type EvmDataParameterConditionOperator string

// EvmDataParameterConditionList defines model for EvmDataParameterConditionList.
type EvmDataParameterConditionList struct {
	// Name The name of the parameter to check against a transaction's calldata. If name is unknown, or is not named, you may supply an array index, e.g., `0` for first parameter.
	Name string `json:"name"`

	// Operator The operator to use for the comparison. The value resolved at the `name` will be on the left-hand side of the operator, and the `values` field will be on the right-hand side.
	Operator EvmDataParameterConditionListOperator `json:"operator"`

	// Values Values to compare against the resolved `name` value. All values are encoded as strings. Refer to the table in the documentation for how values should be encoded, and which operators are supported for each type.
	Values []string `json:"values"`
}

// EvmDataParameterConditionListOperator The operator to use for the comparison. The value resolved at the `name` will be on the left-hand side of the operator, and the `values` field will be on the right-hand side.
type EvmDataParameterConditionListOperator string

// EvmMessageCriterion A schema for specifying a criterion for the message being signed.
type EvmMessageCriterion struct {
	// Match A regular expression the message is matched against. Accepts valid regular expression syntax described by [RE2](https://github.com/google/re2/wiki/Syntax).
	Match string `json:"match"`

	// Type The type of criterion to use. This should be `evmMessage`.
	Type EvmMessageCriterionType `json:"type"`
}

// EvmMessageCriterionType The type of criterion to use. This should be `evmMessage`.
type EvmMessageCriterionType string

// EvmNetworkCriterion A schema for specifying a criterion for the intended `network` of an EVM transaction.
type EvmNetworkCriterion struct {
	// Networks A list of EVM network identifiers that the transaction's intended `network` should be compared to.
	Networks []EvmNetworkCriterionNetworks `json:"networks"`

	// Operator The operator to use for the comparison. The transaction's intended `network` will be on the left-hand side of the operator, and the `networks` field will be on the right-hand side.
	Operator EvmNetworkCriterionOperator `json:"operator"`

	// Type The type of criterion to use. This should be `evmNetwork`.
	Type EvmNetworkCriterionType `json:"type"`
}

// EvmNetworkCriterionNetworks The network the transaction is for.
type EvmNetworkCriterionNetworks string

// EvmNetworkCriterionOperator The operator to use for the comparison. The transaction's intended `network` will be on the left-hand side of the operator, and the `networks` field will be on the right-hand side.
type EvmNetworkCriterionOperator string

// EvmNetworkCriterionType The type of criterion to use. This should be `evmNetwork`.
type EvmNetworkCriterionType string

// EvmSmartAccount defines model for EvmSmartAccount.
type EvmSmartAccount struct {
	// Address The 0x-prefixed, checksum address of the Smart Account.
	Address string `json:"address"`

	// CreatedAt The UTC ISO 8601 timestamp at which the account was created.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Name An optional name for the account.
	// Account names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.
	// Account names are guaranteed to be unique across all Smart Accounts in the developer's CDP Project.
	Name *string `json:"name,omitempty"`

	// Owners Today, only a single owner can be set for a Smart Account, but this is an array to allow having multiple owners in the future. The address is a 0x-prefixed, checksum address.
	Owners []string `json:"owners"`

	// Policies The list of policy IDs that apply to the smart account. This will include both the project-level policy and the account-level policy, if one exists.
	Policies *[]string `json:"policies,omitempty"`

	// UpdatedAt The UTC ISO 8601 timestamp at which the account was last updated.
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
}

// EvmSwapsNetwork The network on which to perform the swap.
type EvmSwapsNetwork string

// EvmTypedAddressCondition A schema for specifying criterion for an address field of an EVM typed message. The address can be deeply nested within the typed data's message.
type EvmTypedAddressCondition struct {
	// Addresses A list of 0x-prefixed EVM addresses that the value located at the message's path should be compared to. There is a limit of 300 addresses per criterion.
	Addresses []string `json:"addresses"`

	// Operator The operator to use for the comparison. The value located at the message's path will be on the left-hand side of the operator, and the `addresses` field will be on the right-hand side.
	Operator EvmTypedAddressConditionOperator `json:"operator"`

	// Path The path to the field to compare against this criterion. To reference deeply nested fields within the message, separate object keys by `.`, and access array values using `[index]`. If the field does not exist or is not an address, the operation will be rejected.
	Path string `json:"path"`
}

// EvmTypedAddressConditionOperator The operator to use for the comparison. The value located at the message's path will be on the left-hand side of the operator, and the `addresses` field will be on the right-hand side.
type EvmTypedAddressConditionOperator string

// EvmTypedNumericalCondition A schema for specifying criterion for a numerical field of an EVM typed message. The value can be deeply nested within the typed data's message.
type EvmTypedNumericalCondition struct {
	// Operator The operator to use for the comparison. The value located at the message's path will be on the left-hand side of the operator, and the `value` field will be on the right-hand side.
	Operator EvmTypedNumericalConditionOperator `json:"operator"`

	// Path The path to the field to compare against this criterion. To reference deeply nested fields within the message, separate object keys by `.`, and access array values using `[index]`. If the field does not exist or is not an address, the operation will be rejected.
	Path string `json:"path"`

	// Value The amount that the value located at the message's path should be compared to.
	Value string `json:"value"`
}

// EvmTypedNumericalConditionOperator The operator to use for the comparison. The value located at the message's path will be on the left-hand side of the operator, and the `value` field will be on the right-hand side.
type EvmTypedNumericalConditionOperator string

// EvmTypedStringCondition A schema for specifying criterion for a string field of an EVM typed message. The value can be deeply nested within the typed data's message.
type EvmTypedStringCondition struct {
	// Match A regular expression the field is matched against.
	Match string `json:"match"`

	// Path The path to the field to compare against this criterion. To reference deeply nested fields within the message, separate object keys by `.`, and access array values using `[index]`. If the field does not exist or is not an address, the operation will be rejected.
	Path string `json:"path"`
}

// EvmUserOperation defines model for EvmUserOperation.
type EvmUserOperation struct {
	// Calls The list of calls in the user operation.
	Calls []EvmCall `json:"calls"`

	// Network The network the user operation is for.
	Network EvmUserOperationNetwork `json:"network"`

	// Receipts The list of receipts associated with the user operation.
	Receipts *[]UserOperationReceipt `json:"receipts,omitempty"`

	// Status The status of the user operation.
	Status EvmUserOperationStatus `json:"status"`

	// TransactionHash The hash of the transaction that included this particular user operation. This gets set after the user operation is broadcasted and the transaction is included in a block.
	TransactionHash *string `json:"transactionHash,omitempty"`

	// UserOpHash The hash of the user operation. This is not the transaction hash, as a transaction consists of multiple user operations. The user operation hash is the hash of this particular user operation which gets signed by the owner of the Smart Account.
	UserOpHash string `json:"userOpHash"`
}

// EvmUserOperationStatus The status of the user operation.
type EvmUserOperationStatus string

// EvmUserOperationNetwork The network the user operation is for.
type EvmUserOperationNetwork string

// Fee The fee for the transfer.
type Fee struct {
	// Amount The amount of the fee.
	Amount string `json:"amount"`

	// Currency The currency of the fee.
	Currency string `json:"currency"`

	// Description The description of the fee.
	Description *string `json:"description,omitempty"`

	// Type The type of fee.
	Type FeeType `json:"type"`
}

// FeeType The type of fee.
type FeeType string

// GetSwapPriceResponse defines model for GetSwapPriceResponse.
type GetSwapPriceResponse struct {
	// BlockNumber The block number at which the liquidity conditions were examined.
	BlockNumber string `json:"blockNumber"`

	// Fees The estimated fees for the swap.
	Fees struct {
		// GasFee The estimated gas fee for the swap.
		GasFee *TokenFee `json:"gasFee"`

		// ProtocolFee The estimated protocol fee for the swap.
		ProtocolFee *TokenFee `json:"protocolFee"`
	} `json:"fees"`

	// FromAmount The amount of the `fromToken` that will be sent in this swap, in atomic units of the `fromToken`. For example, `1000000000000000000` when sending ETH equates to 1 ETH, `1000000` when sending USDC equates to 1 USDC, etc.
	FromAmount string `json:"fromAmount"`

	// FromToken The 0x-prefixed contract address of the token that will be sent.
	FromToken string `json:"fromToken"`

	// Gas The estimated gas limit that should be used to send the transaction to guarantee settlement.
	Gas *string `json:"gas"`

	// GasPrice The gas price, in Wei, that should be used to send the transaction. For EIP-1559 transactions, this value should be seen as the `maxFeePerGas` value. The transaction should be sent with this gas price to guarantee settlement.
	GasPrice string `json:"gasPrice"`

	// Issues An object containing potential issues discovered during validation that could prevent the swap from being executed successfully.
	Issues struct {
		// Allowance Details of the allowances that the taker must set in order to execute the swap successfully. Null if no allowance is required.
		Allowance *struct {
			// CurrentAllowance The current allowance of the `fromToken` by the `taker`.
			CurrentAllowance string `json:"currentAllowance"`

			// Spender The 0x-prefixed address of to set the allowance on.
			Spender string `json:"spender"`
		} `json:"allowance"`

		// Balance Details of the balance of the `fromToken` that the `taker` must hold. Null if the `taker` has a sufficient balance.
		Balance *struct {
			// CurrentBalance The current balance of the `fromToken` by the `taker`.
			CurrentBalance string `json:"currentBalance"`

			// RequiredBalance The amount of the token that the `taker` must hold.
			RequiredBalance string `json:"requiredBalance"`

			// Token The 0x-prefixed contract address of the token.
			Token string `json:"token"`
		} `json:"balance"`

		// SimulationIncomplete This is set to true when the transaction cannot be validated. This can happen when the taker has an insufficient balance of the `fromToken`. Note that this does not necessarily mean that the trade will revert.
		SimulationIncomplete bool `json:"simulationIncomplete"`
	} `json:"issues"`

	// LiquidityAvailable Whether sufficient liquidity is available to settle the swap. All other fields in the response will be empty if this is false.
	LiquidityAvailable GetSwapPriceResponseLiquidityAvailable `json:"liquidityAvailable"`

	// MinToAmount The minimum amount of the `toToken` that must be received for the swap to succeed, in atomic units of the `toToken`.  For example, `1000000000000000000` when receiving ETH equates to 1 ETH, `1000000` when receiving USDC equates to 1 USDC, etc. This value is influenced by the `slippageBps` parameter.
	MinToAmount string `json:"minToAmount"`

	// ToAmount The amount of the `toToken` that will be received in atomic units of the `toToken`. For example, `1000000000000000000` when receiving ETH equates to 1 ETH, `1000000` when receiving USDC equates to 1 USDC, etc.
	ToAmount string `json:"toAmount"`

	// ToToken The 0x-prefixed contract address of the token that will be received.
	ToToken string `json:"toToken"`
}

// GetSwapPriceResponseLiquidityAvailable Whether sufficient liquidity is available to settle the swap. All other fields in the response will be empty if this is false.
type GetSwapPriceResponseLiquidityAvailable bool

// GetSwapPriceResponseWrapper A wrapper for the response of a swap price operation.
type GetSwapPriceResponseWrapper struct {
	union json.RawMessage
}

// KnownAbiType A reference to an established EIP standard. When referencing a `KnownAbiType` within a policy rule configuring an `EvmDataCriterion`, criteria will only decode function data officially documented in the standard. For more information on supported token standards, see the links below.
//   - [erc20 - Token Standard](https://eips.ethereum.org/EIPS/eip-20).
//   - [erc721 - Non-Fungible Token Standard](https://eips.ethereum.org/EIPS/eip-721).
//   - [erc1155 - Multi Token Standard](https://eips.ethereum.org/EIPS/eip-1155).
type KnownAbiType string

// ListEvmTokenBalancesNetwork The name of the supported EVM networks in human-readable format.
type ListEvmTokenBalancesNetwork string

// ListResponse defines model for ListResponse.
type ListResponse struct {
	// NextPageToken The token for the next page of items, if any.
	NextPageToken *string `json:"nextPageToken,omitempty"`
}

// ListSolanaTokenBalancesNetwork The name of the supported Solana networks in human-readable format.
type ListSolanaTokenBalancesNetwork string

// MintAddressCriterion The criterion for the token mint addresses of a Solana transaction's SPL token transfer instructions.
type MintAddressCriterion struct {
	// Addresses The Solana addresses that are compared to the list of token mint addresses in the transaction's `accountKeys` (for legacy transactions) or `staticAccountKeys` (for V0 transactions) array.
	Addresses []string `json:"addresses"`

	// Operator The operator to use for the comparison. Each of the token mint addresses in the transaction's `accountKeys` (for legacy transactions) or `staticAccountKeys` (for V0 transactions) array will be on the left-hand side of the operator, and the `addresses` field will be on the right-hand side.
	Operator MintAddressCriterionOperator `json:"operator"`

	// Type The type of criterion to use. This should be `mintAddress`.
	Type MintAddressCriterionType `json:"type"`
}

// MintAddressCriterionOperator The operator to use for the comparison. Each of the token mint addresses in the transaction's `accountKeys` (for legacy transactions) or `staticAccountKeys` (for V0 transactions) array will be on the left-hand side of the operator, and the `addresses` field will be on the right-hand side.
type MintAddressCriterionOperator string

// MintAddressCriterionType The type of criterion to use. This should be `mintAddress`.
type MintAddressCriterionType string

// NetUSDChangeCriterion A schema for specifying a criterion for the USD denominated asset transfer or exposure for a transaction. This includes native transfers, as well as token transfers.
type NetUSDChangeCriterion struct {
	// ChangeCents The amount of USD, in cents, that the total value of a transaction's asset transfer should be compared to.
	ChangeCents int `json:"changeCents"`

	// Operator The operator to use for the comparison. The total value of a transaction's asset transfer will be on the left-hand side of the operator, and the `changeCents` field will be on the right-hand side.
	Operator NetUSDChangeCriterionOperator `json:"operator"`

	// Type The type of criterion to use. This should be `netUSDChange`.
	Type NetUSDChangeCriterionType `json:"type"`
}

// NetUSDChangeCriterionOperator The operator to use for the comparison. The total value of a transaction's asset transfer will be on the left-hand side of the operator, and the `changeCents` field will be on the right-hand side.
type NetUSDChangeCriterionOperator string

// NetUSDChangeCriterionType The type of criterion to use. This should be `netUSDChange`.
type NetUSDChangeCriterionType string

// OnchainDataQuery Request to execute a SQL query against indexed blockchain data.
type OnchainDataQuery struct {
	// Sql SQL query to execute against the indexed blockchain data.
	Sql string `json:"sql"`
}

// OnchainDataResult Result of executing a SQL query.
type OnchainDataResult struct {
	// Metadata Metadata about query execution.
	Metadata *struct {
		// Cached Whether the result was served from cache.
		Cached *bool `json:"cached,omitempty"`

		// ExecutionTimeMs Query execution time in milliseconds.
		ExecutionTimeMs *int `json:"executionTimeMs,omitempty"`

		// RowCount Number of rows returned.
		RowCount *int `json:"rowCount,omitempty"`
	} `json:"metadata,omitempty"`

	// Result Query result as an array of objects representing rows.
	Result *[]map[string]interface{} `json:"result,omitempty"`

	// Schema Schema information for the query result. This is a derived schema from the query result, so types may not match the underlying table.
	Schema *struct {
		// Columns Column definitions.
		Columns *[]struct {
			// Name Column name.
			Name *string `json:"name,omitempty"`

			// Type Column data type (ClickHouse types).
			Type *OnchainDataResultSchemaColumnsType `json:"type,omitempty"`
		} `json:"columns,omitempty"`
	} `json:"schema,omitempty"`
}

// OnchainDataResultSchemaColumnsType Column data type (ClickHouse types).
type OnchainDataResultSchemaColumnsType string

// OnrampOrder An Onramp order.
type OnrampOrder struct {
	// CreatedAt The date and time the order was created.
	CreatedAt string `json:"createdAt"`

	// DestinationAddress The destination address to send the crypto to.
	DestinationAddress string `json:"destinationAddress"`

	// DestinationNetwork The network to send the crypto on.
	DestinationNetwork string `json:"destinationNetwork"`

	// ExchangeRate The exchange rate used to convert fiat to crypto i.e. the crypto value of one fiat.
	ExchangeRate string `json:"exchangeRate"`

	// Fees The fees associated with the order.
	Fees []OnrampOrderFee `json:"fees"`

	// OrderId The ID of the onramp order.
	OrderId string `json:"orderId"`

	// PaymentCurrency The fiat currency to be converted to crypto.
	PaymentCurrency string `json:"paymentCurrency"`

	// PaymentMethod The type of payment method to be used to complete the order.
	PaymentMethod OnrampPaymentMethodTypeId `json:"paymentMethod"`

	// PaymentSubtotal The amount of fiat to be converted to crypto.
	PaymentSubtotal string `json:"paymentSubtotal"`

	// PaymentTotal The total amount of fiat to be paid, inclusive of any fees.
	PaymentTotal string `json:"paymentTotal"`

	// PurchaseAmount The amount of crypto to be purchased.
	PurchaseAmount string `json:"purchaseAmount"`

	// PurchaseCurrency The crypto currency to be purchased.
	PurchaseCurrency string `json:"purchaseCurrency"`

	// Status The status of an onramp order.
	Status OnrampOrderStatus `json:"status"`

	// TxHash The transaction hash of the order (only available once crypto has been sent).
	TxHash *string `json:"txHash,omitempty"`

	// UpdatedAt The date and time the order was last updated.
	UpdatedAt string `json:"updatedAt"`
}

// OnrampOrderFee A fee associated with an order.
type OnrampOrderFee struct {
	// Amount The amount of the fee.
	Amount string `json:"amount"`

	// Currency The currency of the fee.
	Currency string `json:"currency"`

	// Type The type of fee.
	Type OnrampOrderFeeType `json:"type"`
}

// OnrampOrderFeeType The type of fee.
type OnrampOrderFeeType string

// OnrampOrderStatus The status of an onramp order.
type OnrampOrderStatus string

// OnrampPaymentLink A payment link to pay for an order.
//
// Please refer to the [Onramp docs](https://docs.cdp.coinbase.com/onramp-&-offramp/onramp-apis/onramp-overview) for details on how to integrate with the different payment link types.
type OnrampPaymentLink struct {
	// PaymentLinkType The type of payment link.
	PaymentLinkType OnrampPaymentLinkType `json:"paymentLinkType"`

	// Url The URL to the hosted widget the user should be redirected to. For certain payment link types you can append your  own redirect_url query parameter to this URL to ensure the user is redirected back to your app after the widget completes.
	Url string `json:"url"`
}

// OnrampPaymentLinkType The type of payment link.
type OnrampPaymentLinkType string

// OnrampPaymentMethodTypeId The type of payment method to be used to complete the order.
type OnrampPaymentMethodTypeId string

// PaymentMethod The fiat payment method object.
type PaymentMethod struct {
	// Actions The actions for the payment method.
	Actions []PaymentRailAction `json:"actions"`

	// Currency The currency of the payment method.
	Currency string `json:"currency"`

	// Id The ID of the payment method which previously was added.
	Id string `json:"id"`

	// Limits The limits of the payment method.
	Limits *struct {
		// SourceLimit The limit for this payment method being used as a source for transfers.
		SourceLimit *struct {
			// Amount The amount of the limit.
			Amount *string `json:"amount,omitempty"`

			// Currency The currency of the limit.
			Currency *string `json:"currency,omitempty"`
		} `json:"sourceLimit,omitempty"`

		// TargetLimit The limit for this payment method being used as a target for transfers.
		TargetLimit *struct {
			// Amount The amount of the limit.
			Amount *string `json:"amount,omitempty"`

			// Currency The currency of the limit.
			Currency *string `json:"currency,omitempty"`
		} `json:"targetLimit,omitempty"`
	} `json:"limits,omitempty"`

	// Type The type of payment method.
	Type PaymentMethodType `json:"type"`
}

// PaymentMethodType The type of payment method.
type PaymentMethodType string

// PaymentMethodRequest The fiat payment method request object.
type PaymentMethodRequest struct {
	// Id The ID of the payment method.
	Id string `json:"id"`
}

// PaymentRailAction The action of the payment method.
type PaymentRailAction string

// Policy defines model for Policy.
type Policy struct {
	// CreatedAt The ISO 8601 timestamp at which the Policy was created.
	CreatedAt string `json:"createdAt"`

	// Description An optional human-readable description of the policy.
	// Policy descriptions can consist of alphanumeric characters, spaces, commas, and periods, and be 50 characters or less.
	Description *string `json:"description,omitempty"`

	// Id The unique identifier for the policy.
	Id string `json:"id"`

	// Rules A list of rules that comprise the policy.
	Rules []Rule `json:"rules"`

	// Scope The scope of the policy. Only one project-level policy can exist at any time.
	Scope PolicyScope `json:"scope"`

	// UpdatedAt The ISO 8601 timestamp at which the Policy was last updated.
	UpdatedAt string `json:"updatedAt"`
}

// PolicyScope The scope of the policy. Only one project-level policy can exist at any time.
type PolicyScope string

// PrepareUserOperationCriteria A schema for specifying criteria for the PrepareUserOperation operation.
type PrepareUserOperationCriteria = []PrepareUserOperationCriteria_Item

// PrepareUserOperationCriteria_Item defines model for PrepareUserOperationCriteria.Item.
type PrepareUserOperationCriteria_Item struct {
	union json.RawMessage
}

// PrepareUserOperationRule defines model for PrepareUserOperationRule.
type PrepareUserOperationRule struct {
	// Action Whether matching the rule will cause the request to be rejected or accepted.
	Action PrepareUserOperationRuleAction `json:"action"`

	// Criteria A schema for specifying criteria for the PrepareUserOperation operation.
	Criteria PrepareUserOperationCriteria `json:"criteria"`

	// Operation The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.
	Operation PrepareUserOperationRuleOperation `json:"operation"`
}

// PrepareUserOperationRuleAction Whether matching the rule will cause the request to be rejected or accepted.
type PrepareUserOperationRuleAction string

// PrepareUserOperationRuleOperation The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.
type PrepareUserOperationRuleOperation string

// RevokeSpendPermissionRequest defines model for RevokeSpendPermissionRequest.
type RevokeSpendPermissionRequest struct {
	// Network The network of the spend permission.
	Network string `json:"network"`

	// PaymasterUrl The paymaster URL of the spend permission.
	PaymasterUrl *string `json:"paymasterUrl,omitempty"`

	// PermissionHash The hash of the spend permission to revoke.
	PermissionHash string `json:"permissionHash"`
}

// Rule A rule that limits the behavior of an account.
type Rule struct {
	union json.RawMessage
}

// SendEvmTransactionCriteria A schema for specifying criteria for the SignEvmTransaction operation.
type SendEvmTransactionCriteria = []SendEvmTransactionCriteria_Item

// SendEvmTransactionCriteria_Item defines model for SendEvmTransactionCriteria.Item.
type SendEvmTransactionCriteria_Item struct {
	union json.RawMessage
}

// SendEvmTransactionRule defines model for SendEvmTransactionRule.
type SendEvmTransactionRule struct {
	// Action Whether matching the rule will cause the request to be rejected or accepted.
	Action SendEvmTransactionRuleAction `json:"action"`

	// Criteria A schema for specifying criteria for the SignEvmTransaction operation.
	Criteria SendEvmTransactionCriteria `json:"criteria"`

	// Operation The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.
	Operation SendEvmTransactionRuleOperation `json:"operation"`
}

// SendEvmTransactionRuleAction Whether matching the rule will cause the request to be rejected or accepted.
type SendEvmTransactionRuleAction string

// SendEvmTransactionRuleOperation The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.
type SendEvmTransactionRuleOperation string

// SendSolTransactionCriteria A schema for specifying criteria for the SendSolTransaction operation.
type SendSolTransactionCriteria = []SendSolTransactionCriteria_Item

// SendSolTransactionCriteria_Item defines model for SendSolTransactionCriteria.Item.
type SendSolTransactionCriteria_Item struct {
	union json.RawMessage
}

// SendSolTransactionRule defines model for SendSolTransactionRule.
type SendSolTransactionRule struct {
	// Action Whether matching the rule will cause the request to be rejected or accepted.
	Action SendSolTransactionRuleAction `json:"action"`

	// Criteria A schema for specifying criteria for the SendSolTransaction operation.
	Criteria SendSolTransactionCriteria `json:"criteria"`

	// Operation The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.
	Operation SendSolTransactionRuleOperation `json:"operation"`
}

// SendSolTransactionRuleAction Whether matching the rule will cause the request to be rejected or accepted.
type SendSolTransactionRuleAction string

// SendSolTransactionRuleOperation The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.
type SendSolTransactionRuleOperation string

// SendUserOperationCriteria A schema for specifying criteria for the SendUserOperation operation.
type SendUserOperationCriteria = []SendUserOperationCriteria_Item

// SendUserOperationCriteria_Item defines model for SendUserOperationCriteria.Item.
type SendUserOperationCriteria_Item struct {
	union json.RawMessage
}

// SendUserOperationRule defines model for SendUserOperationRule.
type SendUserOperationRule struct {
	// Action Whether matching the rule will cause the request to be rejected or accepted.
	Action SendUserOperationRuleAction `json:"action"`

	// Criteria A schema for specifying criteria for the SendUserOperation operation.
	Criteria SendUserOperationCriteria `json:"criteria"`

	// Operation The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.
	Operation SendUserOperationRuleOperation `json:"operation"`
}

// SendUserOperationRuleAction Whether matching the rule will cause the request to be rejected or accepted.
type SendUserOperationRuleAction string

// SendUserOperationRuleOperation The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.
type SendUserOperationRuleOperation string

// SignEvmHashRule defines model for SignEvmHashRule.
type SignEvmHashRule struct {
	// Action Whether any attempts to sign a hash will be accepted or rejected. This rule does not accept any criteria.
	Action SignEvmHashRuleAction `json:"action"`

	// Operation The operation to which the rule applies.
	Operation SignEvmHashRuleOperation `json:"operation"`
}

// SignEvmHashRuleAction Whether any attempts to sign a hash will be accepted or rejected. This rule does not accept any criteria.
type SignEvmHashRuleAction string

// SignEvmHashRuleOperation The operation to which the rule applies.
type SignEvmHashRuleOperation string

// SignEvmMessageCriteria A schema for specifying the rejection criteria for the SignEvmMessage operation.
type SignEvmMessageCriteria = []SignEvmMessageCriteria_Item

// SignEvmMessageCriteria_Item defines model for SignEvmMessageCriteria.Item.
type SignEvmMessageCriteria_Item struct {
	union json.RawMessage
}

// SignEvmMessageRule defines model for SignEvmMessageRule.
type SignEvmMessageRule struct {
	// Action Whether matching the rule will cause the request to be rejected or accepted.
	Action SignEvmMessageRuleAction `json:"action"`

	// Criteria A schema for specifying the rejection criteria for the SignEvmMessage operation.
	Criteria SignEvmMessageCriteria `json:"criteria"`

	// Operation The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.
	Operation SignEvmMessageRuleOperation `json:"operation"`
}

// SignEvmMessageRuleAction Whether matching the rule will cause the request to be rejected or accepted.
type SignEvmMessageRuleAction string

// SignEvmMessageRuleOperation The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.
type SignEvmMessageRuleOperation string

// SignEvmTransactionCriteria A schema for specifying criteria for the SignEvmTransaction operation.
type SignEvmTransactionCriteria = []SignEvmTransactionCriteria_Item

// SignEvmTransactionCriteria_Item defines model for SignEvmTransactionCriteria.Item.
type SignEvmTransactionCriteria_Item struct {
	union json.RawMessage
}

// SignEvmTransactionRule defines model for SignEvmTransactionRule.
type SignEvmTransactionRule struct {
	// Action Whether matching the rule will cause the request to be rejected or accepted.
	Action SignEvmTransactionRuleAction `json:"action"`

	// Criteria A schema for specifying criteria for the SignEvmTransaction operation.
	Criteria SignEvmTransactionCriteria `json:"criteria"`

	// Operation The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.
	Operation SignEvmTransactionRuleOperation `json:"operation"`
}

// SignEvmTransactionRuleAction Whether matching the rule will cause the request to be rejected or accepted.
type SignEvmTransactionRuleAction string

// SignEvmTransactionRuleOperation The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.
type SignEvmTransactionRuleOperation string

// SignEvmTypedDataCriteria A schema for specifying criteria for the SignEvmTypedData operation.
type SignEvmTypedDataCriteria = []SignEvmTypedDataCriteria_Item

// SignEvmTypedDataCriteria_Item defines model for SignEvmTypedDataCriteria.Item.
type SignEvmTypedDataCriteria_Item struct {
	union json.RawMessage
}

// SignEvmTypedDataFieldCriterion defines model for SignEvmTypedDataFieldCriterion.
type SignEvmTypedDataFieldCriterion struct {
	// Conditions A list of conditions to check against the data being signed. Each condition must be met for the rule to take effect.
	Conditions []SignEvmTypedDataFieldCriterion_Conditions_Item `json:"conditions"`

	// Type The type of criterion to use. This should be `evmTypedDataField`.
	Type SignEvmTypedDataFieldCriterionType `json:"type"`

	// Types An object containing EIP-712 type definitions, as well as a primary type for the root message object.
	Types struct {
		// PrimaryType The name of the root EIP-712 type. This value must be included in the `types` object.
		PrimaryType string `json:"primaryType"`

		// Types EIP-712 compliant map of model names to model definitions.
		Types map[string][]struct {
			// Name The name of a key within an EIP-712 data structure.
			Name *string `json:"name,omitempty"`

			// Type The Solidity type of a value within an EIP-712 data structure.
			Type *string `json:"type,omitempty"`
		} `json:"types"`
	} `json:"types"`
}

// SignEvmTypedDataFieldCriterion_Conditions_Item defines model for SignEvmTypedDataFieldCriterion.conditions.Item.
type SignEvmTypedDataFieldCriterion_Conditions_Item struct {
	union json.RawMessage
}

// SignEvmTypedDataFieldCriterionType The type of criterion to use. This should be `evmTypedDataField`.
type SignEvmTypedDataFieldCriterionType string

// SignEvmTypedDataRule defines model for SignEvmTypedDataRule.
type SignEvmTypedDataRule struct {
	// Action Whether matching the rule will cause the request to be rejected or accepted.
	Action SignEvmTypedDataRuleAction `json:"action"`

	// Criteria A schema for specifying criteria for the SignEvmTypedData operation.
	Criteria SignEvmTypedDataCriteria `json:"criteria"`

	// Operation The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.
	Operation SignEvmTypedDataRuleOperation `json:"operation"`
}

// SignEvmTypedDataRuleAction Whether matching the rule will cause the request to be rejected or accepted.
type SignEvmTypedDataRuleAction string

// SignEvmTypedDataRuleOperation The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.
type SignEvmTypedDataRuleOperation string

// SignEvmTypedDataVerifyingContractCriterion A schema for specifying criterion for a domain's verifying contract.
type SignEvmTypedDataVerifyingContractCriterion struct {
	// Addresses A list of 0x-prefixed EVM addresses that the domain's verifying contract should be compared to. There is a limit of 300 addresses per criterion.
	Addresses []string `json:"addresses"`

	// Operator The operator to use for the comparison. The domain's verifying contract will be on the left-hand side of the operator, and the `addresses` field will be on the right-hand side.
	Operator SignEvmTypedDataVerifyingContractCriterionOperator `json:"operator"`

	// Type The type of criterion to use. This should be `evmTypedDataVerifyingContract`.
	Type SignEvmTypedDataVerifyingContractCriterionType `json:"type"`
}

// SignEvmTypedDataVerifyingContractCriterionOperator The operator to use for the comparison. The domain's verifying contract will be on the left-hand side of the operator, and the `addresses` field will be on the right-hand side.
type SignEvmTypedDataVerifyingContractCriterionOperator string

// SignEvmTypedDataVerifyingContractCriterionType The type of criterion to use. This should be `evmTypedDataVerifyingContract`.
type SignEvmTypedDataVerifyingContractCriterionType string

// SignSolTransactionCriteria A schema for specifying criteria for the SignSolTransaction operation.
type SignSolTransactionCriteria = []SignSolTransactionCriteria_Item

// SignSolTransactionCriteria_Item defines model for SignSolTransactionCriteria.Item.
type SignSolTransactionCriteria_Item struct {
	union json.RawMessage
}

// SignSolTransactionRule defines model for SignSolTransactionRule.
type SignSolTransactionRule struct {
	// Action Whether matching the rule will cause the request to be rejected or accepted.
	Action SignSolTransactionRuleAction `json:"action"`

	// Criteria A schema for specifying criteria for the SignSolTransaction operation.
	Criteria SignSolTransactionCriteria `json:"criteria"`

	// Operation The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.
	Operation SignSolTransactionRuleOperation `json:"operation"`
}

// SignSolTransactionRuleAction Whether matching the rule will cause the request to be rejected or accepted.
type SignSolTransactionRuleAction string

// SignSolTransactionRuleOperation The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.
type SignSolTransactionRuleOperation string

// SolAddressCriterion The criterion for the recipient addresses of a Solana transaction's native transfer instruction.
type SolAddressCriterion struct {
	// Addresses The Solana addresses that are compared to the list of native transfer recipient addresses in the transaction's `accountKeys` (for legacy transactions) or `staticAccountKeys` (for V0 transactions) array.
	Addresses []string `json:"addresses"`

	// Operator The operator to use for the comparison. Each of the native transfer recipient addresses in the transaction's `accountKeys` (for legacy transactions) or `staticAccountKeys` (for V0 transactions) array will be on the left-hand side of the operator, and the `addresses` field will be on the right-hand side.
	Operator SolAddressCriterionOperator `json:"operator"`

	// Type The type of criterion to use. This should be `solAddress`.
	Type SolAddressCriterionType `json:"type"`
}

// SolAddressCriterionOperator The operator to use for the comparison. Each of the native transfer recipient addresses in the transaction's `accountKeys` (for legacy transactions) or `staticAccountKeys` (for V0 transactions) array will be on the left-hand side of the operator, and the `addresses` field will be on the right-hand side.
type SolAddressCriterionOperator string

// SolAddressCriterionType The type of criterion to use. This should be `solAddress`.
type SolAddressCriterionType string

// SolValueCriterion The criterion for the SOL value in lamports of a native transfer instruction in a Solana transaction.
type SolValueCriterion struct {
	// Operator The operator to use for the comparison. The transaction instruction's `value` field will be on the left-hand side of the operator, and the `solValue` field will be on the right-hand side.
	Operator SolValueCriterionOperator `json:"operator"`

	// SolValue The amount of SOL in lamports that the transaction instruction's `value` field should be compared to.
	SolValue string `json:"solValue"`

	// Type The type of criterion to use. This should be `solValue`.
	Type SolValueCriterionType `json:"type"`
}

// SolValueCriterionOperator The operator to use for the comparison. The transaction instruction's `value` field will be on the left-hand side of the operator, and the `solValue` field will be on the right-hand side.
type SolValueCriterionOperator string

// SolValueCriterionType The type of criterion to use. This should be `solValue`.
type SolValueCriterionType string

// SolanaAccount defines model for SolanaAccount.
type SolanaAccount struct {
	// Address The base58 encoded Solana address.
	Address string `json:"address"`

	// CreatedAt The ISO 8601 UTC timestamp at which the account was created.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Name An optional name for the account.
	// Account names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.
	// Account names are guaranteed to be unique across all Solana accounts in the developer's CDP Project.
	Name *string `json:"name,omitempty"`

	// Policies The list of policy IDs that apply to the account. This will include both the project-level policy and the account-level policy, if one exists.
	Policies *[]string `json:"policies,omitempty"`

	// UpdatedAt The ISO 8601 UTC timestamp at which the account was last updated.
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
}

// SolanaToken General information about a Solana token. Includes the mint address, and other identifying information.
type SolanaToken struct {
	// MintAddress The mint address of the token.
	// For native SOL, the mint address is `So11111111111111111111111111111111111111111`. For SPL tokens, this is the mint address where the token is defined.
	MintAddress string `json:"mintAddress"`

	// Name The name of this token (ex: "Solana", "USD Coin", "Raydium").
	// The token name is not unique. It is possible for two different tokens to have the same name.
	// For the native SOL token, this name is "Solana". For SPL tokens, this name is defined in the token's metadata.
	// Not all tokens have a name. This field will only be populated when the token has metadata available.
	Name *string `json:"name,omitempty"`

	// Symbol The symbol of this token (ex: SOL, USDC, RAY).
	// The token symbol is not unique. It is possible for two different tokens to have the same symbol.
	// For the native SOL token, this symbol is "SOL". For SPL tokens, this symbol is defined in the token's metadata.
	// Not all tokens have a symbol. This field will only be populated when the token has metadata available.
	Symbol *string `json:"symbol,omitempty"`
}

// SolanaTokenAmount Amount of a given Solana token.
type SolanaTokenAmount struct {
	// Amount The amount is denominated in the smallest indivisible unit of the token. For SOL, the smallest indivisible unit is lamports (10^-9 SOL). For SPL tokens, the smallest unit is defined by the token's decimals configuration.
	Amount string `json:"amount"`

	// Decimals 'decimals' is the exponential value N that satisfies the equation `amount * 10^-N = standard_denomination`. The standard denomination is the most commonly used denomination for the token.
	// - For native SOL, `decimals` is 9 (1 SOL = 10^9 lamports). - For SPL tokens, `decimals` is defined in the token's mint configuration.
	Decimals int64 `json:"decimals"`
}

// SolanaTokenBalance defines model for SolanaTokenBalance.
type SolanaTokenBalance struct {
	// Amount Amount of a given Solana token.
	Amount SolanaTokenAmount `json:"amount"`

	// Token General information about a Solana token. Includes the mint address, and other identifying information.
	Token SolanaToken `json:"token"`
}

// SpendPermission The core spend permission.
type SpendPermission struct {
	// Account Smart account this spend permission is valid for.
	Account string `json:"account"`

	// Allowance Maximum allowed value to spend, in atomic units for the specified token, within each period.
	Allowance string `json:"allowance"`

	// End The expiration time for this spend permission, in Unix seconds.
	End string `json:"end"`

	// ExtraData Arbitrary data to include in the permission.
	ExtraData string `json:"extraData"`

	// Period Time duration for resetting used allowance on a recurring basis (seconds).
	Period string `json:"period"`

	// Salt An arbitrary salt to differentiate unique spend permissions with otherwise identical data.
	Salt string `json:"salt"`

	// Spender Entity that can spend account's tokens.
	Spender string `json:"spender"`

	// Start The start time for this spend permission, in Unix seconds.
	Start string `json:"start"`

	// Token Token address (ERC-7528 native token address or ERC-20 contract).
	Token string `json:"token"`
}

// SpendPermissionResponseObject defines model for SpendPermissionResponseObject.
type SpendPermissionResponseObject struct {
	// CreatedAt The UTC ISO 8601 timestamp when the permission was created.
	CreatedAt time.Time `json:"createdAt"`

	// Permission The core spend permission.
	Permission SpendPermission `json:"permission"`

	// PermissionHash Unique hash identifier for this permission.
	PermissionHash string `json:"permissionHash"`

	// Revoked Whether this permission has been revoked.
	Revoked bool `json:"revoked"`

	// RevokedAt The UTC ISO 8601 timestamp when the permission was revoked (if applicable).
	RevokedAt *time.Time `json:"revokedAt,omitempty"`
}

// SplAddressCriterion The criterion for the recipient addresses of a Solana transaction's SPL token transfer instructions.
type SplAddressCriterion struct {
	// Addresses The Solana addresses that are compared to the list of SPL token transfer recipient addresses in the transaction's `accountKeys` (for legacy transactions) or `staticAccountKeys` (for V0 transactions) array.
	Addresses []string `json:"addresses"`

	// Operator The operator to use for the comparison. Each of the SPL token transfer recipient addresses in the transaction's `accountKeys` (for legacy transactions) or `staticAccountKeys` (for V0 transactions) array will be on the left-hand side of the operator, and the `addresses` field will be on the right-hand side.
	Operator SplAddressCriterionOperator `json:"operator"`

	// Type The type of criterion to use. This should be `splAddress`.
	Type SplAddressCriterionType `json:"type"`
}

// SplAddressCriterionOperator The operator to use for the comparison. Each of the SPL token transfer recipient addresses in the transaction's `accountKeys` (for legacy transactions) or `staticAccountKeys` (for V0 transactions) array will be on the left-hand side of the operator, and the `addresses` field will be on the right-hand side.
type SplAddressCriterionOperator string

// SplAddressCriterionType The type of criterion to use. This should be `splAddress`.
type SplAddressCriterionType string

// SplValueCriterion The criterion for the SPL token value of a SPL token transfer instruction in a Solana transaction.
type SplValueCriterion struct {
	// Operator The operator to use for the comparison. The transaction instruction's `value` field will be on the left-hand side of the operator, and the `splValue` field will be on the right-hand side.
	Operator SplValueCriterionOperator `json:"operator"`

	// SplValue The amount of the SPL token that the transaction instruction's `value` field should be compared to.
	SplValue string `json:"splValue"`

	// Type The type of criterion to use. This should be `splValue`.
	Type SplValueCriterionType `json:"type"`
}

// SplValueCriterionOperator The operator to use for the comparison. The transaction instruction's `value` field will be on the left-hand side of the operator, and the `splValue` field will be on the right-hand side.
type SplValueCriterionOperator string

// SplValueCriterionType The type of criterion to use. This should be `splValue`.
type SplValueCriterionType string

// SwapUnavailableResponse defines model for SwapUnavailableResponse.
type SwapUnavailableResponse struct {
	// LiquidityAvailable Whether sufficient liquidity is available to settle the swap. All other fields in the response will be empty if this is false.
	LiquidityAvailable SwapUnavailableResponseLiquidityAvailable `json:"liquidityAvailable"`
}

// SwapUnavailableResponseLiquidityAvailable Whether sufficient liquidity is available to settle the swap. All other fields in the response will be empty if this is false.
type SwapUnavailableResponseLiquidityAvailable bool

// Token General information about a token. Includes the type, the network, and other identifying information.
type Token struct {
	// ContractAddress The contract address of the token.
	// For Ether, the contract address is `0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE` per [EIP-7528](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-7528.md). For ERC-20 tokens, this is the contract address where the token is deployed.
	ContractAddress string `json:"contractAddress"`

	// Name The name of this token (ex: "Solana", "Ether", "USD Coin").
	// The token name is not unique. It is possible for two different tokens to have the same name.
	// For native gas tokens, this name is defined via convention. As an example, for ETH on Ethereum mainnet, the name is "Ether". For ERC-20 tokens, this name is defined via configuration. `name` will be the string returned by `function name() public view returns (string)` on the underlying token contract.
	// Not all tokens have a name, as this function is [optional in the ERC-20 specification](https://eips.ethereum.org/EIPS/eip-20#name). This field will only be populated when the token's underlying ERC-20 contract has a `name()` function.
	// Further, this endpoint will only populate this value for a small subset of whitelisted ERC-20 tokens at this time. We intend to improve coverage in the future.
	Name *string `json:"name,omitempty"`

	// Network The name of the supported EVM networks in human-readable format.
	Network ListEvmTokenBalancesNetwork `json:"network"`

	// Symbol The symbol of this token (ex: SOL, ETH, USDC).
	// The token symbol is not unique. It is possible for two different tokens to have the same symbol.
	// For native gas tokens, this symbol is defined via convention. As an example, for ETH on Ethereum mainnet, the symbol is "ETH". For ERC-20 tokens, this symbol is defined via configuration. `symbol` will be the string returned by `function symbol() public view returns (string)` on the underlying token contract.
	// Not all tokens have a symbol, as this function is [optional in the ERC-20 specification](https://eips.ethereum.org/EIPS/eip-20#symbol). This field will only be populated when the token's underlying ERC-20 contract has a `symbol()` function.
	// Further, this endpoint will only populate this value for a small subset of whitelisted ERC-20 tokens at this time. We intend to improve coverage in the future.
	Symbol *string `json:"symbol,omitempty"`
}

// TokenAmount Amount of a given token.
type TokenAmount struct {
	// Amount The amount is denominated in the smallest indivisible unit of the token. For ETH, the smallest indivisible unit is Wei (10^-18 ETH). For ERC-20s, the smallest unit is the unit returned from `function totalSupply() public view returns (uint256)`.
	Amount string `json:"amount"`

	// Decimals 'decimals' is the exponential value N that satisfies the equation `amount * 10^-N = standard_denomination`. The standard denomination is the most commonly used denomination for the token.
	// - In the case of the native gas token, `decimals` is defined via convention. As an example, for ETH of Ethereum mainnet, the standard denomination is 10^-18 the smallest denomination (Wei). As such, for ETH on Ethereum mainnet, `decimals` is 18. - In the case of ERC-20 tokens, `decimals` is defined via configuration. `decimals` will be the number returned by `function decimals() public view returns (uint8)` on the underlying token contract.
	// Not all tokens have a `decimals` field, as this function is [optional in the ERC-20 specification](https://eips.ethereum.org/EIPS/eip-20#decimals). This field will be left empty if the underlying token contract doesn't implement `decimals`.
	// Further, this endpoint will only populate this value for a small subset of whitelisted ERC-20 tokens at this time. We intend to improve coverage in the future.
	Decimals int64 `json:"decimals"`
}

// TokenBalance defines model for TokenBalance.
type TokenBalance struct {
	// Amount Amount of a given token.
	Amount TokenAmount `json:"amount"`

	// Token General information about a token. Includes the type, the network, and other identifying information.
	Token Token `json:"token"`
}

// TokenFee defines model for TokenFee.
type TokenFee struct {
	// Amount The estimated amount of the fee in atomic units of the `token`. For example, `1000000000000000` if the fee is in ETH equates to 0.001 ETH, `10000` if the fee is in USDC equates to 0.01 USDC, etc.
	Amount string `json:"amount"`

	// Token The contract address of the token that the fee is paid in. The address `0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE` is used for the native token of the network (e.g. ETH).
	Token string `json:"token"`
}

// Transfer The transfer object.
type Transfer struct {
	// CreatedAt The UTC date and time in ISO 8601 format the transfer was created.
	CreatedAt string `json:"createdAt"`

	// Fees The fees for the transfer.
	Fees []Fee `json:"fees"`

	// Id The ID of the transfer.
	Id string `json:"id"`

	// Source The source of the transfer.
	Source Transfer_Source `json:"source"`

	// SourceAmount The amount the source will transfer.
	SourceAmount string `json:"sourceAmount"`

	// SourceCurrency The currency the source will transfer.
	SourceCurrency string `json:"sourceCurrency"`

	// SourceType The type of the source of the transfer.
	SourceType TransferSourceType `json:"sourceType"`

	// Status The status of the transfer.
	Status TransferStatus `json:"status"`

	// Target The target of the transfer.
	Target Transfer_Target `json:"target"`

	// TargetAmount The amount the target will receive.
	TargetAmount string `json:"targetAmount"`

	// TargetCurrency The currency the target will receive.
	TargetCurrency string `json:"targetCurrency"`

	// TargetType The type of the target of the transfer.
	TargetType TransferTargetType `json:"targetType"`

	// TransactionHash The transaction hash or transaction signature of the transfer.
	TransactionHash *string `json:"transactionHash,omitempty"`

	// UpdatedAt The UTC date and time in ISO 8601 format the transfer was updated.
	UpdatedAt string `json:"updatedAt"`

	// UserAmount The amount the customer put in to transfer.
	UserAmount string `json:"userAmount"`

	// UserCurrency The currency the customer put in to transfer.
	UserCurrency string `json:"userCurrency"`
}

// Transfer_Source The source of the transfer.
type Transfer_Source struct {
	union json.RawMessage
}

// TransferSourceType The type of the source of the transfer.
type TransferSourceType string

// TransferStatus The status of the transfer.
type TransferStatus string

// Transfer_Target The target of the transfer.
type Transfer_Target struct {
	union json.RawMessage
}

// TransferTargetType The type of the target of the transfer.
type TransferTargetType string

// TransferSource The source of the transfer.
type TransferSource struct {
	union json.RawMessage
}

// TransferTarget The target of the transfer.
type TransferTarget struct {
	union json.RawMessage
}

// UserOperationReceipt The receipt that contains information about the execution of user operation.
type UserOperationReceipt struct {
	// BlockHash The block hash of the block including the transaction as 0x-prefixed string.
	BlockHash *string `json:"blockHash,omitempty"`

	// BlockNumber The block height (number) of the block including the transaction.
	BlockNumber *int `json:"blockNumber,omitempty"`

	// GasUsed The gas used for landing this user operation.
	GasUsed *string `json:"gasUsed,omitempty"`

	// Revert The revert data if the user operation has reverted.
	Revert *UserOperationReceiptRevert `json:"revert,omitempty"`

	// TransactionHash The hash of this transaction as 0x-prefixed string.
	TransactionHash *string `json:"transactionHash,omitempty"`
}

// UserOperationReceiptRevert The revert data if the user operation has reverted.
type UserOperationReceiptRevert struct {
	// Data The 0x-prefixed raw hex string.
	Data string `json:"data"`

	// Message Human-readable revert reason if able to decode.
	Message string `json:"message"`
}

// FromAmount The amount of the `fromToken` to send in atomic units of the token. For example, `1000000000000000000` when sending ETH equates to 1 ETH, `1000000` when sending USDC equates to 1 USDC, etc.
type FromAmount = string

// FromToken The 0x-prefixed contract address of the token to send.
type FromToken = string

// GasPrice The target gas price for the swap transaction, in Wei. For EIP-1559 transactions, this value should be seen as the `maxFeePerGas` value. If not provided, the API will use an estimate based on the current network conditions.
type GasPrice = string

// SignerAddress The 0x-prefixed Externally Owned Account (EOA) address that will sign the `Permit2` EIP-712 permit message. This is only needed if `taker` is a smart contract.
type SignerAddress = string

// SlippageBps The maximum acceptable slippage of the `toToken` in basis points. If this parameter is set to 0, no slippage will be tolerated. If not provided, the default slippage tolerance is 100 bps (i.e., 1%).
type SlippageBps = int

// Taker The 0x-prefixed address that holds the `fromToken` balance and has the `Permit2` allowance set for the swap.
type Taker = string

// ToToken The 0x-prefixed contract address of the token to receive.
type ToToken = string

// IdempotencyKey defines model for IdempotencyKey.
type IdempotencyKey = string

// XWalletAuth defines model for XWalletAuth.
type XWalletAuth = string

// AlreadyExistsError An error response including the code for the type of error and a human-readable message describing the error.
type AlreadyExistsError = Error

// BadGatewayError An error response including the code for the type of error and a human-readable message describing the error.
type BadGatewayError = Error

// IdempotencyError An error response including the code for the type of error and a human-readable message describing the error.
type IdempotencyError = Error

// InternalServerError An error response including the code for the type of error and a human-readable message describing the error.
type InternalServerError = Error

// InvalidSQLQueryError An error response including the code for the type of error and a human-readable message describing the error.
type InvalidSQLQueryError = Error

// PaymentMethodRequiredError An error response including the code for the type of error and a human-readable message describing the error.
type PaymentMethodRequiredError = Error

// RateLimitExceeded An error response including the code for the type of error and a human-readable message describing the error.
type RateLimitExceeded = Error

// ServiceUnavailableError An error response including the code for the type of error and a human-readable message describing the error.
type ServiceUnavailableError = Error

// TimedOutError An error response including the code for the type of error and a human-readable message describing the error.
type TimedOutError = Error

// UnauthorizedError An error response including the code for the type of error and a human-readable message describing the error.
type UnauthorizedError = Error

// ListEvmAccountsParams defines parameters for ListEvmAccounts.
type ListEvmAccountsParams struct {
	// PageSize The number of accounts to return per page.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// PageToken The token for the next page of accounts, if any.
	PageToken *string `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// CreateEvmAccountJSONBody defines parameters for CreateEvmAccount.
type CreateEvmAccountJSONBody struct {
	// AccountPolicy The ID of the account-level policy to apply to the account.
	AccountPolicy *string `json:"accountPolicy,omitempty"`

	// Name An optional name for the account.
	// Account names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.
	// Account names must be unique across all EVM accounts in the developer's CDP Project.
	Name *string `json:"name,omitempty"`
}

// CreateEvmAccountParams defines parameters for CreateEvmAccount.
type CreateEvmAccountParams struct {
	// XWalletAuth A JWT signed using your Wallet Secret, encoded in base64. Refer to the
	// [Generate Wallet Token](https://docs.cdp.coinbase.com/api-reference/v2/authentication#2-generate-wallet-token)
	// section of our Authentication docs for more details on how to generate your Wallet Token.
	XWalletAuth *XWalletAuth `json:"X-Wallet-Auth,omitempty"`

	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// ExportEvmAccountByNameJSONBody defines parameters for ExportEvmAccountByName.
type ExportEvmAccountByNameJSONBody struct {
	// ExportEncryptionKey The base64-encoded, public part of the RSA key in DER format used to encrypt the account private key.
	ExportEncryptionKey string `json:"exportEncryptionKey"`
}

// ExportEvmAccountByNameParams defines parameters for ExportEvmAccountByName.
type ExportEvmAccountByNameParams struct {
	// XWalletAuth A JWT signed using your Wallet Secret, encoded in base64. Refer to the
	// [Generate Wallet Token](https://docs.cdp.coinbase.com/api-reference/v2/authentication#2-generate-wallet-token)
	// section of our Authentication docs for more details on how to generate your Wallet Token.
	XWalletAuth *XWalletAuth `json:"X-Wallet-Auth,omitempty"`

	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// ImportEvmAccountJSONBody defines parameters for ImportEvmAccount.
type ImportEvmAccountJSONBody struct {
	// AccountPolicy The ID of the account-level policy to apply to the account.
	AccountPolicy *string `json:"accountPolicy,omitempty"`

	// EncryptedPrivateKey The base64-encoded, encrypted private key of the EVM account. The private key must be encrypted using the CDP SDK's encryption scheme.
	EncryptedPrivateKey string `json:"encryptedPrivateKey"`

	// Name An optional name for the account.
	// Account names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.
	// Account names must be unique across all EVM accounts in the developer's CDP Project.
	Name *string `json:"name,omitempty"`
}

// ImportEvmAccountParams defines parameters for ImportEvmAccount.
type ImportEvmAccountParams struct {
	// XWalletAuth A JWT signed using your Wallet Secret, encoded in base64. Refer to the
	// [Generate Wallet Token](https://docs.cdp.coinbase.com/api-reference/v2/authentication#2-generate-wallet-token)
	// section of our Authentication docs for more details on how to generate your Wallet Token.
	XWalletAuth *XWalletAuth `json:"X-Wallet-Auth,omitempty"`

	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// UpdateEvmAccountJSONBody defines parameters for UpdateEvmAccount.
type UpdateEvmAccountJSONBody struct {
	// AccountPolicy The ID of the account-level policy to apply to the account, or an empty string to unset attached policy.
	AccountPolicy *string `json:"accountPolicy,omitempty"`

	// Name An optional name for the account.
	// Account names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.
	// Account names must be unique across all EVM accounts in the developer's CDP Project.
	Name *string `json:"name,omitempty"`
}

// UpdateEvmAccountParams defines parameters for UpdateEvmAccount.
type UpdateEvmAccountParams struct {
	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// ExportEvmAccountJSONBody defines parameters for ExportEvmAccount.
type ExportEvmAccountJSONBody struct {
	// ExportEncryptionKey The base64-encoded, public part of the RSA key in DER format used to encrypt the account private key.
	ExportEncryptionKey string `json:"exportEncryptionKey"`
}

// ExportEvmAccountParams defines parameters for ExportEvmAccount.
type ExportEvmAccountParams struct {
	// XWalletAuth A JWT signed using your Wallet Secret, encoded in base64. Refer to the
	// [Generate Wallet Token](https://docs.cdp.coinbase.com/api-reference/v2/authentication#2-generate-wallet-token)
	// section of our Authentication docs for more details on how to generate your Wallet Token.
	XWalletAuth *XWalletAuth `json:"X-Wallet-Auth,omitempty"`

	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// SendEvmTransactionJSONBody defines parameters for SendEvmTransaction.
type SendEvmTransactionJSONBody struct {
	// Network The network to send the transaction to.
	Network SendEvmTransactionJSONBodyNetwork `json:"network"`

	// Transaction The RLP-encoded transaction to sign and send, as a 0x-prefixed hex string.
	Transaction string `json:"transaction"`
}

// SendEvmTransactionParams defines parameters for SendEvmTransaction.
type SendEvmTransactionParams struct {
	// XWalletAuth A JWT signed using your Wallet Secret, encoded in base64. Refer to the
	// [Generate Wallet Token](https://docs.cdp.coinbase.com/api-reference/v2/authentication#2-generate-wallet-token)
	// section of our Authentication docs for more details on how to generate your Wallet Token.
	XWalletAuth *XWalletAuth `json:"X-Wallet-Auth,omitempty"`

	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// SendEvmTransactionJSONBodyNetwork defines parameters for SendEvmTransaction.
type SendEvmTransactionJSONBodyNetwork string

// SignEvmHashJSONBody defines parameters for SignEvmHash.
type SignEvmHashJSONBody struct {
	// Hash The arbitrary 32 byte hash to sign.
	Hash string `json:"hash"`
}

// SignEvmHashParams defines parameters for SignEvmHash.
type SignEvmHashParams struct {
	// XWalletAuth A JWT signed using your Wallet Secret, encoded in base64. Refer to the
	// [Generate Wallet Token](https://docs.cdp.coinbase.com/api-reference/v2/authentication#2-generate-wallet-token)
	// section of our Authentication docs for more details on how to generate your Wallet Token.
	XWalletAuth *XWalletAuth `json:"X-Wallet-Auth,omitempty"`

	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// SignEvmMessageJSONBody defines parameters for SignEvmMessage.
type SignEvmMessageJSONBody struct {
	// Message The message to sign.
	Message string `json:"message"`
}

// SignEvmMessageParams defines parameters for SignEvmMessage.
type SignEvmMessageParams struct {
	// XWalletAuth A JWT signed using your Wallet Secret, encoded in base64. Refer to the
	// [Generate Wallet Token](https://docs.cdp.coinbase.com/api-reference/v2/authentication#2-generate-wallet-token)
	// section of our Authentication docs for more details on how to generate your Wallet Token.
	XWalletAuth *XWalletAuth `json:"X-Wallet-Auth,omitempty"`

	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// SignEvmTransactionJSONBody defines parameters for SignEvmTransaction.
type SignEvmTransactionJSONBody struct {
	// Transaction The RLP-encoded transaction to sign, as a 0x-prefixed hex string.
	Transaction string `json:"transaction"`
}

// SignEvmTransactionParams defines parameters for SignEvmTransaction.
type SignEvmTransactionParams struct {
	// XWalletAuth A JWT signed using your Wallet Secret, encoded in base64. Refer to the
	// [Generate Wallet Token](https://docs.cdp.coinbase.com/api-reference/v2/authentication#2-generate-wallet-token)
	// section of our Authentication docs for more details on how to generate your Wallet Token.
	XWalletAuth *XWalletAuth `json:"X-Wallet-Auth,omitempty"`

	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// SignEvmTypedDataParams defines parameters for SignEvmTypedData.
type SignEvmTypedDataParams struct {
	// XWalletAuth A JWT signed using your Wallet Secret, encoded in base64. Refer to the
	// [Generate Wallet Token](https://docs.cdp.coinbase.com/api-reference/v2/authentication#2-generate-wallet-token)
	// section of our Authentication docs for more details on how to generate your Wallet Token.
	XWalletAuth *XWalletAuth `json:"X-Wallet-Auth,omitempty"`

	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// RequestEvmFaucetJSONBody defines parameters for RequestEvmFaucet.
type RequestEvmFaucetJSONBody struct {
	// Address The address to request funds to, which is a 0x-prefixed hexadecimal string.
	Address string `json:"address"`

	// Network The network to request funds from.
	Network RequestEvmFaucetJSONBodyNetwork `json:"network"`

	// Token The token to request funds for.
	Token RequestEvmFaucetJSONBodyToken `json:"token"`
}

// RequestEvmFaucetJSONBodyNetwork defines parameters for RequestEvmFaucet.
type RequestEvmFaucetJSONBodyNetwork string

// RequestEvmFaucetJSONBodyToken defines parameters for RequestEvmFaucet.
type RequestEvmFaucetJSONBodyToken string

// ListEvmSmartAccountsParams defines parameters for ListEvmSmartAccounts.
type ListEvmSmartAccountsParams struct {
	// PageSize The number of accounts to return per page.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// PageToken The token for the next page of accounts, if any.
	PageToken *string `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// CreateEvmSmartAccountJSONBody defines parameters for CreateEvmSmartAccount.
type CreateEvmSmartAccountJSONBody struct {
	// Name An optional name for the account.
	// Account names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.
	// Account names must be unique across all EVM accounts in the developer's CDP Project.
	Name *string `json:"name,omitempty"`

	// Owners Today, only a single owner can be set for a Smart Account, but this is an array to allow setting multiple owners in the future.
	Owners []string `json:"owners"`
}

// CreateEvmSmartAccountParams defines parameters for CreateEvmSmartAccount.
type CreateEvmSmartAccountParams struct {
	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// UpdateEvmSmartAccountJSONBody defines parameters for UpdateEvmSmartAccount.
type UpdateEvmSmartAccountJSONBody struct {
	// Name An optional name for the smart account.
	// Account names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.
	// Account names must be unique across all EVM smart accounts in the developer's CDP Project.
	Name *string `json:"name,omitempty"`
}

// CreateSpendPermissionParams defines parameters for CreateSpendPermission.
type CreateSpendPermissionParams struct {
	// XWalletAuth A JWT signed using your Wallet Secret, encoded in base64. Refer to the
	// [Generate Wallet Token](https://docs.cdp.coinbase.com/api-reference/v2/authentication#2-generate-wallet-token)
	// section of our Authentication docs for more details on how to generate your Wallet Token.
	XWalletAuth *XWalletAuth `json:"X-Wallet-Auth,omitempty"`

	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// ListSpendPermissionsParams defines parameters for ListSpendPermissions.
type ListSpendPermissionsParams struct {
	// PageSize The number of spend permissions to return per page.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// PageToken The token for the next page of spend permissions. Will be empty if there are no more spend permissions to fetch.
	PageToken *string `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// RevokeSpendPermissionParams defines parameters for RevokeSpendPermission.
type RevokeSpendPermissionParams struct {
	// XWalletAuth A JWT signed using your Wallet Secret, encoded in base64. Refer to the
	// [Generate Wallet Token](https://docs.cdp.coinbase.com/api-reference/v2/authentication#2-generate-wallet-token)
	// section of our Authentication docs for more details on how to generate your Wallet Token.
	XWalletAuth *XWalletAuth `json:"X-Wallet-Auth,omitempty"`

	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// PrepareUserOperationJSONBody defines parameters for PrepareUserOperation.
type PrepareUserOperationJSONBody struct {
	// Calls The list of calls to make from the Smart Account.
	Calls []EvmCall `json:"calls"`

	// Network The network the user operation is for.
	Network EvmUserOperationNetwork `json:"network"`

	// PaymasterUrl The URL of the paymaster to use for the user operation.
	PaymasterUrl *string `json:"paymasterUrl,omitempty"`
}

// SendUserOperationJSONBody defines parameters for SendUserOperation.
type SendUserOperationJSONBody struct {
	// Signature The hex-encoded signature of the user operation. This should be a 65-byte signature consisting of the `r`, `s`, and `v` values of the ECDSA signature. Note that the `v` value should conform to the `personal_sign` standard, which means it should be 27 or 28.
	Signature string `json:"signature"`
}

// CreateEvmSwapQuoteJSONBody defines parameters for CreateEvmSwapQuote.
type CreateEvmSwapQuoteJSONBody struct {
	// FromAmount The amount of the `fromToken` to send in atomic units of the token. For example, `1000000000000000000` when sending ETH equates to 1 ETH, `1000000` when sending USDC equates to 1 USDC, etc.
	FromAmount string `json:"fromAmount"`

	// FromToken The 0x-prefixed contract address of the token to send.
	FromToken string `json:"fromToken"`

	// GasPrice The target gas price for the swap transaction, in Wei. For EIP-1559 transactions, this value should be seen as the `maxFeePerGas` value. If not provided, the API will use an estimate based on the current network conditions.
	GasPrice *string `json:"gasPrice,omitempty"`

	// Network The network on which to perform the swap.
	Network EvmSwapsNetwork `json:"network"`

	// SignerAddress The 0x-prefixed Externally Owned Account (EOA) address that will sign the `Permit2` EIP-712 permit message. This is only needed if `taker` is a smart contract.
	SignerAddress *string `json:"signerAddress,omitempty"`

	// SlippageBps The maximum acceptable slippage of the `toToken` in basis points. If this parameter is set to 0, no slippage will be tolerated. If not provided, the default slippage tolerance is 100 bps (i.e., 1%).
	SlippageBps *int `json:"slippageBps,omitempty"`

	// Taker The 0x-prefixed address that holds the `fromToken` balance and has the `Permit2` allowance set for the swap.
	Taker string `json:"taker"`

	// ToToken The 0x-prefixed contract address of the token to receive.
	ToToken string `json:"toToken"`
}

// CreateEvmSwapQuoteParams defines parameters for CreateEvmSwapQuote.
type CreateEvmSwapQuoteParams struct {
	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// GetEvmSwapPriceParams defines parameters for GetEvmSwapPrice.
type GetEvmSwapPriceParams struct {
	Network       EvmSwapsNetwork `form:"network" json:"network"`
	ToToken       ToToken         `form:"toToken" json:"toToken"`
	FromToken     FromToken       `form:"fromToken" json:"fromToken"`
	FromAmount    FromAmount      `form:"fromAmount" json:"fromAmount"`
	Taker         Taker           `form:"taker" json:"taker"`
	SignerAddress *SignerAddress  `form:"signerAddress,omitempty" json:"signerAddress,omitempty"`
	GasPrice      *GasPrice       `form:"gasPrice,omitempty" json:"gasPrice,omitempty"`
	SlippageBps   *SlippageBps    `form:"slippageBps,omitempty" json:"slippageBps,omitempty"`
}

// ListEvmTokenBalancesParams defines parameters for ListEvmTokenBalances.
type ListEvmTokenBalancesParams struct {
	// PageSize The number of balances to return per page.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// PageToken The token for the next page of balances. Will be empty if there are no more balances to fetch.
	PageToken *string `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// CreateOnrampOrderJSONBody defines parameters for CreateOnrampOrder.
type CreateOnrampOrderJSONBody struct {
	// AgreementAcceptedAt The timestamp of when the user acknowledged that by using Coinbase Onramp they are accepting the Coinbase Terms  (https://www.coinbase.com/legal/guest-checkout/us), User Agreement (https://www.coinbase.com/legal/user_agreement),  and Privacy Policy (https://www.coinbase.com/legal/privacy).
	AgreementAcceptedAt time.Time `json:"agreementAcceptedAt"`

	// DestinationAddress The address the purchased crypto will be sent to.
	DestinationAddress string `json:"destinationAddress"`

	// DestinationNetwork The name of the crypto network the purchased currency will be sent on.
	//
	// Use the [Onramp Buy Options API](https://docs.cdp.coinbase.com/api-reference/rest-api/onramp-offramp/get-buy-options) to discover the supported networks for your user's location.
	DestinationNetwork string `json:"destinationNetwork"`

	// Email The verified email address of the user requesting the onramp transaction. This email must be verified by your app (via OTP) before being used with the Onramp API.
	Email string `json:"email"`

	// IsQuote If true, this API will return a quote without creating any transaction.
	IsQuote *bool `json:"isQuote,omitempty"`

	// PartnerOrderRef Optional partner order reference ID.
	PartnerOrderRef *string `json:"partnerOrderRef,omitempty"`

	// PartnerUserRef A unique string that represents the user in your app. This can be used to link individual transactions  together so you can retrieve the transaction history for your users. Prefix this string with sandbox-  (e.g. "sandbox-user-1234") to perform a sandbox transaction which will allow you to test your integration  without any real transfer of funds.
	//
	// This value can be used with with [Onramp User Transactions API](https://docs.cdp.coinbase.com/api-reference/rest-api/onramp-offramp/get-onramp-transactions-by-id) to retrieve all transactions created by the user.
	PartnerUserRef string `json:"partnerUserRef"`

	// PaymentAmount A string representing the amount of fiat the user wishes to pay in exchange for crypto. When using  this parameter, the returned quote will be inclusive of fees i.e. the user will pay this exact amount  of the payment currency.
	PaymentAmount *string `json:"paymentAmount,omitempty"`

	// PaymentCurrency The fiat currency to be converted to crypto.
	PaymentCurrency string `json:"paymentCurrency"`

	// PaymentMethod The type of payment method to be used to complete the order.
	PaymentMethod OnrampPaymentMethodTypeId `json:"paymentMethod"`

	// PhoneNumber The phone number of the user requesting the onramp transaction in E.164 format. This phone number must  be verified by your app (via OTP) before being used with the Onramp API.
	//
	// Please refer to the [Onramp docs](https://docs.cdp.coinbase.com/onramp-&-offramp/onramp-apis/apple-pay-onramp-api) for more details on phone number verification requirements and best practices.
	PhoneNumber string `json:"phoneNumber"`

	// PhoneNumberVerifiedAt Timestamp of when the user's phone number was verified via OTP. User phone number must be verified  every 60 days. If this timestamp is older than 60 days, an error will be returned.
	PhoneNumberVerifiedAt time.Time `json:"phoneNumberVerifiedAt"`

	// PurchaseAmount A string representing the amount of crypto the user wishes to purchase. When using this parameter the  returned quote will be exclusive of fees i.e. the user will receive this exact amount of the purchase  currency.
	PurchaseAmount *string `json:"purchaseAmount,omitempty"`

	// PurchaseCurrency The ticker (e.g. `BTC`, `USDC`, `SOL`) or the Coinbase UUID (e.g. `d85dce9b-5b73-5c3c-8978-522ce1d1c1b4`)  of the crypto asset to be purchased.
	//
	// Use the [Onramp Buy Options API](https://docs.cdp.coinbase.com/api-reference/rest-api/onramp-offramp/get-buy-options) to discover the supported purchase currencies for your user's location.
	PurchaseCurrency string `json:"purchaseCurrency"`
}

// GetCryptoRailsParams defines parameters for GetCryptoRails.
type GetCryptoRailsParams struct {
	// Networks Comma separated list of networks to filter the rails by.
	Networks *string `form:"networks,omitempty" json:"networks,omitempty"`
}

// CreatePaymentTransferQuoteJSONBody defines parameters for CreatePaymentTransferQuote.
type CreatePaymentTransferQuoteJSONBody struct {
	// Amount The amount of the transfer, which is either for the source currency to buy, or the target currency to receive.
	Amount string `json:"amount"`

	// Currency The currency of the transfer. This can be specified as the source currency, which would be used to buy, or else the target currency, which is how much will be received.
	Currency string `json:"currency"`

	// Execute Whether to execute the transfer. If true, the transfer will be committed and executed. If false, the quote will be generated and returned.
	Execute *bool `json:"execute,omitempty"`

	// Source The source of the transfer.
	Source TransferSource `json:"source"`

	// SourceType The type of the source of the transfer.
	SourceType CreatePaymentTransferQuoteJSONBodySourceType `json:"sourceType"`

	// Target The target of the transfer.
	Target TransferTarget `json:"target"`

	// TargetType The type of the target of the transfer.
	TargetType CreatePaymentTransferQuoteJSONBodyTargetType `json:"targetType"`
}

// CreatePaymentTransferQuoteJSONBodySourceType defines parameters for CreatePaymentTransferQuote.
type CreatePaymentTransferQuoteJSONBodySourceType string

// CreatePaymentTransferQuoteJSONBodyTargetType defines parameters for CreatePaymentTransferQuote.
type CreatePaymentTransferQuoteJSONBodyTargetType string

// ListPoliciesParams defines parameters for ListPolicies.
type ListPoliciesParams struct {
	// PageSize The number of policies to return per page.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// PageToken The token for the next page of policies, if any.
	PageToken *string `form:"pageToken,omitempty" json:"pageToken,omitempty"`

	// Scope The scope of the policies to return. If `project`, the response will include exactly one policy, which is the project-level policy. If `account`, the response will include all account-level policies for the developer's CDP Project.
	Scope *ListPoliciesParamsScope `form:"scope,omitempty" json:"scope,omitempty"`
}

// ListPoliciesParamsScope defines parameters for ListPolicies.
type ListPoliciesParamsScope string

// CreatePolicyJSONBody defines parameters for CreatePolicy.
type CreatePolicyJSONBody struct {
	// Description An optional human-readable description for the policy.
	// Policy descriptions can consist of alphanumeric characters, spaces, commas, and periods, and be 50 characters or less.
	Description *string `json:"description,omitempty"`

	// Rules A list of rules that comprise the policy. There is a limit of 10 rules per policy.
	Rules []Rule `json:"rules"`

	// Scope The scope of the policy.
	Scope CreatePolicyJSONBodyScope `json:"scope"`
}

// CreatePolicyParams defines parameters for CreatePolicy.
type CreatePolicyParams struct {
	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// CreatePolicyJSONBodyScope defines parameters for CreatePolicy.
type CreatePolicyJSONBodyScope string

// DeletePolicyParams defines parameters for DeletePolicy.
type DeletePolicyParams struct {
	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// UpdatePolicyJSONBody defines parameters for UpdatePolicy.
type UpdatePolicyJSONBody struct {
	// Description An optional human-readable description for the policy.
	// Policy descriptions can consist of alphanumeric characters, spaces, commas, and periods, and be 50 characters or less.
	Description *string `json:"description,omitempty"`

	// Rules A list of rules that comprise the policy. There is a limit of 10 rules per policy.
	Rules []Rule `json:"rules"`
}

// UpdatePolicyParams defines parameters for UpdatePolicy.
type UpdatePolicyParams struct {
	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// ListSolanaAccountsParams defines parameters for ListSolanaAccounts.
type ListSolanaAccountsParams struct {
	// PageSize The number of accounts to return per page.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// PageToken The token for the next page of accounts, if any.
	PageToken *string `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// CreateSolanaAccountJSONBody defines parameters for CreateSolanaAccount.
type CreateSolanaAccountJSONBody struct {
	// AccountPolicy The ID of the account-level policy to apply to the account.
	AccountPolicy *string `json:"accountPolicy,omitempty"`

	// Name An optional name for the account.
	// Account names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.
	// Account names must be unique across all Solana accounts in the developer's CDP Project.
	Name *string `json:"name,omitempty"`
}

// CreateSolanaAccountParams defines parameters for CreateSolanaAccount.
type CreateSolanaAccountParams struct {
	// XWalletAuth A JWT signed using your Wallet Secret, encoded in base64. Refer to the
	// [Generate Wallet Token](https://docs.cdp.coinbase.com/api-reference/v2/authentication#2-generate-wallet-token)
	// section of our Authentication docs for more details on how to generate your Wallet Token.
	XWalletAuth *XWalletAuth `json:"X-Wallet-Auth,omitempty"`

	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// ExportSolanaAccountByNameJSONBody defines parameters for ExportSolanaAccountByName.
type ExportSolanaAccountByNameJSONBody struct {
	// ExportEncryptionKey The base64-encoded, public part of the RSA key in DER format used to encrypt the account private key.
	ExportEncryptionKey string `json:"exportEncryptionKey"`
}

// ExportSolanaAccountByNameParams defines parameters for ExportSolanaAccountByName.
type ExportSolanaAccountByNameParams struct {
	// XWalletAuth A JWT signed using your Wallet Secret, encoded in base64. Refer to the
	// [Generate Wallet Token](https://docs.cdp.coinbase.com/api-reference/v2/authentication#2-generate-wallet-token)
	// section of our Authentication docs for more details on how to generate your Wallet Token.
	XWalletAuth *XWalletAuth `json:"X-Wallet-Auth,omitempty"`

	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// ImportSolanaAccountJSONBody defines parameters for ImportSolanaAccount.
type ImportSolanaAccountJSONBody struct {
	// EncryptedPrivateKey The base64-encoded, encrypted 32-byte private key of the Solana account. The private key must be encrypted using the CDP SDK's encryption scheme.
	EncryptedPrivateKey string `json:"encryptedPrivateKey"`

	// Name An optional name for the account.
	// Account names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.
	// Account names must be unique across all EVM accounts in the developer's CDP Project.
	Name *string `json:"name,omitempty"`
}

// ImportSolanaAccountParams defines parameters for ImportSolanaAccount.
type ImportSolanaAccountParams struct {
	// XWalletAuth A JWT signed using your Wallet Secret, encoded in base64. Refer to the
	// [Generate Wallet Token](https://docs.cdp.coinbase.com/api-reference/v2/authentication#2-generate-wallet-token)
	// section of our Authentication docs for more details on how to generate your Wallet Token.
	XWalletAuth *XWalletAuth `json:"X-Wallet-Auth,omitempty"`

	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// SendSolanaTransactionJSONBody defines parameters for SendSolanaTransaction.
type SendSolanaTransactionJSONBody struct {
	// Network The Solana network to send the transaction to.
	Network SendSolanaTransactionJSONBodyNetwork `json:"network"`

	// Transaction The base64 encoded transaction to sign and send. This transaction can contain multiple instructions for native Solana batching.
	Transaction string `json:"transaction"`
}

// SendSolanaTransactionParams defines parameters for SendSolanaTransaction.
type SendSolanaTransactionParams struct {
	// XWalletAuth A JWT signed using your Wallet Secret, encoded in base64. Refer to the
	// [Generate Wallet Token](https://docs.cdp.coinbase.com/api-reference/v2/authentication#2-generate-wallet-token)
	// section of our Authentication docs for more details on how to generate your Wallet Token.
	XWalletAuth *XWalletAuth `json:"X-Wallet-Auth,omitempty"`

	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// SendSolanaTransactionJSONBodyNetwork defines parameters for SendSolanaTransaction.
type SendSolanaTransactionJSONBodyNetwork string

// UpdateSolanaAccountJSONBody defines parameters for UpdateSolanaAccount.
type UpdateSolanaAccountJSONBody struct {
	// AccountPolicy The ID of the account-level policy to apply to the account, or an empty string to unset attached policy.
	AccountPolicy *string `json:"accountPolicy,omitempty"`

	// Name An optional name for the account. Account names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.
	// Account names must be unique across all Solana accounts in the developer's CDP Project.
	Name *string `json:"name,omitempty"`
}

// UpdateSolanaAccountParams defines parameters for UpdateSolanaAccount.
type UpdateSolanaAccountParams struct {
	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// ExportSolanaAccountJSONBody defines parameters for ExportSolanaAccount.
type ExportSolanaAccountJSONBody struct {
	// ExportEncryptionKey The base64-encoded, public part of the RSA key in DER format used to encrypt the account private key.
	ExportEncryptionKey string `json:"exportEncryptionKey"`
}

// ExportSolanaAccountParams defines parameters for ExportSolanaAccount.
type ExportSolanaAccountParams struct {
	// XWalletAuth A JWT signed using your Wallet Secret, encoded in base64. Refer to the
	// [Generate Wallet Token](https://docs.cdp.coinbase.com/api-reference/v2/authentication#2-generate-wallet-token)
	// section of our Authentication docs for more details on how to generate your Wallet Token.
	XWalletAuth *XWalletAuth `json:"X-Wallet-Auth,omitempty"`

	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// SignSolanaMessageJSONBody defines parameters for SignSolanaMessage.
type SignSolanaMessageJSONBody struct {
	// Message The arbitrary message to sign.
	Message string `json:"message"`
}

// SignSolanaMessageParams defines parameters for SignSolanaMessage.
type SignSolanaMessageParams struct {
	// XWalletAuth A JWT signed using your Wallet Secret, encoded in base64. Refer to the
	// [Generate Wallet Token](https://docs.cdp.coinbase.com/api-reference/v2/authentication#2-generate-wallet-token)
	// section of our Authentication docs for more details on how to generate your Wallet Token.
	XWalletAuth *XWalletAuth `json:"X-Wallet-Auth,omitempty"`

	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// SignSolanaTransactionJSONBody defines parameters for SignSolanaTransaction.
type SignSolanaTransactionJSONBody struct {
	// Transaction The base64 encoded transaction to sign.
	Transaction string `json:"transaction"`
}

// SignSolanaTransactionParams defines parameters for SignSolanaTransaction.
type SignSolanaTransactionParams struct {
	// XWalletAuth A JWT signed using your Wallet Secret, encoded in base64. Refer to the
	// [Generate Wallet Token](https://docs.cdp.coinbase.com/api-reference/v2/authentication#2-generate-wallet-token)
	// section of our Authentication docs for more details on how to generate your Wallet Token.
	XWalletAuth *XWalletAuth `json:"X-Wallet-Auth,omitempty"`

	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// RequestSolanaFaucetJSONBody defines parameters for RequestSolanaFaucet.
type RequestSolanaFaucetJSONBody struct {
	// Address The address to request funds to, which is a base58-encoded string.
	Address string `json:"address"`

	// Token The token to request funds for.
	Token RequestSolanaFaucetJSONBodyToken `json:"token"`
}

// RequestSolanaFaucetJSONBodyToken defines parameters for RequestSolanaFaucet.
type RequestSolanaFaucetJSONBodyToken string

// ListSolanaTokenBalancesParams defines parameters for ListSolanaTokenBalances.
type ListSolanaTokenBalancesParams struct {
	// PageSize The number of balances to return per page.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// PageToken The token for the next page of balances. Will be empty if there are no more balances to fetch.
	PageToken *string `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// RunSQLQueryJSONRequestBody defines body for RunSQLQuery for application/json ContentType.
type RunSQLQueryJSONRequestBody = OnchainDataQuery

// CreateEvmAccountJSONRequestBody defines body for CreateEvmAccount for application/json ContentType.
type CreateEvmAccountJSONRequestBody CreateEvmAccountJSONBody

// ExportEvmAccountByNameJSONRequestBody defines body for ExportEvmAccountByName for application/json ContentType.
type ExportEvmAccountByNameJSONRequestBody ExportEvmAccountByNameJSONBody

// ImportEvmAccountJSONRequestBody defines body for ImportEvmAccount for application/json ContentType.
type ImportEvmAccountJSONRequestBody ImportEvmAccountJSONBody

// UpdateEvmAccountJSONRequestBody defines body for UpdateEvmAccount for application/json ContentType.
type UpdateEvmAccountJSONRequestBody UpdateEvmAccountJSONBody

// ExportEvmAccountJSONRequestBody defines body for ExportEvmAccount for application/json ContentType.
type ExportEvmAccountJSONRequestBody ExportEvmAccountJSONBody

// SendEvmTransactionJSONRequestBody defines body for SendEvmTransaction for application/json ContentType.
type SendEvmTransactionJSONRequestBody SendEvmTransactionJSONBody

// SignEvmHashJSONRequestBody defines body for SignEvmHash for application/json ContentType.
type SignEvmHashJSONRequestBody SignEvmHashJSONBody

// SignEvmMessageJSONRequestBody defines body for SignEvmMessage for application/json ContentType.
type SignEvmMessageJSONRequestBody SignEvmMessageJSONBody

// SignEvmTransactionJSONRequestBody defines body for SignEvmTransaction for application/json ContentType.
type SignEvmTransactionJSONRequestBody SignEvmTransactionJSONBody

// SignEvmTypedDataJSONRequestBody defines body for SignEvmTypedData for application/json ContentType.
type SignEvmTypedDataJSONRequestBody = EIP712Message

// RequestEvmFaucetJSONRequestBody defines body for RequestEvmFaucet for application/json ContentType.
type RequestEvmFaucetJSONRequestBody RequestEvmFaucetJSONBody

// CreateEvmSmartAccountJSONRequestBody defines body for CreateEvmSmartAccount for application/json ContentType.
type CreateEvmSmartAccountJSONRequestBody CreateEvmSmartAccountJSONBody

// UpdateEvmSmartAccountJSONRequestBody defines body for UpdateEvmSmartAccount for application/json ContentType.
type UpdateEvmSmartAccountJSONRequestBody UpdateEvmSmartAccountJSONBody

// CreateSpendPermissionJSONRequestBody defines body for CreateSpendPermission for application/json ContentType.
type CreateSpendPermissionJSONRequestBody = CreateSpendPermissionRequest

// RevokeSpendPermissionJSONRequestBody defines body for RevokeSpendPermission for application/json ContentType.
type RevokeSpendPermissionJSONRequestBody = RevokeSpendPermissionRequest

// PrepareUserOperationJSONRequestBody defines body for PrepareUserOperation for application/json ContentType.
type PrepareUserOperationJSONRequestBody PrepareUserOperationJSONBody

// SendUserOperationJSONRequestBody defines body for SendUserOperation for application/json ContentType.
type SendUserOperationJSONRequestBody SendUserOperationJSONBody

// CreateEvmSwapQuoteJSONRequestBody defines body for CreateEvmSwapQuote for application/json ContentType.
type CreateEvmSwapQuoteJSONRequestBody CreateEvmSwapQuoteJSONBody

// CreateOnrampOrderJSONRequestBody defines body for CreateOnrampOrder for application/json ContentType.
type CreateOnrampOrderJSONRequestBody CreateOnrampOrderJSONBody

// CreatePaymentTransferQuoteJSONRequestBody defines body for CreatePaymentTransferQuote for application/json ContentType.
type CreatePaymentTransferQuoteJSONRequestBody CreatePaymentTransferQuoteJSONBody

// CreatePolicyJSONRequestBody defines body for CreatePolicy for application/json ContentType.
type CreatePolicyJSONRequestBody CreatePolicyJSONBody

// UpdatePolicyJSONRequestBody defines body for UpdatePolicy for application/json ContentType.
type UpdatePolicyJSONRequestBody UpdatePolicyJSONBody

// CreateSolanaAccountJSONRequestBody defines body for CreateSolanaAccount for application/json ContentType.
type CreateSolanaAccountJSONRequestBody CreateSolanaAccountJSONBody

// ExportSolanaAccountByNameJSONRequestBody defines body for ExportSolanaAccountByName for application/json ContentType.
type ExportSolanaAccountByNameJSONRequestBody ExportSolanaAccountByNameJSONBody

// ImportSolanaAccountJSONRequestBody defines body for ImportSolanaAccount for application/json ContentType.
type ImportSolanaAccountJSONRequestBody ImportSolanaAccountJSONBody

// SendSolanaTransactionJSONRequestBody defines body for SendSolanaTransaction for application/json ContentType.
type SendSolanaTransactionJSONRequestBody SendSolanaTransactionJSONBody

// UpdateSolanaAccountJSONRequestBody defines body for UpdateSolanaAccount for application/json ContentType.
type UpdateSolanaAccountJSONRequestBody UpdateSolanaAccountJSONBody

// ExportSolanaAccountJSONRequestBody defines body for ExportSolanaAccount for application/json ContentType.
type ExportSolanaAccountJSONRequestBody ExportSolanaAccountJSONBody

// SignSolanaMessageJSONRequestBody defines body for SignSolanaMessage for application/json ContentType.
type SignSolanaMessageJSONRequestBody SignSolanaMessageJSONBody

// SignSolanaTransactionJSONRequestBody defines body for SignSolanaTransaction for application/json ContentType.
type SignSolanaTransactionJSONRequestBody SignSolanaTransactionJSONBody

// RequestSolanaFaucetJSONRequestBody defines body for RequestSolanaFaucet for application/json ContentType.
type RequestSolanaFaucetJSONRequestBody RequestSolanaFaucetJSONBody

// AsAbiFunction returns the union data inside the Abi_Item as a AbiFunction
func (t Abi_Item) AsAbiFunction() (AbiFunction, error) {
	var body AbiFunction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAbiFunction overwrites any union data inside the Abi_Item as the provided AbiFunction
func (t *Abi_Item) FromAbiFunction(v AbiFunction) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAbiFunction performs a merge with any union data inside the Abi_Item, using the provided AbiFunction
func (t *Abi_Item) MergeAbiFunction(v AbiFunction) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAbiInput returns the union data inside the Abi_Item as a AbiInput
func (t Abi_Item) AsAbiInput() (AbiInput, error) {
	var body AbiInput
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAbiInput overwrites any union data inside the Abi_Item as the provided AbiInput
func (t *Abi_Item) FromAbiInput(v AbiInput) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAbiInput performs a merge with any union data inside the Abi_Item, using the provided AbiInput
func (t *Abi_Item) MergeAbiInput(v AbiInput) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t Abi_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Abi_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCreateSwapQuoteResponse returns the union data inside the CreateSwapQuoteResponseWrapper as a CreateSwapQuoteResponse
func (t CreateSwapQuoteResponseWrapper) AsCreateSwapQuoteResponse() (CreateSwapQuoteResponse, error) {
	var body CreateSwapQuoteResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateSwapQuoteResponse overwrites any union data inside the CreateSwapQuoteResponseWrapper as the provided CreateSwapQuoteResponse
func (t *CreateSwapQuoteResponseWrapper) FromCreateSwapQuoteResponse(v CreateSwapQuoteResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateSwapQuoteResponse performs a merge with any union data inside the CreateSwapQuoteResponseWrapper, using the provided CreateSwapQuoteResponse
func (t *CreateSwapQuoteResponseWrapper) MergeCreateSwapQuoteResponse(v CreateSwapQuoteResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSwapUnavailableResponse returns the union data inside the CreateSwapQuoteResponseWrapper as a SwapUnavailableResponse
func (t CreateSwapQuoteResponseWrapper) AsSwapUnavailableResponse() (SwapUnavailableResponse, error) {
	var body SwapUnavailableResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSwapUnavailableResponse overwrites any union data inside the CreateSwapQuoteResponseWrapper as the provided SwapUnavailableResponse
func (t *CreateSwapQuoteResponseWrapper) FromSwapUnavailableResponse(v SwapUnavailableResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSwapUnavailableResponse performs a merge with any union data inside the CreateSwapQuoteResponseWrapper, using the provided SwapUnavailableResponse
func (t *CreateSwapQuoteResponseWrapper) MergeSwapUnavailableResponse(v SwapUnavailableResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateSwapQuoteResponseWrapper) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateSwapQuoteResponseWrapper) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsEvmDataParameterCondition returns the union data inside the EvmDataCondition_Params_Item as a EvmDataParameterCondition
func (t EvmDataCondition_Params_Item) AsEvmDataParameterCondition() (EvmDataParameterCondition, error) {
	var body EvmDataParameterCondition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEvmDataParameterCondition overwrites any union data inside the EvmDataCondition_Params_Item as the provided EvmDataParameterCondition
func (t *EvmDataCondition_Params_Item) FromEvmDataParameterCondition(v EvmDataParameterCondition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEvmDataParameterCondition performs a merge with any union data inside the EvmDataCondition_Params_Item, using the provided EvmDataParameterCondition
func (t *EvmDataCondition_Params_Item) MergeEvmDataParameterCondition(v EvmDataParameterCondition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsEvmDataParameterConditionList returns the union data inside the EvmDataCondition_Params_Item as a EvmDataParameterConditionList
func (t EvmDataCondition_Params_Item) AsEvmDataParameterConditionList() (EvmDataParameterConditionList, error) {
	var body EvmDataParameterConditionList
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEvmDataParameterConditionList overwrites any union data inside the EvmDataCondition_Params_Item as the provided EvmDataParameterConditionList
func (t *EvmDataCondition_Params_Item) FromEvmDataParameterConditionList(v EvmDataParameterConditionList) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEvmDataParameterConditionList performs a merge with any union data inside the EvmDataCondition_Params_Item, using the provided EvmDataParameterConditionList
func (t *EvmDataCondition_Params_Item) MergeEvmDataParameterConditionList(v EvmDataParameterConditionList) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t EvmDataCondition_Params_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *EvmDataCondition_Params_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsKnownAbiType returns the union data inside the EvmDataCriterion_Abi as a KnownAbiType
func (t EvmDataCriterion_Abi) AsKnownAbiType() (KnownAbiType, error) {
	var body KnownAbiType
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromKnownAbiType overwrites any union data inside the EvmDataCriterion_Abi as the provided KnownAbiType
func (t *EvmDataCriterion_Abi) FromKnownAbiType(v KnownAbiType) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeKnownAbiType performs a merge with any union data inside the EvmDataCriterion_Abi, using the provided KnownAbiType
func (t *EvmDataCriterion_Abi) MergeKnownAbiType(v KnownAbiType) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAbi returns the union data inside the EvmDataCriterion_Abi as a Abi
func (t EvmDataCriterion_Abi) AsAbi() (Abi, error) {
	var body Abi
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAbi overwrites any union data inside the EvmDataCriterion_Abi as the provided Abi
func (t *EvmDataCriterion_Abi) FromAbi(v Abi) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAbi performs a merge with any union data inside the EvmDataCriterion_Abi, using the provided Abi
func (t *EvmDataCriterion_Abi) MergeAbi(v Abi) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t EvmDataCriterion_Abi) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *EvmDataCriterion_Abi) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsGetSwapPriceResponse returns the union data inside the GetSwapPriceResponseWrapper as a GetSwapPriceResponse
func (t GetSwapPriceResponseWrapper) AsGetSwapPriceResponse() (GetSwapPriceResponse, error) {
	var body GetSwapPriceResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetSwapPriceResponse overwrites any union data inside the GetSwapPriceResponseWrapper as the provided GetSwapPriceResponse
func (t *GetSwapPriceResponseWrapper) FromGetSwapPriceResponse(v GetSwapPriceResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetSwapPriceResponse performs a merge with any union data inside the GetSwapPriceResponseWrapper, using the provided GetSwapPriceResponse
func (t *GetSwapPriceResponseWrapper) MergeGetSwapPriceResponse(v GetSwapPriceResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSwapUnavailableResponse returns the union data inside the GetSwapPriceResponseWrapper as a SwapUnavailableResponse
func (t GetSwapPriceResponseWrapper) AsSwapUnavailableResponse() (SwapUnavailableResponse, error) {
	var body SwapUnavailableResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSwapUnavailableResponse overwrites any union data inside the GetSwapPriceResponseWrapper as the provided SwapUnavailableResponse
func (t *GetSwapPriceResponseWrapper) FromSwapUnavailableResponse(v SwapUnavailableResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSwapUnavailableResponse performs a merge with any union data inside the GetSwapPriceResponseWrapper, using the provided SwapUnavailableResponse
func (t *GetSwapPriceResponseWrapper) MergeSwapUnavailableResponse(v SwapUnavailableResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetSwapPriceResponseWrapper) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetSwapPriceResponseWrapper) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsEthValueCriterion returns the union data inside the PrepareUserOperationCriteria_Item as a EthValueCriterion
func (t PrepareUserOperationCriteria_Item) AsEthValueCriterion() (EthValueCriterion, error) {
	var body EthValueCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEthValueCriterion overwrites any union data inside the PrepareUserOperationCriteria_Item as the provided EthValueCriterion
func (t *PrepareUserOperationCriteria_Item) FromEthValueCriterion(v EthValueCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEthValueCriterion performs a merge with any union data inside the PrepareUserOperationCriteria_Item, using the provided EthValueCriterion
func (t *PrepareUserOperationCriteria_Item) MergeEthValueCriterion(v EthValueCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsEvmAddressCriterion returns the union data inside the PrepareUserOperationCriteria_Item as a EvmAddressCriterion
func (t PrepareUserOperationCriteria_Item) AsEvmAddressCriterion() (EvmAddressCriterion, error) {
	var body EvmAddressCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEvmAddressCriterion overwrites any union data inside the PrepareUserOperationCriteria_Item as the provided EvmAddressCriterion
func (t *PrepareUserOperationCriteria_Item) FromEvmAddressCriterion(v EvmAddressCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEvmAddressCriterion performs a merge with any union data inside the PrepareUserOperationCriteria_Item, using the provided EvmAddressCriterion
func (t *PrepareUserOperationCriteria_Item) MergeEvmAddressCriterion(v EvmAddressCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsEvmNetworkCriterion returns the union data inside the PrepareUserOperationCriteria_Item as a EvmNetworkCriterion
func (t PrepareUserOperationCriteria_Item) AsEvmNetworkCriterion() (EvmNetworkCriterion, error) {
	var body EvmNetworkCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEvmNetworkCriterion overwrites any union data inside the PrepareUserOperationCriteria_Item as the provided EvmNetworkCriterion
func (t *PrepareUserOperationCriteria_Item) FromEvmNetworkCriterion(v EvmNetworkCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEvmNetworkCriterion performs a merge with any union data inside the PrepareUserOperationCriteria_Item, using the provided EvmNetworkCriterion
func (t *PrepareUserOperationCriteria_Item) MergeEvmNetworkCriterion(v EvmNetworkCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsEvmDataCriterion returns the union data inside the PrepareUserOperationCriteria_Item as a EvmDataCriterion
func (t PrepareUserOperationCriteria_Item) AsEvmDataCriterion() (EvmDataCriterion, error) {
	var body EvmDataCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEvmDataCriterion overwrites any union data inside the PrepareUserOperationCriteria_Item as the provided EvmDataCriterion
func (t *PrepareUserOperationCriteria_Item) FromEvmDataCriterion(v EvmDataCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEvmDataCriterion performs a merge with any union data inside the PrepareUserOperationCriteria_Item, using the provided EvmDataCriterion
func (t *PrepareUserOperationCriteria_Item) MergeEvmDataCriterion(v EvmDataCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t PrepareUserOperationCriteria_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PrepareUserOperationCriteria_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSignEvmTransactionRule returns the union data inside the Rule as a SignEvmTransactionRule
func (t Rule) AsSignEvmTransactionRule() (SignEvmTransactionRule, error) {
	var body SignEvmTransactionRule
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSignEvmTransactionRule overwrites any union data inside the Rule as the provided SignEvmTransactionRule
func (t *Rule) FromSignEvmTransactionRule(v SignEvmTransactionRule) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSignEvmTransactionRule performs a merge with any union data inside the Rule, using the provided SignEvmTransactionRule
func (t *Rule) MergeSignEvmTransactionRule(v SignEvmTransactionRule) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSendEvmTransactionRule returns the union data inside the Rule as a SendEvmTransactionRule
func (t Rule) AsSendEvmTransactionRule() (SendEvmTransactionRule, error) {
	var body SendEvmTransactionRule
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSendEvmTransactionRule overwrites any union data inside the Rule as the provided SendEvmTransactionRule
func (t *Rule) FromSendEvmTransactionRule(v SendEvmTransactionRule) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSendEvmTransactionRule performs a merge with any union data inside the Rule, using the provided SendEvmTransactionRule
func (t *Rule) MergeSendEvmTransactionRule(v SendEvmTransactionRule) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSignEvmMessageRule returns the union data inside the Rule as a SignEvmMessageRule
func (t Rule) AsSignEvmMessageRule() (SignEvmMessageRule, error) {
	var body SignEvmMessageRule
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSignEvmMessageRule overwrites any union data inside the Rule as the provided SignEvmMessageRule
func (t *Rule) FromSignEvmMessageRule(v SignEvmMessageRule) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSignEvmMessageRule performs a merge with any union data inside the Rule, using the provided SignEvmMessageRule
func (t *Rule) MergeSignEvmMessageRule(v SignEvmMessageRule) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSignEvmTypedDataRule returns the union data inside the Rule as a SignEvmTypedDataRule
func (t Rule) AsSignEvmTypedDataRule() (SignEvmTypedDataRule, error) {
	var body SignEvmTypedDataRule
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSignEvmTypedDataRule overwrites any union data inside the Rule as the provided SignEvmTypedDataRule
func (t *Rule) FromSignEvmTypedDataRule(v SignEvmTypedDataRule) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSignEvmTypedDataRule performs a merge with any union data inside the Rule, using the provided SignEvmTypedDataRule
func (t *Rule) MergeSignEvmTypedDataRule(v SignEvmTypedDataRule) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSignSolTransactionRule returns the union data inside the Rule as a SignSolTransactionRule
func (t Rule) AsSignSolTransactionRule() (SignSolTransactionRule, error) {
	var body SignSolTransactionRule
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSignSolTransactionRule overwrites any union data inside the Rule as the provided SignSolTransactionRule
func (t *Rule) FromSignSolTransactionRule(v SignSolTransactionRule) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSignSolTransactionRule performs a merge with any union data inside the Rule, using the provided SignSolTransactionRule
func (t *Rule) MergeSignSolTransactionRule(v SignSolTransactionRule) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSendSolTransactionRule returns the union data inside the Rule as a SendSolTransactionRule
func (t Rule) AsSendSolTransactionRule() (SendSolTransactionRule, error) {
	var body SendSolTransactionRule
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSendSolTransactionRule overwrites any union data inside the Rule as the provided SendSolTransactionRule
func (t *Rule) FromSendSolTransactionRule(v SendSolTransactionRule) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSendSolTransactionRule performs a merge with any union data inside the Rule, using the provided SendSolTransactionRule
func (t *Rule) MergeSendSolTransactionRule(v SendSolTransactionRule) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSignEvmHashRule returns the union data inside the Rule as a SignEvmHashRule
func (t Rule) AsSignEvmHashRule() (SignEvmHashRule, error) {
	var body SignEvmHashRule
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSignEvmHashRule overwrites any union data inside the Rule as the provided SignEvmHashRule
func (t *Rule) FromSignEvmHashRule(v SignEvmHashRule) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSignEvmHashRule performs a merge with any union data inside the Rule, using the provided SignEvmHashRule
func (t *Rule) MergeSignEvmHashRule(v SignEvmHashRule) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsPrepareUserOperationRule returns the union data inside the Rule as a PrepareUserOperationRule
func (t Rule) AsPrepareUserOperationRule() (PrepareUserOperationRule, error) {
	var body PrepareUserOperationRule
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPrepareUserOperationRule overwrites any union data inside the Rule as the provided PrepareUserOperationRule
func (t *Rule) FromPrepareUserOperationRule(v PrepareUserOperationRule) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePrepareUserOperationRule performs a merge with any union data inside the Rule, using the provided PrepareUserOperationRule
func (t *Rule) MergePrepareUserOperationRule(v PrepareUserOperationRule) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSendUserOperationRule returns the union data inside the Rule as a SendUserOperationRule
func (t Rule) AsSendUserOperationRule() (SendUserOperationRule, error) {
	var body SendUserOperationRule
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSendUserOperationRule overwrites any union data inside the Rule as the provided SendUserOperationRule
func (t *Rule) FromSendUserOperationRule(v SendUserOperationRule) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSendUserOperationRule performs a merge with any union data inside the Rule, using the provided SendUserOperationRule
func (t *Rule) MergeSendUserOperationRule(v SendUserOperationRule) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t Rule) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Rule) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsEthValueCriterion returns the union data inside the SendEvmTransactionCriteria_Item as a EthValueCriterion
func (t SendEvmTransactionCriteria_Item) AsEthValueCriterion() (EthValueCriterion, error) {
	var body EthValueCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEthValueCriterion overwrites any union data inside the SendEvmTransactionCriteria_Item as the provided EthValueCriterion
func (t *SendEvmTransactionCriteria_Item) FromEthValueCriterion(v EthValueCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEthValueCriterion performs a merge with any union data inside the SendEvmTransactionCriteria_Item, using the provided EthValueCriterion
func (t *SendEvmTransactionCriteria_Item) MergeEthValueCriterion(v EthValueCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsEvmAddressCriterion returns the union data inside the SendEvmTransactionCriteria_Item as a EvmAddressCriterion
func (t SendEvmTransactionCriteria_Item) AsEvmAddressCriterion() (EvmAddressCriterion, error) {
	var body EvmAddressCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEvmAddressCriterion overwrites any union data inside the SendEvmTransactionCriteria_Item as the provided EvmAddressCriterion
func (t *SendEvmTransactionCriteria_Item) FromEvmAddressCriterion(v EvmAddressCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEvmAddressCriterion performs a merge with any union data inside the SendEvmTransactionCriteria_Item, using the provided EvmAddressCriterion
func (t *SendEvmTransactionCriteria_Item) MergeEvmAddressCriterion(v EvmAddressCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsEvmNetworkCriterion returns the union data inside the SendEvmTransactionCriteria_Item as a EvmNetworkCriterion
func (t SendEvmTransactionCriteria_Item) AsEvmNetworkCriterion() (EvmNetworkCriterion, error) {
	var body EvmNetworkCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEvmNetworkCriterion overwrites any union data inside the SendEvmTransactionCriteria_Item as the provided EvmNetworkCriterion
func (t *SendEvmTransactionCriteria_Item) FromEvmNetworkCriterion(v EvmNetworkCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEvmNetworkCriterion performs a merge with any union data inside the SendEvmTransactionCriteria_Item, using the provided EvmNetworkCriterion
func (t *SendEvmTransactionCriteria_Item) MergeEvmNetworkCriterion(v EvmNetworkCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsEvmDataCriterion returns the union data inside the SendEvmTransactionCriteria_Item as a EvmDataCriterion
func (t SendEvmTransactionCriteria_Item) AsEvmDataCriterion() (EvmDataCriterion, error) {
	var body EvmDataCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEvmDataCriterion overwrites any union data inside the SendEvmTransactionCriteria_Item as the provided EvmDataCriterion
func (t *SendEvmTransactionCriteria_Item) FromEvmDataCriterion(v EvmDataCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEvmDataCriterion performs a merge with any union data inside the SendEvmTransactionCriteria_Item, using the provided EvmDataCriterion
func (t *SendEvmTransactionCriteria_Item) MergeEvmDataCriterion(v EvmDataCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsNetUSDChangeCriterion returns the union data inside the SendEvmTransactionCriteria_Item as a NetUSDChangeCriterion
func (t SendEvmTransactionCriteria_Item) AsNetUSDChangeCriterion() (NetUSDChangeCriterion, error) {
	var body NetUSDChangeCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNetUSDChangeCriterion overwrites any union data inside the SendEvmTransactionCriteria_Item as the provided NetUSDChangeCriterion
func (t *SendEvmTransactionCriteria_Item) FromNetUSDChangeCriterion(v NetUSDChangeCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNetUSDChangeCriterion performs a merge with any union data inside the SendEvmTransactionCriteria_Item, using the provided NetUSDChangeCriterion
func (t *SendEvmTransactionCriteria_Item) MergeNetUSDChangeCriterion(v NetUSDChangeCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t SendEvmTransactionCriteria_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SendEvmTransactionCriteria_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSolAddressCriterion returns the union data inside the SendSolTransactionCriteria_Item as a SolAddressCriterion
func (t SendSolTransactionCriteria_Item) AsSolAddressCriterion() (SolAddressCriterion, error) {
	var body SolAddressCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSolAddressCriterion overwrites any union data inside the SendSolTransactionCriteria_Item as the provided SolAddressCriterion
func (t *SendSolTransactionCriteria_Item) FromSolAddressCriterion(v SolAddressCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSolAddressCriterion performs a merge with any union data inside the SendSolTransactionCriteria_Item, using the provided SolAddressCriterion
func (t *SendSolTransactionCriteria_Item) MergeSolAddressCriterion(v SolAddressCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSolValueCriterion returns the union data inside the SendSolTransactionCriteria_Item as a SolValueCriterion
func (t SendSolTransactionCriteria_Item) AsSolValueCriterion() (SolValueCriterion, error) {
	var body SolValueCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSolValueCriterion overwrites any union data inside the SendSolTransactionCriteria_Item as the provided SolValueCriterion
func (t *SendSolTransactionCriteria_Item) FromSolValueCriterion(v SolValueCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSolValueCriterion performs a merge with any union data inside the SendSolTransactionCriteria_Item, using the provided SolValueCriterion
func (t *SendSolTransactionCriteria_Item) MergeSolValueCriterion(v SolValueCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSplAddressCriterion returns the union data inside the SendSolTransactionCriteria_Item as a SplAddressCriterion
func (t SendSolTransactionCriteria_Item) AsSplAddressCriterion() (SplAddressCriterion, error) {
	var body SplAddressCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSplAddressCriterion overwrites any union data inside the SendSolTransactionCriteria_Item as the provided SplAddressCriterion
func (t *SendSolTransactionCriteria_Item) FromSplAddressCriterion(v SplAddressCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSplAddressCriterion performs a merge with any union data inside the SendSolTransactionCriteria_Item, using the provided SplAddressCriterion
func (t *SendSolTransactionCriteria_Item) MergeSplAddressCriterion(v SplAddressCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSplValueCriterion returns the union data inside the SendSolTransactionCriteria_Item as a SplValueCriterion
func (t SendSolTransactionCriteria_Item) AsSplValueCriterion() (SplValueCriterion, error) {
	var body SplValueCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSplValueCriterion overwrites any union data inside the SendSolTransactionCriteria_Item as the provided SplValueCriterion
func (t *SendSolTransactionCriteria_Item) FromSplValueCriterion(v SplValueCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSplValueCriterion performs a merge with any union data inside the SendSolTransactionCriteria_Item, using the provided SplValueCriterion
func (t *SendSolTransactionCriteria_Item) MergeSplValueCriterion(v SplValueCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsMintAddressCriterion returns the union data inside the SendSolTransactionCriteria_Item as a MintAddressCriterion
func (t SendSolTransactionCriteria_Item) AsMintAddressCriterion() (MintAddressCriterion, error) {
	var body MintAddressCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMintAddressCriterion overwrites any union data inside the SendSolTransactionCriteria_Item as the provided MintAddressCriterion
func (t *SendSolTransactionCriteria_Item) FromMintAddressCriterion(v MintAddressCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMintAddressCriterion performs a merge with any union data inside the SendSolTransactionCriteria_Item, using the provided MintAddressCriterion
func (t *SendSolTransactionCriteria_Item) MergeMintAddressCriterion(v MintAddressCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t SendSolTransactionCriteria_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SendSolTransactionCriteria_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsEthValueCriterion returns the union data inside the SendUserOperationCriteria_Item as a EthValueCriterion
func (t SendUserOperationCriteria_Item) AsEthValueCriterion() (EthValueCriterion, error) {
	var body EthValueCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEthValueCriterion overwrites any union data inside the SendUserOperationCriteria_Item as the provided EthValueCriterion
func (t *SendUserOperationCriteria_Item) FromEthValueCriterion(v EthValueCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEthValueCriterion performs a merge with any union data inside the SendUserOperationCriteria_Item, using the provided EthValueCriterion
func (t *SendUserOperationCriteria_Item) MergeEthValueCriterion(v EthValueCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsEvmAddressCriterion returns the union data inside the SendUserOperationCriteria_Item as a EvmAddressCriterion
func (t SendUserOperationCriteria_Item) AsEvmAddressCriterion() (EvmAddressCriterion, error) {
	var body EvmAddressCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEvmAddressCriterion overwrites any union data inside the SendUserOperationCriteria_Item as the provided EvmAddressCriterion
func (t *SendUserOperationCriteria_Item) FromEvmAddressCriterion(v EvmAddressCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEvmAddressCriterion performs a merge with any union data inside the SendUserOperationCriteria_Item, using the provided EvmAddressCriterion
func (t *SendUserOperationCriteria_Item) MergeEvmAddressCriterion(v EvmAddressCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsEvmDataCriterion returns the union data inside the SendUserOperationCriteria_Item as a EvmDataCriterion
func (t SendUserOperationCriteria_Item) AsEvmDataCriterion() (EvmDataCriterion, error) {
	var body EvmDataCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEvmDataCriterion overwrites any union data inside the SendUserOperationCriteria_Item as the provided EvmDataCriterion
func (t *SendUserOperationCriteria_Item) FromEvmDataCriterion(v EvmDataCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEvmDataCriterion performs a merge with any union data inside the SendUserOperationCriteria_Item, using the provided EvmDataCriterion
func (t *SendUserOperationCriteria_Item) MergeEvmDataCriterion(v EvmDataCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t SendUserOperationCriteria_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SendUserOperationCriteria_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsEvmMessageCriterion returns the union data inside the SignEvmMessageCriteria_Item as a EvmMessageCriterion
func (t SignEvmMessageCriteria_Item) AsEvmMessageCriterion() (EvmMessageCriterion, error) {
	var body EvmMessageCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEvmMessageCriterion overwrites any union data inside the SignEvmMessageCriteria_Item as the provided EvmMessageCriterion
func (t *SignEvmMessageCriteria_Item) FromEvmMessageCriterion(v EvmMessageCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEvmMessageCriterion performs a merge with any union data inside the SignEvmMessageCriteria_Item, using the provided EvmMessageCriterion
func (t *SignEvmMessageCriteria_Item) MergeEvmMessageCriterion(v EvmMessageCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t SignEvmMessageCriteria_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SignEvmMessageCriteria_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsEthValueCriterion returns the union data inside the SignEvmTransactionCriteria_Item as a EthValueCriterion
func (t SignEvmTransactionCriteria_Item) AsEthValueCriterion() (EthValueCriterion, error) {
	var body EthValueCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEthValueCriterion overwrites any union data inside the SignEvmTransactionCriteria_Item as the provided EthValueCriterion
func (t *SignEvmTransactionCriteria_Item) FromEthValueCriterion(v EthValueCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEthValueCriterion performs a merge with any union data inside the SignEvmTransactionCriteria_Item, using the provided EthValueCriterion
func (t *SignEvmTransactionCriteria_Item) MergeEthValueCriterion(v EthValueCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsEvmAddressCriterion returns the union data inside the SignEvmTransactionCriteria_Item as a EvmAddressCriterion
func (t SignEvmTransactionCriteria_Item) AsEvmAddressCriterion() (EvmAddressCriterion, error) {
	var body EvmAddressCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEvmAddressCriterion overwrites any union data inside the SignEvmTransactionCriteria_Item as the provided EvmAddressCriterion
func (t *SignEvmTransactionCriteria_Item) FromEvmAddressCriterion(v EvmAddressCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEvmAddressCriterion performs a merge with any union data inside the SignEvmTransactionCriteria_Item, using the provided EvmAddressCriterion
func (t *SignEvmTransactionCriteria_Item) MergeEvmAddressCriterion(v EvmAddressCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsEvmDataCriterion returns the union data inside the SignEvmTransactionCriteria_Item as a EvmDataCriterion
func (t SignEvmTransactionCriteria_Item) AsEvmDataCriterion() (EvmDataCriterion, error) {
	var body EvmDataCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEvmDataCriterion overwrites any union data inside the SignEvmTransactionCriteria_Item as the provided EvmDataCriterion
func (t *SignEvmTransactionCriteria_Item) FromEvmDataCriterion(v EvmDataCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEvmDataCriterion performs a merge with any union data inside the SignEvmTransactionCriteria_Item, using the provided EvmDataCriterion
func (t *SignEvmTransactionCriteria_Item) MergeEvmDataCriterion(v EvmDataCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsNetUSDChangeCriterion returns the union data inside the SignEvmTransactionCriteria_Item as a NetUSDChangeCriterion
func (t SignEvmTransactionCriteria_Item) AsNetUSDChangeCriterion() (NetUSDChangeCriterion, error) {
	var body NetUSDChangeCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNetUSDChangeCriterion overwrites any union data inside the SignEvmTransactionCriteria_Item as the provided NetUSDChangeCriterion
func (t *SignEvmTransactionCriteria_Item) FromNetUSDChangeCriterion(v NetUSDChangeCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNetUSDChangeCriterion performs a merge with any union data inside the SignEvmTransactionCriteria_Item, using the provided NetUSDChangeCriterion
func (t *SignEvmTransactionCriteria_Item) MergeNetUSDChangeCriterion(v NetUSDChangeCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t SignEvmTransactionCriteria_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SignEvmTransactionCriteria_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSignEvmTypedDataFieldCriterion returns the union data inside the SignEvmTypedDataCriteria_Item as a SignEvmTypedDataFieldCriterion
func (t SignEvmTypedDataCriteria_Item) AsSignEvmTypedDataFieldCriterion() (SignEvmTypedDataFieldCriterion, error) {
	var body SignEvmTypedDataFieldCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSignEvmTypedDataFieldCriterion overwrites any union data inside the SignEvmTypedDataCriteria_Item as the provided SignEvmTypedDataFieldCriterion
func (t *SignEvmTypedDataCriteria_Item) FromSignEvmTypedDataFieldCriterion(v SignEvmTypedDataFieldCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSignEvmTypedDataFieldCriterion performs a merge with any union data inside the SignEvmTypedDataCriteria_Item, using the provided SignEvmTypedDataFieldCriterion
func (t *SignEvmTypedDataCriteria_Item) MergeSignEvmTypedDataFieldCriterion(v SignEvmTypedDataFieldCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSignEvmTypedDataVerifyingContractCriterion returns the union data inside the SignEvmTypedDataCriteria_Item as a SignEvmTypedDataVerifyingContractCriterion
func (t SignEvmTypedDataCriteria_Item) AsSignEvmTypedDataVerifyingContractCriterion() (SignEvmTypedDataVerifyingContractCriterion, error) {
	var body SignEvmTypedDataVerifyingContractCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSignEvmTypedDataVerifyingContractCriterion overwrites any union data inside the SignEvmTypedDataCriteria_Item as the provided SignEvmTypedDataVerifyingContractCriterion
func (t *SignEvmTypedDataCriteria_Item) FromSignEvmTypedDataVerifyingContractCriterion(v SignEvmTypedDataVerifyingContractCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSignEvmTypedDataVerifyingContractCriterion performs a merge with any union data inside the SignEvmTypedDataCriteria_Item, using the provided SignEvmTypedDataVerifyingContractCriterion
func (t *SignEvmTypedDataCriteria_Item) MergeSignEvmTypedDataVerifyingContractCriterion(v SignEvmTypedDataVerifyingContractCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t SignEvmTypedDataCriteria_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SignEvmTypedDataCriteria_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsEvmTypedAddressCondition returns the union data inside the SignEvmTypedDataFieldCriterion_Conditions_Item as a EvmTypedAddressCondition
func (t SignEvmTypedDataFieldCriterion_Conditions_Item) AsEvmTypedAddressCondition() (EvmTypedAddressCondition, error) {
	var body EvmTypedAddressCondition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEvmTypedAddressCondition overwrites any union data inside the SignEvmTypedDataFieldCriterion_Conditions_Item as the provided EvmTypedAddressCondition
func (t *SignEvmTypedDataFieldCriterion_Conditions_Item) FromEvmTypedAddressCondition(v EvmTypedAddressCondition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEvmTypedAddressCondition performs a merge with any union data inside the SignEvmTypedDataFieldCriterion_Conditions_Item, using the provided EvmTypedAddressCondition
func (t *SignEvmTypedDataFieldCriterion_Conditions_Item) MergeEvmTypedAddressCondition(v EvmTypedAddressCondition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsEvmTypedNumericalCondition returns the union data inside the SignEvmTypedDataFieldCriterion_Conditions_Item as a EvmTypedNumericalCondition
func (t SignEvmTypedDataFieldCriterion_Conditions_Item) AsEvmTypedNumericalCondition() (EvmTypedNumericalCondition, error) {
	var body EvmTypedNumericalCondition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEvmTypedNumericalCondition overwrites any union data inside the SignEvmTypedDataFieldCriterion_Conditions_Item as the provided EvmTypedNumericalCondition
func (t *SignEvmTypedDataFieldCriterion_Conditions_Item) FromEvmTypedNumericalCondition(v EvmTypedNumericalCondition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEvmTypedNumericalCondition performs a merge with any union data inside the SignEvmTypedDataFieldCriterion_Conditions_Item, using the provided EvmTypedNumericalCondition
func (t *SignEvmTypedDataFieldCriterion_Conditions_Item) MergeEvmTypedNumericalCondition(v EvmTypedNumericalCondition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsEvmTypedStringCondition returns the union data inside the SignEvmTypedDataFieldCriterion_Conditions_Item as a EvmTypedStringCondition
func (t SignEvmTypedDataFieldCriterion_Conditions_Item) AsEvmTypedStringCondition() (EvmTypedStringCondition, error) {
	var body EvmTypedStringCondition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEvmTypedStringCondition overwrites any union data inside the SignEvmTypedDataFieldCriterion_Conditions_Item as the provided EvmTypedStringCondition
func (t *SignEvmTypedDataFieldCriterion_Conditions_Item) FromEvmTypedStringCondition(v EvmTypedStringCondition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEvmTypedStringCondition performs a merge with any union data inside the SignEvmTypedDataFieldCriterion_Conditions_Item, using the provided EvmTypedStringCondition
func (t *SignEvmTypedDataFieldCriterion_Conditions_Item) MergeEvmTypedStringCondition(v EvmTypedStringCondition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t SignEvmTypedDataFieldCriterion_Conditions_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SignEvmTypedDataFieldCriterion_Conditions_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSolAddressCriterion returns the union data inside the SignSolTransactionCriteria_Item as a SolAddressCriterion
func (t SignSolTransactionCriteria_Item) AsSolAddressCriterion() (SolAddressCriterion, error) {
	var body SolAddressCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSolAddressCriterion overwrites any union data inside the SignSolTransactionCriteria_Item as the provided SolAddressCriterion
func (t *SignSolTransactionCriteria_Item) FromSolAddressCriterion(v SolAddressCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSolAddressCriterion performs a merge with any union data inside the SignSolTransactionCriteria_Item, using the provided SolAddressCriterion
func (t *SignSolTransactionCriteria_Item) MergeSolAddressCriterion(v SolAddressCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSolValueCriterion returns the union data inside the SignSolTransactionCriteria_Item as a SolValueCriterion
func (t SignSolTransactionCriteria_Item) AsSolValueCriterion() (SolValueCriterion, error) {
	var body SolValueCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSolValueCriterion overwrites any union data inside the SignSolTransactionCriteria_Item as the provided SolValueCriterion
func (t *SignSolTransactionCriteria_Item) FromSolValueCriterion(v SolValueCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSolValueCriterion performs a merge with any union data inside the SignSolTransactionCriteria_Item, using the provided SolValueCriterion
func (t *SignSolTransactionCriteria_Item) MergeSolValueCriterion(v SolValueCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSplAddressCriterion returns the union data inside the SignSolTransactionCriteria_Item as a SplAddressCriterion
func (t SignSolTransactionCriteria_Item) AsSplAddressCriterion() (SplAddressCriterion, error) {
	var body SplAddressCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSplAddressCriterion overwrites any union data inside the SignSolTransactionCriteria_Item as the provided SplAddressCriterion
func (t *SignSolTransactionCriteria_Item) FromSplAddressCriterion(v SplAddressCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSplAddressCriterion performs a merge with any union data inside the SignSolTransactionCriteria_Item, using the provided SplAddressCriterion
func (t *SignSolTransactionCriteria_Item) MergeSplAddressCriterion(v SplAddressCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSplValueCriterion returns the union data inside the SignSolTransactionCriteria_Item as a SplValueCriterion
func (t SignSolTransactionCriteria_Item) AsSplValueCriterion() (SplValueCriterion, error) {
	var body SplValueCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSplValueCriterion overwrites any union data inside the SignSolTransactionCriteria_Item as the provided SplValueCriterion
func (t *SignSolTransactionCriteria_Item) FromSplValueCriterion(v SplValueCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSplValueCriterion performs a merge with any union data inside the SignSolTransactionCriteria_Item, using the provided SplValueCriterion
func (t *SignSolTransactionCriteria_Item) MergeSplValueCriterion(v SplValueCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsMintAddressCriterion returns the union data inside the SignSolTransactionCriteria_Item as a MintAddressCriterion
func (t SignSolTransactionCriteria_Item) AsMintAddressCriterion() (MintAddressCriterion, error) {
	var body MintAddressCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMintAddressCriterion overwrites any union data inside the SignSolTransactionCriteria_Item as the provided MintAddressCriterion
func (t *SignSolTransactionCriteria_Item) FromMintAddressCriterion(v MintAddressCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMintAddressCriterion performs a merge with any union data inside the SignSolTransactionCriteria_Item, using the provided MintAddressCriterion
func (t *SignSolTransactionCriteria_Item) MergeMintAddressCriterion(v MintAddressCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t SignSolTransactionCriteria_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SignSolTransactionCriteria_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPaymentMethodRequest returns the union data inside the Transfer_Source as a PaymentMethodRequest
func (t Transfer_Source) AsPaymentMethodRequest() (PaymentMethodRequest, error) {
	var body PaymentMethodRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPaymentMethodRequest overwrites any union data inside the Transfer_Source as the provided PaymentMethodRequest
func (t *Transfer_Source) FromPaymentMethodRequest(v PaymentMethodRequest) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePaymentMethodRequest performs a merge with any union data inside the Transfer_Source, using the provided PaymentMethodRequest
func (t *Transfer_Source) MergePaymentMethodRequest(v PaymentMethodRequest) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t Transfer_Source) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Transfer_Source) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCryptoRailAddress returns the union data inside the Transfer_Target as a CryptoRailAddress
func (t Transfer_Target) AsCryptoRailAddress() (CryptoRailAddress, error) {
	var body CryptoRailAddress
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCryptoRailAddress overwrites any union data inside the Transfer_Target as the provided CryptoRailAddress
func (t *Transfer_Target) FromCryptoRailAddress(v CryptoRailAddress) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCryptoRailAddress performs a merge with any union data inside the Transfer_Target, using the provided CryptoRailAddress
func (t *Transfer_Target) MergeCryptoRailAddress(v CryptoRailAddress) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t Transfer_Target) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Transfer_Target) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPaymentMethodRequest returns the union data inside the TransferSource as a PaymentMethodRequest
func (t TransferSource) AsPaymentMethodRequest() (PaymentMethodRequest, error) {
	var body PaymentMethodRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPaymentMethodRequest overwrites any union data inside the TransferSource as the provided PaymentMethodRequest
func (t *TransferSource) FromPaymentMethodRequest(v PaymentMethodRequest) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePaymentMethodRequest performs a merge with any union data inside the TransferSource, using the provided PaymentMethodRequest
func (t *TransferSource) MergePaymentMethodRequest(v PaymentMethodRequest) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t TransferSource) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *TransferSource) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCryptoRailAddress returns the union data inside the TransferTarget as a CryptoRailAddress
func (t TransferTarget) AsCryptoRailAddress() (CryptoRailAddress, error) {
	var body CryptoRailAddress
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCryptoRailAddress overwrites any union data inside the TransferTarget as the provided CryptoRailAddress
func (t *TransferTarget) FromCryptoRailAddress(v CryptoRailAddress) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCryptoRailAddress performs a merge with any union data inside the TransferTarget, using the provided CryptoRailAddress
func (t *TransferTarget) MergeCryptoRailAddress(v CryptoRailAddress) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t TransferTarget) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *TransferTarget) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// CDPClient which conforms to the OpenAPI3 specification for this service.
type CDPClient struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*CDPClient) error

// Creates a new CDPClient, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*CDPClient, error) {
	// create a client with sane default values
	client := CDPClient{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *CDPClient) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *CDPClient) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// RunSQLQueryWithBody request with any body
	RunSQLQueryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RunSQLQuery(ctx context.Context, body RunSQLQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListEvmAccounts request
	ListEvmAccounts(ctx context.Context, params *ListEvmAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateEvmAccountWithBody request with any body
	CreateEvmAccountWithBody(ctx context.Context, params *CreateEvmAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateEvmAccount(ctx context.Context, params *CreateEvmAccountParams, body CreateEvmAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEvmAccountByName request
	GetEvmAccountByName(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExportEvmAccountByNameWithBody request with any body
	ExportEvmAccountByNameWithBody(ctx context.Context, name string, params *ExportEvmAccountByNameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ExportEvmAccountByName(ctx context.Context, name string, params *ExportEvmAccountByNameParams, body ExportEvmAccountByNameJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ImportEvmAccountWithBody request with any body
	ImportEvmAccountWithBody(ctx context.Context, params *ImportEvmAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ImportEvmAccount(ctx context.Context, params *ImportEvmAccountParams, body ImportEvmAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEvmAccount request
	GetEvmAccount(ctx context.Context, address string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateEvmAccountWithBody request with any body
	UpdateEvmAccountWithBody(ctx context.Context, address string, params *UpdateEvmAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateEvmAccount(ctx context.Context, address string, params *UpdateEvmAccountParams, body UpdateEvmAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExportEvmAccountWithBody request with any body
	ExportEvmAccountWithBody(ctx context.Context, address string, params *ExportEvmAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ExportEvmAccount(ctx context.Context, address string, params *ExportEvmAccountParams, body ExportEvmAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendEvmTransactionWithBody request with any body
	SendEvmTransactionWithBody(ctx context.Context, address string, params *SendEvmTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SendEvmTransaction(ctx context.Context, address string, params *SendEvmTransactionParams, body SendEvmTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SignEvmHashWithBody request with any body
	SignEvmHashWithBody(ctx context.Context, address string, params *SignEvmHashParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SignEvmHash(ctx context.Context, address string, params *SignEvmHashParams, body SignEvmHashJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SignEvmMessageWithBody request with any body
	SignEvmMessageWithBody(ctx context.Context, address string, params *SignEvmMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SignEvmMessage(ctx context.Context, address string, params *SignEvmMessageParams, body SignEvmMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SignEvmTransactionWithBody request with any body
	SignEvmTransactionWithBody(ctx context.Context, address string, params *SignEvmTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SignEvmTransaction(ctx context.Context, address string, params *SignEvmTransactionParams, body SignEvmTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SignEvmTypedDataWithBody request with any body
	SignEvmTypedDataWithBody(ctx context.Context, address string, params *SignEvmTypedDataParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SignEvmTypedData(ctx context.Context, address string, params *SignEvmTypedDataParams, body SignEvmTypedDataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RequestEvmFaucetWithBody request with any body
	RequestEvmFaucetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RequestEvmFaucet(ctx context.Context, body RequestEvmFaucetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListEvmSmartAccounts request
	ListEvmSmartAccounts(ctx context.Context, params *ListEvmSmartAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateEvmSmartAccountWithBody request with any body
	CreateEvmSmartAccountWithBody(ctx context.Context, params *CreateEvmSmartAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateEvmSmartAccount(ctx context.Context, params *CreateEvmSmartAccountParams, body CreateEvmSmartAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEvmSmartAccountByName request
	GetEvmSmartAccountByName(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEvmSmartAccount request
	GetEvmSmartAccount(ctx context.Context, address string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateEvmSmartAccountWithBody request with any body
	UpdateEvmSmartAccountWithBody(ctx context.Context, address string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateEvmSmartAccount(ctx context.Context, address string, body UpdateEvmSmartAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSpendPermissionWithBody request with any body
	CreateSpendPermissionWithBody(ctx context.Context, address string, params *CreateSpendPermissionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSpendPermission(ctx context.Context, address string, params *CreateSpendPermissionParams, body CreateSpendPermissionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSpendPermissions request
	ListSpendPermissions(ctx context.Context, address string, params *ListSpendPermissionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevokeSpendPermissionWithBody request with any body
	RevokeSpendPermissionWithBody(ctx context.Context, address string, params *RevokeSpendPermissionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RevokeSpendPermission(ctx context.Context, address string, params *RevokeSpendPermissionParams, body RevokeSpendPermissionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PrepareUserOperationWithBody request with any body
	PrepareUserOperationWithBody(ctx context.Context, address string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PrepareUserOperation(ctx context.Context, address string, body PrepareUserOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserOperation request
	GetUserOperation(ctx context.Context, address string, userOpHash string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendUserOperationWithBody request with any body
	SendUserOperationWithBody(ctx context.Context, address string, userOpHash string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SendUserOperation(ctx context.Context, address string, userOpHash string, body SendUserOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateEvmSwapQuoteWithBody request with any body
	CreateEvmSwapQuoteWithBody(ctx context.Context, params *CreateEvmSwapQuoteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateEvmSwapQuote(ctx context.Context, params *CreateEvmSwapQuoteParams, body CreateEvmSwapQuoteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEvmSwapPrice request
	GetEvmSwapPrice(ctx context.Context, params *GetEvmSwapPriceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListEvmTokenBalances request
	ListEvmTokenBalances(ctx context.Context, network ListEvmTokenBalancesNetwork, address string, params *ListEvmTokenBalancesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateOnrampOrderWithBody request with any body
	CreateOnrampOrderWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateOnrampOrder(ctx context.Context, body CreateOnrampOrderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOnrampOrderById request
	GetOnrampOrderById(ctx context.Context, orderId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCryptoRails request
	GetCryptoRails(ctx context.Context, params *GetCryptoRailsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPaymentMethods request
	GetPaymentMethods(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePaymentTransferQuoteWithBody request with any body
	CreatePaymentTransferQuoteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePaymentTransferQuote(ctx context.Context, body CreatePaymentTransferQuoteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPaymentTransfer request
	GetPaymentTransfer(ctx context.Context, transferId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExecutePaymentTransferQuote request
	ExecutePaymentTransferQuote(ctx context.Context, transferId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPolicies request
	ListPolicies(ctx context.Context, params *ListPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePolicyWithBody request with any body
	CreatePolicyWithBody(ctx context.Context, params *CreatePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePolicy(ctx context.Context, params *CreatePolicyParams, body CreatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePolicy request
	DeletePolicy(ctx context.Context, policyId string, params *DeletePolicyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPolicyById request
	GetPolicyById(ctx context.Context, policyId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePolicyWithBody request with any body
	UpdatePolicyWithBody(ctx context.Context, policyId string, params *UpdatePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePolicy(ctx context.Context, policyId string, params *UpdatePolicyParams, body UpdatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSolanaAccounts request
	ListSolanaAccounts(ctx context.Context, params *ListSolanaAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSolanaAccountWithBody request with any body
	CreateSolanaAccountWithBody(ctx context.Context, params *CreateSolanaAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSolanaAccount(ctx context.Context, params *CreateSolanaAccountParams, body CreateSolanaAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSolanaAccountByName request
	GetSolanaAccountByName(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExportSolanaAccountByNameWithBody request with any body
	ExportSolanaAccountByNameWithBody(ctx context.Context, name string, params *ExportSolanaAccountByNameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ExportSolanaAccountByName(ctx context.Context, name string, params *ExportSolanaAccountByNameParams, body ExportSolanaAccountByNameJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ImportSolanaAccountWithBody request with any body
	ImportSolanaAccountWithBody(ctx context.Context, params *ImportSolanaAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ImportSolanaAccount(ctx context.Context, params *ImportSolanaAccountParams, body ImportSolanaAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendSolanaTransactionWithBody request with any body
	SendSolanaTransactionWithBody(ctx context.Context, params *SendSolanaTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SendSolanaTransaction(ctx context.Context, params *SendSolanaTransactionParams, body SendSolanaTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSolanaAccount request
	GetSolanaAccount(ctx context.Context, address string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSolanaAccountWithBody request with any body
	UpdateSolanaAccountWithBody(ctx context.Context, address string, params *UpdateSolanaAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSolanaAccount(ctx context.Context, address string, params *UpdateSolanaAccountParams, body UpdateSolanaAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExportSolanaAccountWithBody request with any body
	ExportSolanaAccountWithBody(ctx context.Context, address string, params *ExportSolanaAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ExportSolanaAccount(ctx context.Context, address string, params *ExportSolanaAccountParams, body ExportSolanaAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SignSolanaMessageWithBody request with any body
	SignSolanaMessageWithBody(ctx context.Context, address string, params *SignSolanaMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SignSolanaMessage(ctx context.Context, address string, params *SignSolanaMessageParams, body SignSolanaMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SignSolanaTransactionWithBody request with any body
	SignSolanaTransactionWithBody(ctx context.Context, address string, params *SignSolanaTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SignSolanaTransaction(ctx context.Context, address string, params *SignSolanaTransactionParams, body SignSolanaTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RequestSolanaFaucetWithBody request with any body
	RequestSolanaFaucetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RequestSolanaFaucet(ctx context.Context, body RequestSolanaFaucetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSolanaTokenBalances request
	ListSolanaTokenBalances(ctx context.Context, network ListSolanaTokenBalancesNetwork, address string, params *ListSolanaTokenBalancesParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *CDPClient) RunSQLQueryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunSQLQueryRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) RunSQLQuery(ctx context.Context, body RunSQLQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunSQLQueryRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) ListEvmAccounts(ctx context.Context, params *ListEvmAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListEvmAccountsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) CreateEvmAccountWithBody(ctx context.Context, params *CreateEvmAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEvmAccountRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) CreateEvmAccount(ctx context.Context, params *CreateEvmAccountParams, body CreateEvmAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEvmAccountRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) GetEvmAccountByName(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEvmAccountByNameRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) ExportEvmAccountByNameWithBody(ctx context.Context, name string, params *ExportEvmAccountByNameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportEvmAccountByNameRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) ExportEvmAccountByName(ctx context.Context, name string, params *ExportEvmAccountByNameParams, body ExportEvmAccountByNameJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportEvmAccountByNameRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) ImportEvmAccountWithBody(ctx context.Context, params *ImportEvmAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportEvmAccountRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) ImportEvmAccount(ctx context.Context, params *ImportEvmAccountParams, body ImportEvmAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportEvmAccountRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) GetEvmAccount(ctx context.Context, address string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEvmAccountRequest(c.Server, address)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) UpdateEvmAccountWithBody(ctx context.Context, address string, params *UpdateEvmAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEvmAccountRequestWithBody(c.Server, address, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) UpdateEvmAccount(ctx context.Context, address string, params *UpdateEvmAccountParams, body UpdateEvmAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEvmAccountRequest(c.Server, address, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) ExportEvmAccountWithBody(ctx context.Context, address string, params *ExportEvmAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportEvmAccountRequestWithBody(c.Server, address, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) ExportEvmAccount(ctx context.Context, address string, params *ExportEvmAccountParams, body ExportEvmAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportEvmAccountRequest(c.Server, address, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SendEvmTransactionWithBody(ctx context.Context, address string, params *SendEvmTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendEvmTransactionRequestWithBody(c.Server, address, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SendEvmTransaction(ctx context.Context, address string, params *SendEvmTransactionParams, body SendEvmTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendEvmTransactionRequest(c.Server, address, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SignEvmHashWithBody(ctx context.Context, address string, params *SignEvmHashParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSignEvmHashRequestWithBody(c.Server, address, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SignEvmHash(ctx context.Context, address string, params *SignEvmHashParams, body SignEvmHashJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSignEvmHashRequest(c.Server, address, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SignEvmMessageWithBody(ctx context.Context, address string, params *SignEvmMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSignEvmMessageRequestWithBody(c.Server, address, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SignEvmMessage(ctx context.Context, address string, params *SignEvmMessageParams, body SignEvmMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSignEvmMessageRequest(c.Server, address, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SignEvmTransactionWithBody(ctx context.Context, address string, params *SignEvmTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSignEvmTransactionRequestWithBody(c.Server, address, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SignEvmTransaction(ctx context.Context, address string, params *SignEvmTransactionParams, body SignEvmTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSignEvmTransactionRequest(c.Server, address, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SignEvmTypedDataWithBody(ctx context.Context, address string, params *SignEvmTypedDataParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSignEvmTypedDataRequestWithBody(c.Server, address, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SignEvmTypedData(ctx context.Context, address string, params *SignEvmTypedDataParams, body SignEvmTypedDataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSignEvmTypedDataRequest(c.Server, address, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) RequestEvmFaucetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRequestEvmFaucetRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) RequestEvmFaucet(ctx context.Context, body RequestEvmFaucetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRequestEvmFaucetRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) ListEvmSmartAccounts(ctx context.Context, params *ListEvmSmartAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListEvmSmartAccountsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) CreateEvmSmartAccountWithBody(ctx context.Context, params *CreateEvmSmartAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEvmSmartAccountRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) CreateEvmSmartAccount(ctx context.Context, params *CreateEvmSmartAccountParams, body CreateEvmSmartAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEvmSmartAccountRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) GetEvmSmartAccountByName(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEvmSmartAccountByNameRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) GetEvmSmartAccount(ctx context.Context, address string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEvmSmartAccountRequest(c.Server, address)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) UpdateEvmSmartAccountWithBody(ctx context.Context, address string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEvmSmartAccountRequestWithBody(c.Server, address, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) UpdateEvmSmartAccount(ctx context.Context, address string, body UpdateEvmSmartAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEvmSmartAccountRequest(c.Server, address, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) CreateSpendPermissionWithBody(ctx context.Context, address string, params *CreateSpendPermissionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSpendPermissionRequestWithBody(c.Server, address, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) CreateSpendPermission(ctx context.Context, address string, params *CreateSpendPermissionParams, body CreateSpendPermissionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSpendPermissionRequest(c.Server, address, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) ListSpendPermissions(ctx context.Context, address string, params *ListSpendPermissionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSpendPermissionsRequest(c.Server, address, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) RevokeSpendPermissionWithBody(ctx context.Context, address string, params *RevokeSpendPermissionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevokeSpendPermissionRequestWithBody(c.Server, address, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) RevokeSpendPermission(ctx context.Context, address string, params *RevokeSpendPermissionParams, body RevokeSpendPermissionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevokeSpendPermissionRequest(c.Server, address, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) PrepareUserOperationWithBody(ctx context.Context, address string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPrepareUserOperationRequestWithBody(c.Server, address, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) PrepareUserOperation(ctx context.Context, address string, body PrepareUserOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPrepareUserOperationRequest(c.Server, address, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) GetUserOperation(ctx context.Context, address string, userOpHash string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserOperationRequest(c.Server, address, userOpHash)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SendUserOperationWithBody(ctx context.Context, address string, userOpHash string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendUserOperationRequestWithBody(c.Server, address, userOpHash, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SendUserOperation(ctx context.Context, address string, userOpHash string, body SendUserOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendUserOperationRequest(c.Server, address, userOpHash, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) CreateEvmSwapQuoteWithBody(ctx context.Context, params *CreateEvmSwapQuoteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEvmSwapQuoteRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) CreateEvmSwapQuote(ctx context.Context, params *CreateEvmSwapQuoteParams, body CreateEvmSwapQuoteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEvmSwapQuoteRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) GetEvmSwapPrice(ctx context.Context, params *GetEvmSwapPriceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEvmSwapPriceRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) ListEvmTokenBalances(ctx context.Context, network ListEvmTokenBalancesNetwork, address string, params *ListEvmTokenBalancesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListEvmTokenBalancesRequest(c.Server, network, address, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) CreateOnrampOrderWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOnrampOrderRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) CreateOnrampOrder(ctx context.Context, body CreateOnrampOrderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOnrampOrderRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) GetOnrampOrderById(ctx context.Context, orderId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOnrampOrderByIdRequest(c.Server, orderId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) GetCryptoRails(ctx context.Context, params *GetCryptoRailsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCryptoRailsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) GetPaymentMethods(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPaymentMethodsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) CreatePaymentTransferQuoteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePaymentTransferQuoteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) CreatePaymentTransferQuote(ctx context.Context, body CreatePaymentTransferQuoteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePaymentTransferQuoteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) GetPaymentTransfer(ctx context.Context, transferId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPaymentTransferRequest(c.Server, transferId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) ExecutePaymentTransferQuote(ctx context.Context, transferId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExecutePaymentTransferQuoteRequest(c.Server, transferId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) ListPolicies(ctx context.Context, params *ListPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) CreatePolicyWithBody(ctx context.Context, params *CreatePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePolicyRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) CreatePolicy(ctx context.Context, params *CreatePolicyParams, body CreatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePolicyRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) DeletePolicy(ctx context.Context, policyId string, params *DeletePolicyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePolicyRequest(c.Server, policyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) GetPolicyById(ctx context.Context, policyId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPolicyByIdRequest(c.Server, policyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) UpdatePolicyWithBody(ctx context.Context, policyId string, params *UpdatePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePolicyRequestWithBody(c.Server, policyId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) UpdatePolicy(ctx context.Context, policyId string, params *UpdatePolicyParams, body UpdatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePolicyRequest(c.Server, policyId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) ListSolanaAccounts(ctx context.Context, params *ListSolanaAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSolanaAccountsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) CreateSolanaAccountWithBody(ctx context.Context, params *CreateSolanaAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSolanaAccountRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) CreateSolanaAccount(ctx context.Context, params *CreateSolanaAccountParams, body CreateSolanaAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSolanaAccountRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) GetSolanaAccountByName(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSolanaAccountByNameRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) ExportSolanaAccountByNameWithBody(ctx context.Context, name string, params *ExportSolanaAccountByNameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportSolanaAccountByNameRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) ExportSolanaAccountByName(ctx context.Context, name string, params *ExportSolanaAccountByNameParams, body ExportSolanaAccountByNameJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportSolanaAccountByNameRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) ImportSolanaAccountWithBody(ctx context.Context, params *ImportSolanaAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportSolanaAccountRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) ImportSolanaAccount(ctx context.Context, params *ImportSolanaAccountParams, body ImportSolanaAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportSolanaAccountRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SendSolanaTransactionWithBody(ctx context.Context, params *SendSolanaTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendSolanaTransactionRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SendSolanaTransaction(ctx context.Context, params *SendSolanaTransactionParams, body SendSolanaTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendSolanaTransactionRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) GetSolanaAccount(ctx context.Context, address string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSolanaAccountRequest(c.Server, address)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) UpdateSolanaAccountWithBody(ctx context.Context, address string, params *UpdateSolanaAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSolanaAccountRequestWithBody(c.Server, address, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) UpdateSolanaAccount(ctx context.Context, address string, params *UpdateSolanaAccountParams, body UpdateSolanaAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSolanaAccountRequest(c.Server, address, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) ExportSolanaAccountWithBody(ctx context.Context, address string, params *ExportSolanaAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportSolanaAccountRequestWithBody(c.Server, address, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) ExportSolanaAccount(ctx context.Context, address string, params *ExportSolanaAccountParams, body ExportSolanaAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportSolanaAccountRequest(c.Server, address, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SignSolanaMessageWithBody(ctx context.Context, address string, params *SignSolanaMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSignSolanaMessageRequestWithBody(c.Server, address, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SignSolanaMessage(ctx context.Context, address string, params *SignSolanaMessageParams, body SignSolanaMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSignSolanaMessageRequest(c.Server, address, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SignSolanaTransactionWithBody(ctx context.Context, address string, params *SignSolanaTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSignSolanaTransactionRequestWithBody(c.Server, address, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SignSolanaTransaction(ctx context.Context, address string, params *SignSolanaTransactionParams, body SignSolanaTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSignSolanaTransactionRequest(c.Server, address, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) RequestSolanaFaucetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRequestSolanaFaucetRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) RequestSolanaFaucet(ctx context.Context, body RequestSolanaFaucetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRequestSolanaFaucetRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) ListSolanaTokenBalances(ctx context.Context, network ListSolanaTokenBalancesNetwork, address string, params *ListSolanaTokenBalancesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSolanaTokenBalancesRequest(c.Server, network, address, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewRunSQLQueryRequest calls the generic RunSQLQuery builder with application/json body
func NewRunSQLQueryRequest(server string, body RunSQLQueryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRunSQLQueryRequestWithBody(server, "application/json", bodyReader)
}

// NewRunSQLQueryRequestWithBody generates requests for RunSQLQuery with any type of body
func NewRunSQLQueryRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/data/query/run")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListEvmAccountsRequest generates requests for ListEvmAccounts
func NewListEvmAccountsRequest(server string, params *ListEvmAccountsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/accounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateEvmAccountRequest calls the generic CreateEvmAccount builder with application/json body
func NewCreateEvmAccountRequest(server string, params *CreateEvmAccountParams, body CreateEvmAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateEvmAccountRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateEvmAccountRequestWithBody generates requests for CreateEvmAccount with any type of body
func NewCreateEvmAccountRequestWithBody(server string, params *CreateEvmAccountParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/accounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XWalletAuth != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Wallet-Auth", runtime.ParamLocationHeader, *params.XWalletAuth)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Wallet-Auth", headerParam0)
		}

		if params.XIdempotencyKey != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam1)
		}

	}

	return req, nil
}

// NewGetEvmAccountByNameRequest generates requests for GetEvmAccountByName
func NewGetEvmAccountByNameRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/accounts/by-name/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExportEvmAccountByNameRequest calls the generic ExportEvmAccountByName builder with application/json body
func NewExportEvmAccountByNameRequest(server string, name string, params *ExportEvmAccountByNameParams, body ExportEvmAccountByNameJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExportEvmAccountByNameRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewExportEvmAccountByNameRequestWithBody generates requests for ExportEvmAccountByName with any type of body
func NewExportEvmAccountByNameRequestWithBody(server string, name string, params *ExportEvmAccountByNameParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/accounts/export/by-name/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XWalletAuth != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Wallet-Auth", runtime.ParamLocationHeader, *params.XWalletAuth)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Wallet-Auth", headerParam0)
		}

		if params.XIdempotencyKey != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam1)
		}

	}

	return req, nil
}

// NewImportEvmAccountRequest calls the generic ImportEvmAccount builder with application/json body
func NewImportEvmAccountRequest(server string, params *ImportEvmAccountParams, body ImportEvmAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewImportEvmAccountRequestWithBody(server, params, "application/json", bodyReader)
}

// NewImportEvmAccountRequestWithBody generates requests for ImportEvmAccount with any type of body
func NewImportEvmAccountRequestWithBody(server string, params *ImportEvmAccountParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/accounts/import")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XWalletAuth != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Wallet-Auth", runtime.ParamLocationHeader, *params.XWalletAuth)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Wallet-Auth", headerParam0)
		}

		if params.XIdempotencyKey != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam1)
		}

	}

	return req, nil
}

// NewGetEvmAccountRequest generates requests for GetEvmAccount
func NewGetEvmAccountRequest(server string, address string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/accounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateEvmAccountRequest calls the generic UpdateEvmAccount builder with application/json body
func NewUpdateEvmAccountRequest(server string, address string, params *UpdateEvmAccountParams, body UpdateEvmAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateEvmAccountRequestWithBody(server, address, params, "application/json", bodyReader)
}

// NewUpdateEvmAccountRequestWithBody generates requests for UpdateEvmAccount with any type of body
func NewUpdateEvmAccountRequestWithBody(server string, address string, params *UpdateEvmAccountParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/accounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XIdempotencyKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam0)
		}

	}

	return req, nil
}

// NewExportEvmAccountRequest calls the generic ExportEvmAccount builder with application/json body
func NewExportEvmAccountRequest(server string, address string, params *ExportEvmAccountParams, body ExportEvmAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExportEvmAccountRequestWithBody(server, address, params, "application/json", bodyReader)
}

// NewExportEvmAccountRequestWithBody generates requests for ExportEvmAccount with any type of body
func NewExportEvmAccountRequestWithBody(server string, address string, params *ExportEvmAccountParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/accounts/%s/export", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XWalletAuth != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Wallet-Auth", runtime.ParamLocationHeader, *params.XWalletAuth)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Wallet-Auth", headerParam0)
		}

		if params.XIdempotencyKey != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam1)
		}

	}

	return req, nil
}

// NewSendEvmTransactionRequest calls the generic SendEvmTransaction builder with application/json body
func NewSendEvmTransactionRequest(server string, address string, params *SendEvmTransactionParams, body SendEvmTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSendEvmTransactionRequestWithBody(server, address, params, "application/json", bodyReader)
}

// NewSendEvmTransactionRequestWithBody generates requests for SendEvmTransaction with any type of body
func NewSendEvmTransactionRequestWithBody(server string, address string, params *SendEvmTransactionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/accounts/%s/send/transaction", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XWalletAuth != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Wallet-Auth", runtime.ParamLocationHeader, *params.XWalletAuth)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Wallet-Auth", headerParam0)
		}

		if params.XIdempotencyKey != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam1)
		}

	}

	return req, nil
}

// NewSignEvmHashRequest calls the generic SignEvmHash builder with application/json body
func NewSignEvmHashRequest(server string, address string, params *SignEvmHashParams, body SignEvmHashJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSignEvmHashRequestWithBody(server, address, params, "application/json", bodyReader)
}

// NewSignEvmHashRequestWithBody generates requests for SignEvmHash with any type of body
func NewSignEvmHashRequestWithBody(server string, address string, params *SignEvmHashParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/accounts/%s/sign", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XWalletAuth != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Wallet-Auth", runtime.ParamLocationHeader, *params.XWalletAuth)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Wallet-Auth", headerParam0)
		}

		if params.XIdempotencyKey != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam1)
		}

	}

	return req, nil
}

// NewSignEvmMessageRequest calls the generic SignEvmMessage builder with application/json body
func NewSignEvmMessageRequest(server string, address string, params *SignEvmMessageParams, body SignEvmMessageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSignEvmMessageRequestWithBody(server, address, params, "application/json", bodyReader)
}

// NewSignEvmMessageRequestWithBody generates requests for SignEvmMessage with any type of body
func NewSignEvmMessageRequestWithBody(server string, address string, params *SignEvmMessageParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/accounts/%s/sign/message", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XWalletAuth != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Wallet-Auth", runtime.ParamLocationHeader, *params.XWalletAuth)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Wallet-Auth", headerParam0)
		}

		if params.XIdempotencyKey != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam1)
		}

	}

	return req, nil
}

// NewSignEvmTransactionRequest calls the generic SignEvmTransaction builder with application/json body
func NewSignEvmTransactionRequest(server string, address string, params *SignEvmTransactionParams, body SignEvmTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSignEvmTransactionRequestWithBody(server, address, params, "application/json", bodyReader)
}

// NewSignEvmTransactionRequestWithBody generates requests for SignEvmTransaction with any type of body
func NewSignEvmTransactionRequestWithBody(server string, address string, params *SignEvmTransactionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/accounts/%s/sign/transaction", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XWalletAuth != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Wallet-Auth", runtime.ParamLocationHeader, *params.XWalletAuth)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Wallet-Auth", headerParam0)
		}

		if params.XIdempotencyKey != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam1)
		}

	}

	return req, nil
}

// NewSignEvmTypedDataRequest calls the generic SignEvmTypedData builder with application/json body
func NewSignEvmTypedDataRequest(server string, address string, params *SignEvmTypedDataParams, body SignEvmTypedDataJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSignEvmTypedDataRequestWithBody(server, address, params, "application/json", bodyReader)
}

// NewSignEvmTypedDataRequestWithBody generates requests for SignEvmTypedData with any type of body
func NewSignEvmTypedDataRequestWithBody(server string, address string, params *SignEvmTypedDataParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/accounts/%s/sign/typed-data", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XWalletAuth != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Wallet-Auth", runtime.ParamLocationHeader, *params.XWalletAuth)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Wallet-Auth", headerParam0)
		}

		if params.XIdempotencyKey != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam1)
		}

	}

	return req, nil
}

// NewRequestEvmFaucetRequest calls the generic RequestEvmFaucet builder with application/json body
func NewRequestEvmFaucetRequest(server string, body RequestEvmFaucetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRequestEvmFaucetRequestWithBody(server, "application/json", bodyReader)
}

// NewRequestEvmFaucetRequestWithBody generates requests for RequestEvmFaucet with any type of body
func NewRequestEvmFaucetRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/faucet")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListEvmSmartAccountsRequest generates requests for ListEvmSmartAccounts
func NewListEvmSmartAccountsRequest(server string, params *ListEvmSmartAccountsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/smart-accounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateEvmSmartAccountRequest calls the generic CreateEvmSmartAccount builder with application/json body
func NewCreateEvmSmartAccountRequest(server string, params *CreateEvmSmartAccountParams, body CreateEvmSmartAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateEvmSmartAccountRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateEvmSmartAccountRequestWithBody generates requests for CreateEvmSmartAccount with any type of body
func NewCreateEvmSmartAccountRequestWithBody(server string, params *CreateEvmSmartAccountParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/smart-accounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XIdempotencyKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam0)
		}

	}

	return req, nil
}

// NewGetEvmSmartAccountByNameRequest generates requests for GetEvmSmartAccountByName
func NewGetEvmSmartAccountByNameRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/smart-accounts/by-name/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEvmSmartAccountRequest generates requests for GetEvmSmartAccount
func NewGetEvmSmartAccountRequest(server string, address string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/smart-accounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateEvmSmartAccountRequest calls the generic UpdateEvmSmartAccount builder with application/json body
func NewUpdateEvmSmartAccountRequest(server string, address string, body UpdateEvmSmartAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateEvmSmartAccountRequestWithBody(server, address, "application/json", bodyReader)
}

// NewUpdateEvmSmartAccountRequestWithBody generates requests for UpdateEvmSmartAccount with any type of body
func NewUpdateEvmSmartAccountRequestWithBody(server string, address string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/smart-accounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateSpendPermissionRequest calls the generic CreateSpendPermission builder with application/json body
func NewCreateSpendPermissionRequest(server string, address string, params *CreateSpendPermissionParams, body CreateSpendPermissionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSpendPermissionRequestWithBody(server, address, params, "application/json", bodyReader)
}

// NewCreateSpendPermissionRequestWithBody generates requests for CreateSpendPermission with any type of body
func NewCreateSpendPermissionRequestWithBody(server string, address string, params *CreateSpendPermissionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/smart-accounts/%s/spend-permissions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XWalletAuth != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Wallet-Auth", runtime.ParamLocationHeader, *params.XWalletAuth)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Wallet-Auth", headerParam0)
		}

		if params.XIdempotencyKey != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam1)
		}

	}

	return req, nil
}

// NewListSpendPermissionsRequest generates requests for ListSpendPermissions
func NewListSpendPermissionsRequest(server string, address string, params *ListSpendPermissionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/smart-accounts/%s/spend-permissions/list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRevokeSpendPermissionRequest calls the generic RevokeSpendPermission builder with application/json body
func NewRevokeSpendPermissionRequest(server string, address string, params *RevokeSpendPermissionParams, body RevokeSpendPermissionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRevokeSpendPermissionRequestWithBody(server, address, params, "application/json", bodyReader)
}

// NewRevokeSpendPermissionRequestWithBody generates requests for RevokeSpendPermission with any type of body
func NewRevokeSpendPermissionRequestWithBody(server string, address string, params *RevokeSpendPermissionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/smart-accounts/%s/spend-permissions/revoke", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XWalletAuth != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Wallet-Auth", runtime.ParamLocationHeader, *params.XWalletAuth)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Wallet-Auth", headerParam0)
		}

		if params.XIdempotencyKey != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam1)
		}

	}

	return req, nil
}

// NewPrepareUserOperationRequest calls the generic PrepareUserOperation builder with application/json body
func NewPrepareUserOperationRequest(server string, address string, body PrepareUserOperationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPrepareUserOperationRequestWithBody(server, address, "application/json", bodyReader)
}

// NewPrepareUserOperationRequestWithBody generates requests for PrepareUserOperation with any type of body
func NewPrepareUserOperationRequestWithBody(server string, address string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/smart-accounts/%s/user-operations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUserOperationRequest generates requests for GetUserOperation
func NewGetUserOperationRequest(server string, address string, userOpHash string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userOpHash", runtime.ParamLocationPath, userOpHash)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/smart-accounts/%s/user-operations/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSendUserOperationRequest calls the generic SendUserOperation builder with application/json body
func NewSendUserOperationRequest(server string, address string, userOpHash string, body SendUserOperationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSendUserOperationRequestWithBody(server, address, userOpHash, "application/json", bodyReader)
}

// NewSendUserOperationRequestWithBody generates requests for SendUserOperation with any type of body
func NewSendUserOperationRequestWithBody(server string, address string, userOpHash string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userOpHash", runtime.ParamLocationPath, userOpHash)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/smart-accounts/%s/user-operations/%s/send", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateEvmSwapQuoteRequest calls the generic CreateEvmSwapQuote builder with application/json body
func NewCreateEvmSwapQuoteRequest(server string, params *CreateEvmSwapQuoteParams, body CreateEvmSwapQuoteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateEvmSwapQuoteRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateEvmSwapQuoteRequestWithBody generates requests for CreateEvmSwapQuote with any type of body
func NewCreateEvmSwapQuoteRequestWithBody(server string, params *CreateEvmSwapQuoteParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/swaps")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XIdempotencyKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam0)
		}

	}

	return req, nil
}

// NewGetEvmSwapPriceRequest generates requests for GetEvmSwapPrice
func NewGetEvmSwapPriceRequest(server string, params *GetEvmSwapPriceParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/swaps/quote")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "network", runtime.ParamLocationQuery, params.Network); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "toToken", runtime.ParamLocationQuery, params.ToToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fromToken", runtime.ParamLocationQuery, params.FromToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fromAmount", runtime.ParamLocationQuery, params.FromAmount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "taker", runtime.ParamLocationQuery, params.Taker); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.SignerAddress != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "signerAddress", runtime.ParamLocationQuery, *params.SignerAddress); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GasPrice != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gasPrice", runtime.ParamLocationQuery, *params.GasPrice); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SlippageBps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "slippageBps", runtime.ParamLocationQuery, *params.SlippageBps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListEvmTokenBalancesRequest generates requests for ListEvmTokenBalances
func NewListEvmTokenBalancesRequest(server string, network ListEvmTokenBalancesNetwork, address string, params *ListEvmTokenBalancesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "network", runtime.ParamLocationPath, network)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/token-balances/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateOnrampOrderRequest calls the generic CreateOnrampOrder builder with application/json body
func NewCreateOnrampOrderRequest(server string, body CreateOnrampOrderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOnrampOrderRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateOnrampOrderRequestWithBody generates requests for CreateOnrampOrder with any type of body
func NewCreateOnrampOrderRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/onramp/orders")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetOnrampOrderByIdRequest generates requests for GetOnrampOrderById
func NewGetOnrampOrderByIdRequest(server string, orderId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orderId", runtime.ParamLocationPath, orderId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/onramp/orders/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCryptoRailsRequest generates requests for GetCryptoRails
func NewGetCryptoRailsRequest(server string, params *GetCryptoRailsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/payments/rails/crypto")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Networks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "networks", runtime.ParamLocationQuery, *params.Networks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPaymentMethodsRequest generates requests for GetPaymentMethods
func NewGetPaymentMethodsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/payments/rails/payment-methods")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePaymentTransferQuoteRequest calls the generic CreatePaymentTransferQuote builder with application/json body
func NewCreatePaymentTransferQuoteRequest(server string, body CreatePaymentTransferQuoteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePaymentTransferQuoteRequestWithBody(server, "application/json", bodyReader)
}

// NewCreatePaymentTransferQuoteRequestWithBody generates requests for CreatePaymentTransferQuote with any type of body
func NewCreatePaymentTransferQuoteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/payments/transfers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPaymentTransferRequest generates requests for GetPaymentTransfer
func NewGetPaymentTransferRequest(server string, transferId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "transferId", runtime.ParamLocationPath, transferId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/payments/transfers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExecutePaymentTransferQuoteRequest generates requests for ExecutePaymentTransferQuote
func NewExecutePaymentTransferQuoteRequest(server string, transferId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "transferId", runtime.ParamLocationPath, transferId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/payments/transfers/%s/execute", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPoliciesRequest generates requests for ListPolicies
func NewListPoliciesRequest(server string, params *ListPoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/policy-engine/policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Scope != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scope", runtime.ParamLocationQuery, *params.Scope); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePolicyRequest calls the generic CreatePolicy builder with application/json body
func NewCreatePolicyRequest(server string, params *CreatePolicyParams, body CreatePolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePolicyRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreatePolicyRequestWithBody generates requests for CreatePolicy with any type of body
func NewCreatePolicyRequestWithBody(server string, params *CreatePolicyParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/policy-engine/policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XIdempotencyKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam0)
		}

	}

	return req, nil
}

// NewDeletePolicyRequest generates requests for DeletePolicy
func NewDeletePolicyRequest(server string, policyId string, params *DeletePolicyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "policyId", runtime.ParamLocationPath, policyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/policy-engine/policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XIdempotencyKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam0)
		}

	}

	return req, nil
}

// NewGetPolicyByIdRequest generates requests for GetPolicyById
func NewGetPolicyByIdRequest(server string, policyId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "policyId", runtime.ParamLocationPath, policyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/policy-engine/policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePolicyRequest calls the generic UpdatePolicy builder with application/json body
func NewUpdatePolicyRequest(server string, policyId string, params *UpdatePolicyParams, body UpdatePolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePolicyRequestWithBody(server, policyId, params, "application/json", bodyReader)
}

// NewUpdatePolicyRequestWithBody generates requests for UpdatePolicy with any type of body
func NewUpdatePolicyRequestWithBody(server string, policyId string, params *UpdatePolicyParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "policyId", runtime.ParamLocationPath, policyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/policy-engine/policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XIdempotencyKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam0)
		}

	}

	return req, nil
}

// NewListSolanaAccountsRequest generates requests for ListSolanaAccounts
func NewListSolanaAccountsRequest(server string, params *ListSolanaAccountsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/solana/accounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSolanaAccountRequest calls the generic CreateSolanaAccount builder with application/json body
func NewCreateSolanaAccountRequest(server string, params *CreateSolanaAccountParams, body CreateSolanaAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSolanaAccountRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateSolanaAccountRequestWithBody generates requests for CreateSolanaAccount with any type of body
func NewCreateSolanaAccountRequestWithBody(server string, params *CreateSolanaAccountParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/solana/accounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XWalletAuth != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Wallet-Auth", runtime.ParamLocationHeader, *params.XWalletAuth)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Wallet-Auth", headerParam0)
		}

		if params.XIdempotencyKey != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam1)
		}

	}

	return req, nil
}

// NewGetSolanaAccountByNameRequest generates requests for GetSolanaAccountByName
func NewGetSolanaAccountByNameRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/solana/accounts/by-name/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExportSolanaAccountByNameRequest calls the generic ExportSolanaAccountByName builder with application/json body
func NewExportSolanaAccountByNameRequest(server string, name string, params *ExportSolanaAccountByNameParams, body ExportSolanaAccountByNameJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExportSolanaAccountByNameRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewExportSolanaAccountByNameRequestWithBody generates requests for ExportSolanaAccountByName with any type of body
func NewExportSolanaAccountByNameRequestWithBody(server string, name string, params *ExportSolanaAccountByNameParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/solana/accounts/export/by-name/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XWalletAuth != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Wallet-Auth", runtime.ParamLocationHeader, *params.XWalletAuth)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Wallet-Auth", headerParam0)
		}

		if params.XIdempotencyKey != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam1)
		}

	}

	return req, nil
}

// NewImportSolanaAccountRequest calls the generic ImportSolanaAccount builder with application/json body
func NewImportSolanaAccountRequest(server string, params *ImportSolanaAccountParams, body ImportSolanaAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewImportSolanaAccountRequestWithBody(server, params, "application/json", bodyReader)
}

// NewImportSolanaAccountRequestWithBody generates requests for ImportSolanaAccount with any type of body
func NewImportSolanaAccountRequestWithBody(server string, params *ImportSolanaAccountParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/solana/accounts/import")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XWalletAuth != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Wallet-Auth", runtime.ParamLocationHeader, *params.XWalletAuth)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Wallet-Auth", headerParam0)
		}

		if params.XIdempotencyKey != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam1)
		}

	}

	return req, nil
}

// NewSendSolanaTransactionRequest calls the generic SendSolanaTransaction builder with application/json body
func NewSendSolanaTransactionRequest(server string, params *SendSolanaTransactionParams, body SendSolanaTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSendSolanaTransactionRequestWithBody(server, params, "application/json", bodyReader)
}

// NewSendSolanaTransactionRequestWithBody generates requests for SendSolanaTransaction with any type of body
func NewSendSolanaTransactionRequestWithBody(server string, params *SendSolanaTransactionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/solana/accounts/send/transaction")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XWalletAuth != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Wallet-Auth", runtime.ParamLocationHeader, *params.XWalletAuth)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Wallet-Auth", headerParam0)
		}

		if params.XIdempotencyKey != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam1)
		}

	}

	return req, nil
}

// NewGetSolanaAccountRequest generates requests for GetSolanaAccount
func NewGetSolanaAccountRequest(server string, address string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/solana/accounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateSolanaAccountRequest calls the generic UpdateSolanaAccount builder with application/json body
func NewUpdateSolanaAccountRequest(server string, address string, params *UpdateSolanaAccountParams, body UpdateSolanaAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSolanaAccountRequestWithBody(server, address, params, "application/json", bodyReader)
}

// NewUpdateSolanaAccountRequestWithBody generates requests for UpdateSolanaAccount with any type of body
func NewUpdateSolanaAccountRequestWithBody(server string, address string, params *UpdateSolanaAccountParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/solana/accounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XIdempotencyKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam0)
		}

	}

	return req, nil
}

// NewExportSolanaAccountRequest calls the generic ExportSolanaAccount builder with application/json body
func NewExportSolanaAccountRequest(server string, address string, params *ExportSolanaAccountParams, body ExportSolanaAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExportSolanaAccountRequestWithBody(server, address, params, "application/json", bodyReader)
}

// NewExportSolanaAccountRequestWithBody generates requests for ExportSolanaAccount with any type of body
func NewExportSolanaAccountRequestWithBody(server string, address string, params *ExportSolanaAccountParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/solana/accounts/%s/export", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XWalletAuth != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Wallet-Auth", runtime.ParamLocationHeader, *params.XWalletAuth)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Wallet-Auth", headerParam0)
		}

		if params.XIdempotencyKey != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam1)
		}

	}

	return req, nil
}

// NewSignSolanaMessageRequest calls the generic SignSolanaMessage builder with application/json body
func NewSignSolanaMessageRequest(server string, address string, params *SignSolanaMessageParams, body SignSolanaMessageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSignSolanaMessageRequestWithBody(server, address, params, "application/json", bodyReader)
}

// NewSignSolanaMessageRequestWithBody generates requests for SignSolanaMessage with any type of body
func NewSignSolanaMessageRequestWithBody(server string, address string, params *SignSolanaMessageParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/solana/accounts/%s/sign/message", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XWalletAuth != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Wallet-Auth", runtime.ParamLocationHeader, *params.XWalletAuth)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Wallet-Auth", headerParam0)
		}

		if params.XIdempotencyKey != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam1)
		}

	}

	return req, nil
}

// NewSignSolanaTransactionRequest calls the generic SignSolanaTransaction builder with application/json body
func NewSignSolanaTransactionRequest(server string, address string, params *SignSolanaTransactionParams, body SignSolanaTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSignSolanaTransactionRequestWithBody(server, address, params, "application/json", bodyReader)
}

// NewSignSolanaTransactionRequestWithBody generates requests for SignSolanaTransaction with any type of body
func NewSignSolanaTransactionRequestWithBody(server string, address string, params *SignSolanaTransactionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/solana/accounts/%s/sign/transaction", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XWalletAuth != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Wallet-Auth", runtime.ParamLocationHeader, *params.XWalletAuth)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Wallet-Auth", headerParam0)
		}

		if params.XIdempotencyKey != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam1)
		}

	}

	return req, nil
}

// NewRequestSolanaFaucetRequest calls the generic RequestSolanaFaucet builder with application/json body
func NewRequestSolanaFaucetRequest(server string, body RequestSolanaFaucetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRequestSolanaFaucetRequestWithBody(server, "application/json", bodyReader)
}

// NewRequestSolanaFaucetRequestWithBody generates requests for RequestSolanaFaucet with any type of body
func NewRequestSolanaFaucetRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/solana/faucet")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListSolanaTokenBalancesRequest generates requests for ListSolanaTokenBalances
func NewListSolanaTokenBalancesRequest(server string, network ListSolanaTokenBalancesNetwork, address string, params *ListSolanaTokenBalancesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "network", runtime.ParamLocationPath, network)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/solana/token-balances/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *CDPClient) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *CDPClient) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// RunSQLQueryWithBodyWithResponse request with any body
	RunSQLQueryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunSQLQueryResponse, error)

	RunSQLQueryWithResponse(ctx context.Context, body RunSQLQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*RunSQLQueryResponse, error)

	// ListEvmAccountsWithResponse request
	ListEvmAccountsWithResponse(ctx context.Context, params *ListEvmAccountsParams, reqEditors ...RequestEditorFn) (*ListEvmAccountsResponse, error)

	// CreateEvmAccountWithBodyWithResponse request with any body
	CreateEvmAccountWithBodyWithResponse(ctx context.Context, params *CreateEvmAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEvmAccountResponse, error)

	CreateEvmAccountWithResponse(ctx context.Context, params *CreateEvmAccountParams, body CreateEvmAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEvmAccountResponse, error)

	// GetEvmAccountByNameWithResponse request
	GetEvmAccountByNameWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetEvmAccountByNameResponse, error)

	// ExportEvmAccountByNameWithBodyWithResponse request with any body
	ExportEvmAccountByNameWithBodyWithResponse(ctx context.Context, name string, params *ExportEvmAccountByNameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExportEvmAccountByNameResponse, error)

	ExportEvmAccountByNameWithResponse(ctx context.Context, name string, params *ExportEvmAccountByNameParams, body ExportEvmAccountByNameJSONRequestBody, reqEditors ...RequestEditorFn) (*ExportEvmAccountByNameResponse, error)

	// ImportEvmAccountWithBodyWithResponse request with any body
	ImportEvmAccountWithBodyWithResponse(ctx context.Context, params *ImportEvmAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ImportEvmAccountResponse, error)

	ImportEvmAccountWithResponse(ctx context.Context, params *ImportEvmAccountParams, body ImportEvmAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*ImportEvmAccountResponse, error)

	// GetEvmAccountWithResponse request
	GetEvmAccountWithResponse(ctx context.Context, address string, reqEditors ...RequestEditorFn) (*GetEvmAccountResponse, error)

	// UpdateEvmAccountWithBodyWithResponse request with any body
	UpdateEvmAccountWithBodyWithResponse(ctx context.Context, address string, params *UpdateEvmAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEvmAccountResponse, error)

	UpdateEvmAccountWithResponse(ctx context.Context, address string, params *UpdateEvmAccountParams, body UpdateEvmAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEvmAccountResponse, error)

	// ExportEvmAccountWithBodyWithResponse request with any body
	ExportEvmAccountWithBodyWithResponse(ctx context.Context, address string, params *ExportEvmAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExportEvmAccountResponse, error)

	ExportEvmAccountWithResponse(ctx context.Context, address string, params *ExportEvmAccountParams, body ExportEvmAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*ExportEvmAccountResponse, error)

	// SendEvmTransactionWithBodyWithResponse request with any body
	SendEvmTransactionWithBodyWithResponse(ctx context.Context, address string, params *SendEvmTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendEvmTransactionResponse, error)

	SendEvmTransactionWithResponse(ctx context.Context, address string, params *SendEvmTransactionParams, body SendEvmTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*SendEvmTransactionResponse, error)

	// SignEvmHashWithBodyWithResponse request with any body
	SignEvmHashWithBodyWithResponse(ctx context.Context, address string, params *SignEvmHashParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SignEvmHashResponse, error)

	SignEvmHashWithResponse(ctx context.Context, address string, params *SignEvmHashParams, body SignEvmHashJSONRequestBody, reqEditors ...RequestEditorFn) (*SignEvmHashResponse, error)

	// SignEvmMessageWithBodyWithResponse request with any body
	SignEvmMessageWithBodyWithResponse(ctx context.Context, address string, params *SignEvmMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SignEvmMessageResponse, error)

	SignEvmMessageWithResponse(ctx context.Context, address string, params *SignEvmMessageParams, body SignEvmMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*SignEvmMessageResponse, error)

	// SignEvmTransactionWithBodyWithResponse request with any body
	SignEvmTransactionWithBodyWithResponse(ctx context.Context, address string, params *SignEvmTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SignEvmTransactionResponse, error)

	SignEvmTransactionWithResponse(ctx context.Context, address string, params *SignEvmTransactionParams, body SignEvmTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*SignEvmTransactionResponse, error)

	// SignEvmTypedDataWithBodyWithResponse request with any body
	SignEvmTypedDataWithBodyWithResponse(ctx context.Context, address string, params *SignEvmTypedDataParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SignEvmTypedDataResponse, error)

	SignEvmTypedDataWithResponse(ctx context.Context, address string, params *SignEvmTypedDataParams, body SignEvmTypedDataJSONRequestBody, reqEditors ...RequestEditorFn) (*SignEvmTypedDataResponse, error)

	// RequestEvmFaucetWithBodyWithResponse request with any body
	RequestEvmFaucetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RequestEvmFaucetResponse, error)

	RequestEvmFaucetWithResponse(ctx context.Context, body RequestEvmFaucetJSONRequestBody, reqEditors ...RequestEditorFn) (*RequestEvmFaucetResponse, error)

	// ListEvmSmartAccountsWithResponse request
	ListEvmSmartAccountsWithResponse(ctx context.Context, params *ListEvmSmartAccountsParams, reqEditors ...RequestEditorFn) (*ListEvmSmartAccountsResponse, error)

	// CreateEvmSmartAccountWithBodyWithResponse request with any body
	CreateEvmSmartAccountWithBodyWithResponse(ctx context.Context, params *CreateEvmSmartAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEvmSmartAccountResponse, error)

	CreateEvmSmartAccountWithResponse(ctx context.Context, params *CreateEvmSmartAccountParams, body CreateEvmSmartAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEvmSmartAccountResponse, error)

	// GetEvmSmartAccountByNameWithResponse request
	GetEvmSmartAccountByNameWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetEvmSmartAccountByNameResponse, error)

	// GetEvmSmartAccountWithResponse request
	GetEvmSmartAccountWithResponse(ctx context.Context, address string, reqEditors ...RequestEditorFn) (*GetEvmSmartAccountResponse, error)

	// UpdateEvmSmartAccountWithBodyWithResponse request with any body
	UpdateEvmSmartAccountWithBodyWithResponse(ctx context.Context, address string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEvmSmartAccountResponse, error)

	UpdateEvmSmartAccountWithResponse(ctx context.Context, address string, body UpdateEvmSmartAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEvmSmartAccountResponse, error)

	// CreateSpendPermissionWithBodyWithResponse request with any body
	CreateSpendPermissionWithBodyWithResponse(ctx context.Context, address string, params *CreateSpendPermissionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSpendPermissionResponse, error)

	CreateSpendPermissionWithResponse(ctx context.Context, address string, params *CreateSpendPermissionParams, body CreateSpendPermissionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSpendPermissionResponse, error)

	// ListSpendPermissionsWithResponse request
	ListSpendPermissionsWithResponse(ctx context.Context, address string, params *ListSpendPermissionsParams, reqEditors ...RequestEditorFn) (*ListSpendPermissionsResponse, error)

	// RevokeSpendPermissionWithBodyWithResponse request with any body
	RevokeSpendPermissionWithBodyWithResponse(ctx context.Context, address string, params *RevokeSpendPermissionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevokeSpendPermissionResponse, error)

	RevokeSpendPermissionWithResponse(ctx context.Context, address string, params *RevokeSpendPermissionParams, body RevokeSpendPermissionJSONRequestBody, reqEditors ...RequestEditorFn) (*RevokeSpendPermissionResponse, error)

	// PrepareUserOperationWithBodyWithResponse request with any body
	PrepareUserOperationWithBodyWithResponse(ctx context.Context, address string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PrepareUserOperationResponse, error)

	PrepareUserOperationWithResponse(ctx context.Context, address string, body PrepareUserOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*PrepareUserOperationResponse, error)

	// GetUserOperationWithResponse request
	GetUserOperationWithResponse(ctx context.Context, address string, userOpHash string, reqEditors ...RequestEditorFn) (*GetUserOperationResponse, error)

	// SendUserOperationWithBodyWithResponse request with any body
	SendUserOperationWithBodyWithResponse(ctx context.Context, address string, userOpHash string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendUserOperationResponse, error)

	SendUserOperationWithResponse(ctx context.Context, address string, userOpHash string, body SendUserOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*SendUserOperationResponse, error)

	// CreateEvmSwapQuoteWithBodyWithResponse request with any body
	CreateEvmSwapQuoteWithBodyWithResponse(ctx context.Context, params *CreateEvmSwapQuoteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEvmSwapQuoteResponse, error)

	CreateEvmSwapQuoteWithResponse(ctx context.Context, params *CreateEvmSwapQuoteParams, body CreateEvmSwapQuoteJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEvmSwapQuoteResponse, error)

	// GetEvmSwapPriceWithResponse request
	GetEvmSwapPriceWithResponse(ctx context.Context, params *GetEvmSwapPriceParams, reqEditors ...RequestEditorFn) (*GetEvmSwapPriceResponse, error)

	// ListEvmTokenBalancesWithResponse request
	ListEvmTokenBalancesWithResponse(ctx context.Context, network ListEvmTokenBalancesNetwork, address string, params *ListEvmTokenBalancesParams, reqEditors ...RequestEditorFn) (*ListEvmTokenBalancesResponse, error)

	// CreateOnrampOrderWithBodyWithResponse request with any body
	CreateOnrampOrderWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOnrampOrderResponse, error)

	CreateOnrampOrderWithResponse(ctx context.Context, body CreateOnrampOrderJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOnrampOrderResponse, error)

	// GetOnrampOrderByIdWithResponse request
	GetOnrampOrderByIdWithResponse(ctx context.Context, orderId string, reqEditors ...RequestEditorFn) (*GetOnrampOrderByIdResponse, error)

	// GetCryptoRailsWithResponse request
	GetCryptoRailsWithResponse(ctx context.Context, params *GetCryptoRailsParams, reqEditors ...RequestEditorFn) (*GetCryptoRailsResponse, error)

	// GetPaymentMethodsWithResponse request
	GetPaymentMethodsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPaymentMethodsResponse, error)

	// CreatePaymentTransferQuoteWithBodyWithResponse request with any body
	CreatePaymentTransferQuoteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePaymentTransferQuoteResponse, error)

	CreatePaymentTransferQuoteWithResponse(ctx context.Context, body CreatePaymentTransferQuoteJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePaymentTransferQuoteResponse, error)

	// GetPaymentTransferWithResponse request
	GetPaymentTransferWithResponse(ctx context.Context, transferId string, reqEditors ...RequestEditorFn) (*GetPaymentTransferResponse, error)

	// ExecutePaymentTransferQuoteWithResponse request
	ExecutePaymentTransferQuoteWithResponse(ctx context.Context, transferId string, reqEditors ...RequestEditorFn) (*ExecutePaymentTransferQuoteResponse, error)

	// ListPoliciesWithResponse request
	ListPoliciesWithResponse(ctx context.Context, params *ListPoliciesParams, reqEditors ...RequestEditorFn) (*ListPoliciesResponse, error)

	// CreatePolicyWithBodyWithResponse request with any body
	CreatePolicyWithBodyWithResponse(ctx context.Context, params *CreatePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePolicyResponse, error)

	CreatePolicyWithResponse(ctx context.Context, params *CreatePolicyParams, body CreatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePolicyResponse, error)

	// DeletePolicyWithResponse request
	DeletePolicyWithResponse(ctx context.Context, policyId string, params *DeletePolicyParams, reqEditors ...RequestEditorFn) (*DeletePolicyResponse, error)

	// GetPolicyByIdWithResponse request
	GetPolicyByIdWithResponse(ctx context.Context, policyId string, reqEditors ...RequestEditorFn) (*GetPolicyByIdResponse, error)

	// UpdatePolicyWithBodyWithResponse request with any body
	UpdatePolicyWithBodyWithResponse(ctx context.Context, policyId string, params *UpdatePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePolicyResponse, error)

	UpdatePolicyWithResponse(ctx context.Context, policyId string, params *UpdatePolicyParams, body UpdatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePolicyResponse, error)

	// ListSolanaAccountsWithResponse request
	ListSolanaAccountsWithResponse(ctx context.Context, params *ListSolanaAccountsParams, reqEditors ...RequestEditorFn) (*ListSolanaAccountsResponse, error)

	// CreateSolanaAccountWithBodyWithResponse request with any body
	CreateSolanaAccountWithBodyWithResponse(ctx context.Context, params *CreateSolanaAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSolanaAccountResponse, error)

	CreateSolanaAccountWithResponse(ctx context.Context, params *CreateSolanaAccountParams, body CreateSolanaAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSolanaAccountResponse, error)

	// GetSolanaAccountByNameWithResponse request
	GetSolanaAccountByNameWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetSolanaAccountByNameResponse, error)

	// ExportSolanaAccountByNameWithBodyWithResponse request with any body
	ExportSolanaAccountByNameWithBodyWithResponse(ctx context.Context, name string, params *ExportSolanaAccountByNameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExportSolanaAccountByNameResponse, error)

	ExportSolanaAccountByNameWithResponse(ctx context.Context, name string, params *ExportSolanaAccountByNameParams, body ExportSolanaAccountByNameJSONRequestBody, reqEditors ...RequestEditorFn) (*ExportSolanaAccountByNameResponse, error)

	// ImportSolanaAccountWithBodyWithResponse request with any body
	ImportSolanaAccountWithBodyWithResponse(ctx context.Context, params *ImportSolanaAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ImportSolanaAccountResponse, error)

	ImportSolanaAccountWithResponse(ctx context.Context, params *ImportSolanaAccountParams, body ImportSolanaAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*ImportSolanaAccountResponse, error)

	// SendSolanaTransactionWithBodyWithResponse request with any body
	SendSolanaTransactionWithBodyWithResponse(ctx context.Context, params *SendSolanaTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendSolanaTransactionResponse, error)

	SendSolanaTransactionWithResponse(ctx context.Context, params *SendSolanaTransactionParams, body SendSolanaTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*SendSolanaTransactionResponse, error)

	// GetSolanaAccountWithResponse request
	GetSolanaAccountWithResponse(ctx context.Context, address string, reqEditors ...RequestEditorFn) (*GetSolanaAccountResponse, error)

	// UpdateSolanaAccountWithBodyWithResponse request with any body
	UpdateSolanaAccountWithBodyWithResponse(ctx context.Context, address string, params *UpdateSolanaAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSolanaAccountResponse, error)

	UpdateSolanaAccountWithResponse(ctx context.Context, address string, params *UpdateSolanaAccountParams, body UpdateSolanaAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSolanaAccountResponse, error)

	// ExportSolanaAccountWithBodyWithResponse request with any body
	ExportSolanaAccountWithBodyWithResponse(ctx context.Context, address string, params *ExportSolanaAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExportSolanaAccountResponse, error)

	ExportSolanaAccountWithResponse(ctx context.Context, address string, params *ExportSolanaAccountParams, body ExportSolanaAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*ExportSolanaAccountResponse, error)

	// SignSolanaMessageWithBodyWithResponse request with any body
	SignSolanaMessageWithBodyWithResponse(ctx context.Context, address string, params *SignSolanaMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SignSolanaMessageResponse, error)

	SignSolanaMessageWithResponse(ctx context.Context, address string, params *SignSolanaMessageParams, body SignSolanaMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*SignSolanaMessageResponse, error)

	// SignSolanaTransactionWithBodyWithResponse request with any body
	SignSolanaTransactionWithBodyWithResponse(ctx context.Context, address string, params *SignSolanaTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SignSolanaTransactionResponse, error)

	SignSolanaTransactionWithResponse(ctx context.Context, address string, params *SignSolanaTransactionParams, body SignSolanaTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*SignSolanaTransactionResponse, error)

	// RequestSolanaFaucetWithBodyWithResponse request with any body
	RequestSolanaFaucetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RequestSolanaFaucetResponse, error)

	RequestSolanaFaucetWithResponse(ctx context.Context, body RequestSolanaFaucetJSONRequestBody, reqEditors ...RequestEditorFn) (*RequestSolanaFaucetResponse, error)

	// ListSolanaTokenBalancesWithResponse request
	ListSolanaTokenBalancesWithResponse(ctx context.Context, network ListSolanaTokenBalancesNetwork, address string, params *ListSolanaTokenBalancesParams, reqEditors ...RequestEditorFn) (*ListSolanaTokenBalancesResponse, error)
}

type RunSQLQueryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OnchainDataResult
	JSON400      *InvalidSQLQueryError
	JSON401      *UnauthorizedError
	JSON408      *Error
	JSON429      *Error
	JSON500      *InternalServerError
	JSON504      *TimedOutError
}

// Status returns HTTPResponse.Status
func (r RunSQLQueryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RunSQLQueryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListEvmAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Accounts The list of EVM accounts.
		Accounts []EvmAccount `json:"accounts"`

		// NextPageToken The token for the next page of items, if any.
		NextPageToken *string `json:"nextPageToken,omitempty"`
	}
	JSON500 *InternalServerError
	JSON502 *BadGatewayError
	JSON503 *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r ListEvmAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEvmAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateEvmAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *EvmAccount
	JSON400      *Error
	JSON401      *Error
	JSON402      *PaymentMethodRequiredError
	JSON409      *Error
	JSON422      *IdempotencyError
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r CreateEvmAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateEvmAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEvmAccountByNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EvmAccount
	JSON400      *Error
	JSON404      *Error
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r GetEvmAccountByNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEvmAccountByNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExportEvmAccountByNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// EncryptedPrivateKey The base64-encoded, encrypted private key of the EVM account which is a 32 byte raw private key. The private key is encrypted in transport using the exportEncryptionKey in the request.
		EncryptedPrivateKey string `json:"encryptedPrivateKey"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON402 *PaymentMethodRequiredError
	JSON404 *Error
	JSON422 *IdempotencyError
	JSON500 *InternalServerError
	JSON502 *BadGatewayError
	JSON503 *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r ExportEvmAccountByNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExportEvmAccountByNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ImportEvmAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *EvmAccount
	JSON400      *Error
	JSON401      *Error
	JSON402      *PaymentMethodRequiredError
	JSON409      *Error
	JSON422      *IdempotencyError
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r ImportEvmAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ImportEvmAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEvmAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EvmAccount
	JSON400      *Error
	JSON404      *Error
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r GetEvmAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEvmAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateEvmAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EvmAccount
	JSON400      *Error
	JSON404      *Error
	JSON409      *AlreadyExistsError
	JSON422      *IdempotencyError
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r UpdateEvmAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateEvmAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExportEvmAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// EncryptedPrivateKey The base64-encoded, encrypted private key of the EVM account which is a 32 byte raw private key. The private key is encrypted in transport using the exportEncryptionKey in the request.
		EncryptedPrivateKey string `json:"encryptedPrivateKey"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON402 *PaymentMethodRequiredError
	JSON404 *Error
	JSON422 *IdempotencyError
	JSON500 *InternalServerError
	JSON502 *BadGatewayError
	JSON503 *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r ExportEvmAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExportEvmAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendEvmTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// TransactionHash The hash of the transaction, as a 0x-prefixed hex string.
		TransactionHash string `json:"transactionHash"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON402 *PaymentMethodRequiredError
	JSON403 *Error
	JSON404 *Error
	JSON409 *AlreadyExistsError
	JSON422 *IdempotencyError
	JSON500 *InternalServerError
	JSON502 *BadGatewayError
	JSON503 *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r SendEvmTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendEvmTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SignEvmHashResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Signature The signature of the hash, as a 0x-prefixed hex string.
		Signature string `json:"signature"`
	}
	JSON400 *Error
	JSON402 *PaymentMethodRequiredError
	JSON404 *Error
	JSON409 *AlreadyExistsError
	JSON422 *IdempotencyError
	JSON500 *InternalServerError
	JSON502 *BadGatewayError
	JSON503 *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r SignEvmHashResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SignEvmHashResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SignEvmMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Signature The signature of the message, as a 0x-prefixed hex string.
		Signature string `json:"signature"`
	}
	JSON401 *Error
	JSON402 *PaymentMethodRequiredError
	JSON404 *Error
	JSON409 *AlreadyExistsError
	JSON422 *IdempotencyError
	JSON500 *InternalServerError
	JSON502 *BadGatewayError
	JSON503 *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r SignEvmMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SignEvmMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SignEvmTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// SignedTransaction The RLP-encoded signed transaction, as a 0x-prefixed hex string.
		SignedTransaction string `json:"signedTransaction"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON402 *PaymentMethodRequiredError
	JSON403 *Error
	JSON404 *Error
	JSON409 *AlreadyExistsError
	JSON422 *IdempotencyError
	JSON500 *InternalServerError
	JSON502 *BadGatewayError
	JSON503 *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r SignEvmTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SignEvmTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SignEvmTypedDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Signature The signature of the typed data, as a 0x-prefixed hex string.
		Signature string `json:"signature"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON402 *PaymentMethodRequiredError
	JSON404 *Error
	JSON422 *IdempotencyError
	JSON500 *InternalServerError
	JSON502 *BadGatewayError
	JSON503 *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r SignEvmTypedDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SignEvmTypedDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RequestEvmFaucetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// TransactionHash The hash of the transaction that requested the funds.
		// **Note:** In rare cases, when gas conditions are unusually high, the transaction may not confirm, and the system may issue a replacement transaction to complete the faucet request. In these rare cases, the `transactionHash` will be out of sync with the actual faucet transaction that was confirmed onchain.
		TransactionHash string `json:"transactionHash"`
	}
	JSON400 *Error
	JSON403 *Error
	JSON429 *Error
	JSON500 *InternalServerError
	JSON502 *BadGatewayError
	JSON503 *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r RequestEvmFaucetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RequestEvmFaucetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListEvmSmartAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Accounts The list of Smart Accounts.
		Accounts []EvmSmartAccount `json:"accounts"`

		// NextPageToken The token for the next page of items, if any.
		NextPageToken *string `json:"nextPageToken,omitempty"`
	}
	JSON400 *Error
	JSON500 *InternalServerError
	JSON502 *BadGatewayError
	JSON503 *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r ListEvmSmartAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEvmSmartAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateEvmSmartAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *EvmSmartAccount
	JSON400      *Error
	JSON402      *PaymentMethodRequiredError
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r CreateEvmSmartAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateEvmSmartAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEvmSmartAccountByNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EvmSmartAccount
	JSON400      *Error
	JSON404      *Error
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r GetEvmSmartAccountByNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEvmSmartAccountByNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEvmSmartAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EvmSmartAccount
	JSON400      *Error
	JSON404      *Error
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r GetEvmSmartAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEvmSmartAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateEvmSmartAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EvmSmartAccount
	JSON400      *Error
	JSON404      *Error
	JSON409      *AlreadyExistsError
	JSON422      *IdempotencyError
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r UpdateEvmSmartAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateEvmSmartAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSpendPermissionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EvmUserOperation
	JSON400      *Error
	JSON404      *Error
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r CreateSpendPermissionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSpendPermissionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSpendPermissionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextPageToken The token for the next page of items, if any.
		NextPageToken *string `json:"nextPageToken,omitempty"`

		// SpendPermissions The spend permissions for the smart account.
		SpendPermissions []SpendPermissionResponseObject `json:"spendPermissions"`
	}
	JSON400 *Error
	JSON404 *Error
	JSON500 *InternalServerError
	JSON502 *BadGatewayError
	JSON503 *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r ListSpendPermissionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSpendPermissionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevokeSpendPermissionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EvmUserOperation
	JSON400      *Error
	JSON404      *Error
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r RevokeSpendPermissionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevokeSpendPermissionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PrepareUserOperationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *EvmUserOperation
	JSON400      *Error
	JSON403      *Error
	JSON404      *Error
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r PrepareUserOperationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PrepareUserOperationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserOperationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EvmUserOperation
	JSON400      *Error
	JSON404      *Error
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r GetUserOperationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserOperationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendUserOperationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EvmUserOperation
	JSON400      *Error
	JSON402      *PaymentMethodRequiredError
	JSON403      *Error
	JSON404      *Error
	JSON429      *Error
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r SendUserOperationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendUserOperationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateEvmSwapQuoteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CreateSwapQuoteResponseWrapper
	JSON400      *Error
	JSON403      *Error
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r CreateEvmSwapQuoteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateEvmSwapQuoteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEvmSwapPriceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetSwapPriceResponseWrapper
	JSON400      *Error
	JSON403      *Error
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r GetEvmSwapPriceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEvmSwapPriceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListEvmTokenBalancesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Balances The list of EVM token balances.
		Balances []TokenBalance `json:"balances"`

		// NextPageToken The token for the next page of items, if any.
		NextPageToken *string `json:"nextPageToken,omitempty"`
	}
	JSON400 *Error
	JSON404 *Error
	JSON500 *InternalServerError
	JSON502 *BadGatewayError
	JSON503 *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r ListEvmTokenBalancesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEvmTokenBalancesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOnrampOrderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Order An Onramp order.
		Order OnrampOrder `json:"order"`

		// PaymentLink A payment link to pay for an order.
		//
		// Please refer to the [Onramp docs](https://docs.cdp.coinbase.com/onramp-&-offramp/onramp-apis/onramp-overview) for details on how to integrate with the different payment link types.
		PaymentLink *OnrampPaymentLink `json:"paymentLink,omitempty"`
	}
	JSON400 *Error
	JSON401 *UnauthorizedError
	JSON429 *RateLimitExceeded
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateOnrampOrderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOnrampOrderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOnrampOrderByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Order An Onramp order.
		Order OnrampOrder `json:"order"`
	}
	JSON401 *UnauthorizedError
	JSON404 *Error
	JSON429 *RateLimitExceeded
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetOnrampOrderByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOnrampOrderByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCryptoRailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]CryptoRail
	JSON401      *Error
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r GetCryptoRailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCryptoRailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPaymentMethodsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PaymentMethod
	JSON401      *Error
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r GetPaymentMethodsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPaymentMethodsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePaymentTransferQuoteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Transfer The transfer object.
		Transfer Transfer `json:"transfer"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON429 *Error
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreatePaymentTransferQuoteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePaymentTransferQuoteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPaymentTransferResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Transfer
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r GetPaymentTransferResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPaymentTransferResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExecutePaymentTransferQuoteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Transfer
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSON429      *Error
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r ExecutePaymentTransferQuoteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExecutePaymentTransferQuoteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextPageToken The token for the next page of items, if any.
		NextPageToken *string `json:"nextPageToken,omitempty"`

		// Policies The list of policies.
		Policies []Policy `json:"policies"`
	}
	JSON500 *InternalServerError
	JSON502 *BadGatewayError
	JSON503 *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r ListPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Policy
	JSON400      *Error
	JSON409      *AlreadyExistsError
	JSON422      *IdempotencyError
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r CreatePolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON404      *Error
	JSON409      *AlreadyExistsError
	JSON422      *IdempotencyError
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r DeletePolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPolicyByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Policy
	JSON404      *Error
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r GetPolicyByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPolicyByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Policy
	JSON400      *Error
	JSON404      *Error
	JSON409      *AlreadyExistsError
	JSON422      *IdempotencyError
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r UpdatePolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSolanaAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Accounts The list of Solana accounts.
		Accounts []SolanaAccount `json:"accounts"`

		// NextPageToken The token for the next page of items, if any.
		NextPageToken *string `json:"nextPageToken,omitempty"`
	}
	JSON500 *InternalServerError
	JSON502 *BadGatewayError
	JSON503 *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r ListSolanaAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSolanaAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSolanaAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SolanaAccount
	JSON400      *Error
	JSON401      *Error
	JSON402      *PaymentMethodRequiredError
	JSON409      *Error
	JSON422      *IdempotencyError
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r CreateSolanaAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSolanaAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSolanaAccountByNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SolanaAccount
	JSON400      *Error
	JSON404      *Error
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r GetSolanaAccountByNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSolanaAccountByNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExportSolanaAccountByNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// EncryptedPrivateKey The base64-encoded, encrypted private key of the Solana account which is a 32 byte raw private key. The private key is encrypted in transport using the exportEncryptionKey in the request.
		EncryptedPrivateKey string `json:"encryptedPrivateKey"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON402 *PaymentMethodRequiredError
	JSON404 *Error
	JSON422 *IdempotencyError
	JSON500 *InternalServerError
	JSON502 *BadGatewayError
	JSON503 *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r ExportSolanaAccountByNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExportSolanaAccountByNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ImportSolanaAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SolanaAccount
	JSON400      *Error
	JSON401      *Error
	JSON402      *PaymentMethodRequiredError
	JSON409      *Error
	JSON422      *IdempotencyError
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r ImportSolanaAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ImportSolanaAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendSolanaTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// TransactionSignature The base58 encoded transaction signature.
		TransactionSignature string `json:"transactionSignature"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON402 *PaymentMethodRequiredError
	JSON403 *Error
	JSON404 *Error
	JSON422 *IdempotencyError
	JSON500 *InternalServerError
	JSON502 *BadGatewayError
	JSON503 *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r SendSolanaTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendSolanaTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSolanaAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SolanaAccount
	JSON400      *Error
	JSON404      *Error
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r GetSolanaAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSolanaAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSolanaAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SolanaAccount
	JSON400      *Error
	JSON404      *Error
	JSON409      *AlreadyExistsError
	JSON422      *IdempotencyError
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r UpdateSolanaAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSolanaAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExportSolanaAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// EncryptedPrivateKey The base64-encoded, encrypted private key of the Solana account which is a 32 byte raw private key. The private key is encrypted in transport using the exportEncryptionKey in the request.
		EncryptedPrivateKey string `json:"encryptedPrivateKey"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON402 *PaymentMethodRequiredError
	JSON404 *Error
	JSON422 *IdempotencyError
	JSON500 *InternalServerError
	JSON502 *BadGatewayError
	JSON503 *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r ExportSolanaAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExportSolanaAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SignSolanaMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Signature The signature of the message, as a base58 encoded string.
		Signature string `json:"signature"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON402 *PaymentMethodRequiredError
	JSON404 *Error
	JSON409 *AlreadyExistsError
	JSON422 *IdempotencyError
	JSON500 *InternalServerError
	JSON502 *BadGatewayError
	JSON503 *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r SignSolanaMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SignSolanaMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SignSolanaTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// SignedTransaction The base64 encoded signed transaction.
		SignedTransaction string `json:"signedTransaction"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON402 *PaymentMethodRequiredError
	JSON403 *Error
	JSON404 *Error
	JSON409 *AlreadyExistsError
	JSON422 *IdempotencyError
	JSON500 *InternalServerError
	JSON502 *BadGatewayError
	JSON503 *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r SignSolanaTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SignSolanaTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RequestSolanaFaucetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// TransactionSignature The signature identifying the transaction that requested the funds.
		TransactionSignature string `json:"transactionSignature"`
	}
	JSON400 *Error
	JSON403 *Error
	JSON429 *Error
	JSON500 *InternalServerError
	JSON502 *BadGatewayError
	JSON503 *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r RequestSolanaFaucetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RequestSolanaFaucetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSolanaTokenBalancesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Balances The list of Solana token balances.
		Balances []SolanaTokenBalance `json:"balances"`

		// NextPageToken The token for the next page of items, if any.
		NextPageToken *string `json:"nextPageToken,omitempty"`
	}
	JSON400 *Error
	JSON404 *Error
	JSON500 *InternalServerError
	JSON502 *BadGatewayError
	JSON503 *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r ListSolanaTokenBalancesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSolanaTokenBalancesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// RunSQLQueryWithBodyWithResponse request with arbitrary body returning *RunSQLQueryResponse
func (c *ClientWithResponses) RunSQLQueryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunSQLQueryResponse, error) {
	rsp, err := c.RunSQLQueryWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunSQLQueryResponse(rsp)
}

func (c *ClientWithResponses) RunSQLQueryWithResponse(ctx context.Context, body RunSQLQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*RunSQLQueryResponse, error) {
	rsp, err := c.RunSQLQuery(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunSQLQueryResponse(rsp)
}

// ListEvmAccountsWithResponse request returning *ListEvmAccountsResponse
func (c *ClientWithResponses) ListEvmAccountsWithResponse(ctx context.Context, params *ListEvmAccountsParams, reqEditors ...RequestEditorFn) (*ListEvmAccountsResponse, error) {
	rsp, err := c.ListEvmAccounts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListEvmAccountsResponse(rsp)
}

// CreateEvmAccountWithBodyWithResponse request with arbitrary body returning *CreateEvmAccountResponse
func (c *ClientWithResponses) CreateEvmAccountWithBodyWithResponse(ctx context.Context, params *CreateEvmAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEvmAccountResponse, error) {
	rsp, err := c.CreateEvmAccountWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEvmAccountResponse(rsp)
}

func (c *ClientWithResponses) CreateEvmAccountWithResponse(ctx context.Context, params *CreateEvmAccountParams, body CreateEvmAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEvmAccountResponse, error) {
	rsp, err := c.CreateEvmAccount(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEvmAccountResponse(rsp)
}

// GetEvmAccountByNameWithResponse request returning *GetEvmAccountByNameResponse
func (c *ClientWithResponses) GetEvmAccountByNameWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetEvmAccountByNameResponse, error) {
	rsp, err := c.GetEvmAccountByName(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEvmAccountByNameResponse(rsp)
}

// ExportEvmAccountByNameWithBodyWithResponse request with arbitrary body returning *ExportEvmAccountByNameResponse
func (c *ClientWithResponses) ExportEvmAccountByNameWithBodyWithResponse(ctx context.Context, name string, params *ExportEvmAccountByNameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExportEvmAccountByNameResponse, error) {
	rsp, err := c.ExportEvmAccountByNameWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportEvmAccountByNameResponse(rsp)
}

func (c *ClientWithResponses) ExportEvmAccountByNameWithResponse(ctx context.Context, name string, params *ExportEvmAccountByNameParams, body ExportEvmAccountByNameJSONRequestBody, reqEditors ...RequestEditorFn) (*ExportEvmAccountByNameResponse, error) {
	rsp, err := c.ExportEvmAccountByName(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportEvmAccountByNameResponse(rsp)
}

// ImportEvmAccountWithBodyWithResponse request with arbitrary body returning *ImportEvmAccountResponse
func (c *ClientWithResponses) ImportEvmAccountWithBodyWithResponse(ctx context.Context, params *ImportEvmAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ImportEvmAccountResponse, error) {
	rsp, err := c.ImportEvmAccountWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImportEvmAccountResponse(rsp)
}

func (c *ClientWithResponses) ImportEvmAccountWithResponse(ctx context.Context, params *ImportEvmAccountParams, body ImportEvmAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*ImportEvmAccountResponse, error) {
	rsp, err := c.ImportEvmAccount(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImportEvmAccountResponse(rsp)
}

// GetEvmAccountWithResponse request returning *GetEvmAccountResponse
func (c *ClientWithResponses) GetEvmAccountWithResponse(ctx context.Context, address string, reqEditors ...RequestEditorFn) (*GetEvmAccountResponse, error) {
	rsp, err := c.GetEvmAccount(ctx, address, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEvmAccountResponse(rsp)
}

// UpdateEvmAccountWithBodyWithResponse request with arbitrary body returning *UpdateEvmAccountResponse
func (c *ClientWithResponses) UpdateEvmAccountWithBodyWithResponse(ctx context.Context, address string, params *UpdateEvmAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEvmAccountResponse, error) {
	rsp, err := c.UpdateEvmAccountWithBody(ctx, address, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEvmAccountResponse(rsp)
}

func (c *ClientWithResponses) UpdateEvmAccountWithResponse(ctx context.Context, address string, params *UpdateEvmAccountParams, body UpdateEvmAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEvmAccountResponse, error) {
	rsp, err := c.UpdateEvmAccount(ctx, address, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEvmAccountResponse(rsp)
}

// ExportEvmAccountWithBodyWithResponse request with arbitrary body returning *ExportEvmAccountResponse
func (c *ClientWithResponses) ExportEvmAccountWithBodyWithResponse(ctx context.Context, address string, params *ExportEvmAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExportEvmAccountResponse, error) {
	rsp, err := c.ExportEvmAccountWithBody(ctx, address, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportEvmAccountResponse(rsp)
}

func (c *ClientWithResponses) ExportEvmAccountWithResponse(ctx context.Context, address string, params *ExportEvmAccountParams, body ExportEvmAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*ExportEvmAccountResponse, error) {
	rsp, err := c.ExportEvmAccount(ctx, address, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportEvmAccountResponse(rsp)
}

// SendEvmTransactionWithBodyWithResponse request with arbitrary body returning *SendEvmTransactionResponse
func (c *ClientWithResponses) SendEvmTransactionWithBodyWithResponse(ctx context.Context, address string, params *SendEvmTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendEvmTransactionResponse, error) {
	rsp, err := c.SendEvmTransactionWithBody(ctx, address, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendEvmTransactionResponse(rsp)
}

func (c *ClientWithResponses) SendEvmTransactionWithResponse(ctx context.Context, address string, params *SendEvmTransactionParams, body SendEvmTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*SendEvmTransactionResponse, error) {
	rsp, err := c.SendEvmTransaction(ctx, address, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendEvmTransactionResponse(rsp)
}

// SignEvmHashWithBodyWithResponse request with arbitrary body returning *SignEvmHashResponse
func (c *ClientWithResponses) SignEvmHashWithBodyWithResponse(ctx context.Context, address string, params *SignEvmHashParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SignEvmHashResponse, error) {
	rsp, err := c.SignEvmHashWithBody(ctx, address, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSignEvmHashResponse(rsp)
}

func (c *ClientWithResponses) SignEvmHashWithResponse(ctx context.Context, address string, params *SignEvmHashParams, body SignEvmHashJSONRequestBody, reqEditors ...RequestEditorFn) (*SignEvmHashResponse, error) {
	rsp, err := c.SignEvmHash(ctx, address, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSignEvmHashResponse(rsp)
}

// SignEvmMessageWithBodyWithResponse request with arbitrary body returning *SignEvmMessageResponse
func (c *ClientWithResponses) SignEvmMessageWithBodyWithResponse(ctx context.Context, address string, params *SignEvmMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SignEvmMessageResponse, error) {
	rsp, err := c.SignEvmMessageWithBody(ctx, address, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSignEvmMessageResponse(rsp)
}

func (c *ClientWithResponses) SignEvmMessageWithResponse(ctx context.Context, address string, params *SignEvmMessageParams, body SignEvmMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*SignEvmMessageResponse, error) {
	rsp, err := c.SignEvmMessage(ctx, address, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSignEvmMessageResponse(rsp)
}

// SignEvmTransactionWithBodyWithResponse request with arbitrary body returning *SignEvmTransactionResponse
func (c *ClientWithResponses) SignEvmTransactionWithBodyWithResponse(ctx context.Context, address string, params *SignEvmTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SignEvmTransactionResponse, error) {
	rsp, err := c.SignEvmTransactionWithBody(ctx, address, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSignEvmTransactionResponse(rsp)
}

func (c *ClientWithResponses) SignEvmTransactionWithResponse(ctx context.Context, address string, params *SignEvmTransactionParams, body SignEvmTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*SignEvmTransactionResponse, error) {
	rsp, err := c.SignEvmTransaction(ctx, address, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSignEvmTransactionResponse(rsp)
}

// SignEvmTypedDataWithBodyWithResponse request with arbitrary body returning *SignEvmTypedDataResponse
func (c *ClientWithResponses) SignEvmTypedDataWithBodyWithResponse(ctx context.Context, address string, params *SignEvmTypedDataParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SignEvmTypedDataResponse, error) {
	rsp, err := c.SignEvmTypedDataWithBody(ctx, address, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSignEvmTypedDataResponse(rsp)
}

func (c *ClientWithResponses) SignEvmTypedDataWithResponse(ctx context.Context, address string, params *SignEvmTypedDataParams, body SignEvmTypedDataJSONRequestBody, reqEditors ...RequestEditorFn) (*SignEvmTypedDataResponse, error) {
	rsp, err := c.SignEvmTypedData(ctx, address, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSignEvmTypedDataResponse(rsp)
}

// RequestEvmFaucetWithBodyWithResponse request with arbitrary body returning *RequestEvmFaucetResponse
func (c *ClientWithResponses) RequestEvmFaucetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RequestEvmFaucetResponse, error) {
	rsp, err := c.RequestEvmFaucetWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRequestEvmFaucetResponse(rsp)
}

func (c *ClientWithResponses) RequestEvmFaucetWithResponse(ctx context.Context, body RequestEvmFaucetJSONRequestBody, reqEditors ...RequestEditorFn) (*RequestEvmFaucetResponse, error) {
	rsp, err := c.RequestEvmFaucet(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRequestEvmFaucetResponse(rsp)
}

// ListEvmSmartAccountsWithResponse request returning *ListEvmSmartAccountsResponse
func (c *ClientWithResponses) ListEvmSmartAccountsWithResponse(ctx context.Context, params *ListEvmSmartAccountsParams, reqEditors ...RequestEditorFn) (*ListEvmSmartAccountsResponse, error) {
	rsp, err := c.ListEvmSmartAccounts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListEvmSmartAccountsResponse(rsp)
}

// CreateEvmSmartAccountWithBodyWithResponse request with arbitrary body returning *CreateEvmSmartAccountResponse
func (c *ClientWithResponses) CreateEvmSmartAccountWithBodyWithResponse(ctx context.Context, params *CreateEvmSmartAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEvmSmartAccountResponse, error) {
	rsp, err := c.CreateEvmSmartAccountWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEvmSmartAccountResponse(rsp)
}

func (c *ClientWithResponses) CreateEvmSmartAccountWithResponse(ctx context.Context, params *CreateEvmSmartAccountParams, body CreateEvmSmartAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEvmSmartAccountResponse, error) {
	rsp, err := c.CreateEvmSmartAccount(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEvmSmartAccountResponse(rsp)
}

// GetEvmSmartAccountByNameWithResponse request returning *GetEvmSmartAccountByNameResponse
func (c *ClientWithResponses) GetEvmSmartAccountByNameWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetEvmSmartAccountByNameResponse, error) {
	rsp, err := c.GetEvmSmartAccountByName(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEvmSmartAccountByNameResponse(rsp)
}

// GetEvmSmartAccountWithResponse request returning *GetEvmSmartAccountResponse
func (c *ClientWithResponses) GetEvmSmartAccountWithResponse(ctx context.Context, address string, reqEditors ...RequestEditorFn) (*GetEvmSmartAccountResponse, error) {
	rsp, err := c.GetEvmSmartAccount(ctx, address, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEvmSmartAccountResponse(rsp)
}

// UpdateEvmSmartAccountWithBodyWithResponse request with arbitrary body returning *UpdateEvmSmartAccountResponse
func (c *ClientWithResponses) UpdateEvmSmartAccountWithBodyWithResponse(ctx context.Context, address string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEvmSmartAccountResponse, error) {
	rsp, err := c.UpdateEvmSmartAccountWithBody(ctx, address, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEvmSmartAccountResponse(rsp)
}

func (c *ClientWithResponses) UpdateEvmSmartAccountWithResponse(ctx context.Context, address string, body UpdateEvmSmartAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEvmSmartAccountResponse, error) {
	rsp, err := c.UpdateEvmSmartAccount(ctx, address, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEvmSmartAccountResponse(rsp)
}

// CreateSpendPermissionWithBodyWithResponse request with arbitrary body returning *CreateSpendPermissionResponse
func (c *ClientWithResponses) CreateSpendPermissionWithBodyWithResponse(ctx context.Context, address string, params *CreateSpendPermissionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSpendPermissionResponse, error) {
	rsp, err := c.CreateSpendPermissionWithBody(ctx, address, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSpendPermissionResponse(rsp)
}

func (c *ClientWithResponses) CreateSpendPermissionWithResponse(ctx context.Context, address string, params *CreateSpendPermissionParams, body CreateSpendPermissionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSpendPermissionResponse, error) {
	rsp, err := c.CreateSpendPermission(ctx, address, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSpendPermissionResponse(rsp)
}

// ListSpendPermissionsWithResponse request returning *ListSpendPermissionsResponse
func (c *ClientWithResponses) ListSpendPermissionsWithResponse(ctx context.Context, address string, params *ListSpendPermissionsParams, reqEditors ...RequestEditorFn) (*ListSpendPermissionsResponse, error) {
	rsp, err := c.ListSpendPermissions(ctx, address, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSpendPermissionsResponse(rsp)
}

// RevokeSpendPermissionWithBodyWithResponse request with arbitrary body returning *RevokeSpendPermissionResponse
func (c *ClientWithResponses) RevokeSpendPermissionWithBodyWithResponse(ctx context.Context, address string, params *RevokeSpendPermissionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevokeSpendPermissionResponse, error) {
	rsp, err := c.RevokeSpendPermissionWithBody(ctx, address, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevokeSpendPermissionResponse(rsp)
}

func (c *ClientWithResponses) RevokeSpendPermissionWithResponse(ctx context.Context, address string, params *RevokeSpendPermissionParams, body RevokeSpendPermissionJSONRequestBody, reqEditors ...RequestEditorFn) (*RevokeSpendPermissionResponse, error) {
	rsp, err := c.RevokeSpendPermission(ctx, address, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevokeSpendPermissionResponse(rsp)
}

// PrepareUserOperationWithBodyWithResponse request with arbitrary body returning *PrepareUserOperationResponse
func (c *ClientWithResponses) PrepareUserOperationWithBodyWithResponse(ctx context.Context, address string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PrepareUserOperationResponse, error) {
	rsp, err := c.PrepareUserOperationWithBody(ctx, address, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePrepareUserOperationResponse(rsp)
}

func (c *ClientWithResponses) PrepareUserOperationWithResponse(ctx context.Context, address string, body PrepareUserOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*PrepareUserOperationResponse, error) {
	rsp, err := c.PrepareUserOperation(ctx, address, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePrepareUserOperationResponse(rsp)
}

// GetUserOperationWithResponse request returning *GetUserOperationResponse
func (c *ClientWithResponses) GetUserOperationWithResponse(ctx context.Context, address string, userOpHash string, reqEditors ...RequestEditorFn) (*GetUserOperationResponse, error) {
	rsp, err := c.GetUserOperation(ctx, address, userOpHash, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserOperationResponse(rsp)
}

// SendUserOperationWithBodyWithResponse request with arbitrary body returning *SendUserOperationResponse
func (c *ClientWithResponses) SendUserOperationWithBodyWithResponse(ctx context.Context, address string, userOpHash string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendUserOperationResponse, error) {
	rsp, err := c.SendUserOperationWithBody(ctx, address, userOpHash, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendUserOperationResponse(rsp)
}

func (c *ClientWithResponses) SendUserOperationWithResponse(ctx context.Context, address string, userOpHash string, body SendUserOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*SendUserOperationResponse, error) {
	rsp, err := c.SendUserOperation(ctx, address, userOpHash, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendUserOperationResponse(rsp)
}

// CreateEvmSwapQuoteWithBodyWithResponse request with arbitrary body returning *CreateEvmSwapQuoteResponse
func (c *ClientWithResponses) CreateEvmSwapQuoteWithBodyWithResponse(ctx context.Context, params *CreateEvmSwapQuoteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEvmSwapQuoteResponse, error) {
	rsp, err := c.CreateEvmSwapQuoteWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEvmSwapQuoteResponse(rsp)
}

func (c *ClientWithResponses) CreateEvmSwapQuoteWithResponse(ctx context.Context, params *CreateEvmSwapQuoteParams, body CreateEvmSwapQuoteJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEvmSwapQuoteResponse, error) {
	rsp, err := c.CreateEvmSwapQuote(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEvmSwapQuoteResponse(rsp)
}

// GetEvmSwapPriceWithResponse request returning *GetEvmSwapPriceResponse
func (c *ClientWithResponses) GetEvmSwapPriceWithResponse(ctx context.Context, params *GetEvmSwapPriceParams, reqEditors ...RequestEditorFn) (*GetEvmSwapPriceResponse, error) {
	rsp, err := c.GetEvmSwapPrice(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEvmSwapPriceResponse(rsp)
}

// ListEvmTokenBalancesWithResponse request returning *ListEvmTokenBalancesResponse
func (c *ClientWithResponses) ListEvmTokenBalancesWithResponse(ctx context.Context, network ListEvmTokenBalancesNetwork, address string, params *ListEvmTokenBalancesParams, reqEditors ...RequestEditorFn) (*ListEvmTokenBalancesResponse, error) {
	rsp, err := c.ListEvmTokenBalances(ctx, network, address, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListEvmTokenBalancesResponse(rsp)
}

// CreateOnrampOrderWithBodyWithResponse request with arbitrary body returning *CreateOnrampOrderResponse
func (c *ClientWithResponses) CreateOnrampOrderWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOnrampOrderResponse, error) {
	rsp, err := c.CreateOnrampOrderWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOnrampOrderResponse(rsp)
}

func (c *ClientWithResponses) CreateOnrampOrderWithResponse(ctx context.Context, body CreateOnrampOrderJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOnrampOrderResponse, error) {
	rsp, err := c.CreateOnrampOrder(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOnrampOrderResponse(rsp)
}

// GetOnrampOrderByIdWithResponse request returning *GetOnrampOrderByIdResponse
func (c *ClientWithResponses) GetOnrampOrderByIdWithResponse(ctx context.Context, orderId string, reqEditors ...RequestEditorFn) (*GetOnrampOrderByIdResponse, error) {
	rsp, err := c.GetOnrampOrderById(ctx, orderId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOnrampOrderByIdResponse(rsp)
}

// GetCryptoRailsWithResponse request returning *GetCryptoRailsResponse
func (c *ClientWithResponses) GetCryptoRailsWithResponse(ctx context.Context, params *GetCryptoRailsParams, reqEditors ...RequestEditorFn) (*GetCryptoRailsResponse, error) {
	rsp, err := c.GetCryptoRails(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCryptoRailsResponse(rsp)
}

// GetPaymentMethodsWithResponse request returning *GetPaymentMethodsResponse
func (c *ClientWithResponses) GetPaymentMethodsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPaymentMethodsResponse, error) {
	rsp, err := c.GetPaymentMethods(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPaymentMethodsResponse(rsp)
}

// CreatePaymentTransferQuoteWithBodyWithResponse request with arbitrary body returning *CreatePaymentTransferQuoteResponse
func (c *ClientWithResponses) CreatePaymentTransferQuoteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePaymentTransferQuoteResponse, error) {
	rsp, err := c.CreatePaymentTransferQuoteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePaymentTransferQuoteResponse(rsp)
}

func (c *ClientWithResponses) CreatePaymentTransferQuoteWithResponse(ctx context.Context, body CreatePaymentTransferQuoteJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePaymentTransferQuoteResponse, error) {
	rsp, err := c.CreatePaymentTransferQuote(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePaymentTransferQuoteResponse(rsp)
}

// GetPaymentTransferWithResponse request returning *GetPaymentTransferResponse
func (c *ClientWithResponses) GetPaymentTransferWithResponse(ctx context.Context, transferId string, reqEditors ...RequestEditorFn) (*GetPaymentTransferResponse, error) {
	rsp, err := c.GetPaymentTransfer(ctx, transferId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPaymentTransferResponse(rsp)
}

// ExecutePaymentTransferQuoteWithResponse request returning *ExecutePaymentTransferQuoteResponse
func (c *ClientWithResponses) ExecutePaymentTransferQuoteWithResponse(ctx context.Context, transferId string, reqEditors ...RequestEditorFn) (*ExecutePaymentTransferQuoteResponse, error) {
	rsp, err := c.ExecutePaymentTransferQuote(ctx, transferId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExecutePaymentTransferQuoteResponse(rsp)
}

// ListPoliciesWithResponse request returning *ListPoliciesResponse
func (c *ClientWithResponses) ListPoliciesWithResponse(ctx context.Context, params *ListPoliciesParams, reqEditors ...RequestEditorFn) (*ListPoliciesResponse, error) {
	rsp, err := c.ListPolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPoliciesResponse(rsp)
}

// CreatePolicyWithBodyWithResponse request with arbitrary body returning *CreatePolicyResponse
func (c *ClientWithResponses) CreatePolicyWithBodyWithResponse(ctx context.Context, params *CreatePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePolicyResponse, error) {
	rsp, err := c.CreatePolicyWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePolicyResponse(rsp)
}

func (c *ClientWithResponses) CreatePolicyWithResponse(ctx context.Context, params *CreatePolicyParams, body CreatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePolicyResponse, error) {
	rsp, err := c.CreatePolicy(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePolicyResponse(rsp)
}

// DeletePolicyWithResponse request returning *DeletePolicyResponse
func (c *ClientWithResponses) DeletePolicyWithResponse(ctx context.Context, policyId string, params *DeletePolicyParams, reqEditors ...RequestEditorFn) (*DeletePolicyResponse, error) {
	rsp, err := c.DeletePolicy(ctx, policyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePolicyResponse(rsp)
}

// GetPolicyByIdWithResponse request returning *GetPolicyByIdResponse
func (c *ClientWithResponses) GetPolicyByIdWithResponse(ctx context.Context, policyId string, reqEditors ...RequestEditorFn) (*GetPolicyByIdResponse, error) {
	rsp, err := c.GetPolicyById(ctx, policyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPolicyByIdResponse(rsp)
}

// UpdatePolicyWithBodyWithResponse request with arbitrary body returning *UpdatePolicyResponse
func (c *ClientWithResponses) UpdatePolicyWithBodyWithResponse(ctx context.Context, policyId string, params *UpdatePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePolicyResponse, error) {
	rsp, err := c.UpdatePolicyWithBody(ctx, policyId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePolicyResponse(rsp)
}

func (c *ClientWithResponses) UpdatePolicyWithResponse(ctx context.Context, policyId string, params *UpdatePolicyParams, body UpdatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePolicyResponse, error) {
	rsp, err := c.UpdatePolicy(ctx, policyId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePolicyResponse(rsp)
}

// ListSolanaAccountsWithResponse request returning *ListSolanaAccountsResponse
func (c *ClientWithResponses) ListSolanaAccountsWithResponse(ctx context.Context, params *ListSolanaAccountsParams, reqEditors ...RequestEditorFn) (*ListSolanaAccountsResponse, error) {
	rsp, err := c.ListSolanaAccounts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSolanaAccountsResponse(rsp)
}

// CreateSolanaAccountWithBodyWithResponse request with arbitrary body returning *CreateSolanaAccountResponse
func (c *ClientWithResponses) CreateSolanaAccountWithBodyWithResponse(ctx context.Context, params *CreateSolanaAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSolanaAccountResponse, error) {
	rsp, err := c.CreateSolanaAccountWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSolanaAccountResponse(rsp)
}

func (c *ClientWithResponses) CreateSolanaAccountWithResponse(ctx context.Context, params *CreateSolanaAccountParams, body CreateSolanaAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSolanaAccountResponse, error) {
	rsp, err := c.CreateSolanaAccount(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSolanaAccountResponse(rsp)
}

// GetSolanaAccountByNameWithResponse request returning *GetSolanaAccountByNameResponse
func (c *ClientWithResponses) GetSolanaAccountByNameWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetSolanaAccountByNameResponse, error) {
	rsp, err := c.GetSolanaAccountByName(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSolanaAccountByNameResponse(rsp)
}

// ExportSolanaAccountByNameWithBodyWithResponse request with arbitrary body returning *ExportSolanaAccountByNameResponse
func (c *ClientWithResponses) ExportSolanaAccountByNameWithBodyWithResponse(ctx context.Context, name string, params *ExportSolanaAccountByNameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExportSolanaAccountByNameResponse, error) {
	rsp, err := c.ExportSolanaAccountByNameWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportSolanaAccountByNameResponse(rsp)
}

func (c *ClientWithResponses) ExportSolanaAccountByNameWithResponse(ctx context.Context, name string, params *ExportSolanaAccountByNameParams, body ExportSolanaAccountByNameJSONRequestBody, reqEditors ...RequestEditorFn) (*ExportSolanaAccountByNameResponse, error) {
	rsp, err := c.ExportSolanaAccountByName(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportSolanaAccountByNameResponse(rsp)
}

// ImportSolanaAccountWithBodyWithResponse request with arbitrary body returning *ImportSolanaAccountResponse
func (c *ClientWithResponses) ImportSolanaAccountWithBodyWithResponse(ctx context.Context, params *ImportSolanaAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ImportSolanaAccountResponse, error) {
	rsp, err := c.ImportSolanaAccountWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImportSolanaAccountResponse(rsp)
}

func (c *ClientWithResponses) ImportSolanaAccountWithResponse(ctx context.Context, params *ImportSolanaAccountParams, body ImportSolanaAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*ImportSolanaAccountResponse, error) {
	rsp, err := c.ImportSolanaAccount(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImportSolanaAccountResponse(rsp)
}

// SendSolanaTransactionWithBodyWithResponse request with arbitrary body returning *SendSolanaTransactionResponse
func (c *ClientWithResponses) SendSolanaTransactionWithBodyWithResponse(ctx context.Context, params *SendSolanaTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendSolanaTransactionResponse, error) {
	rsp, err := c.SendSolanaTransactionWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendSolanaTransactionResponse(rsp)
}

func (c *ClientWithResponses) SendSolanaTransactionWithResponse(ctx context.Context, params *SendSolanaTransactionParams, body SendSolanaTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*SendSolanaTransactionResponse, error) {
	rsp, err := c.SendSolanaTransaction(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendSolanaTransactionResponse(rsp)
}

// GetSolanaAccountWithResponse request returning *GetSolanaAccountResponse
func (c *ClientWithResponses) GetSolanaAccountWithResponse(ctx context.Context, address string, reqEditors ...RequestEditorFn) (*GetSolanaAccountResponse, error) {
	rsp, err := c.GetSolanaAccount(ctx, address, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSolanaAccountResponse(rsp)
}

// UpdateSolanaAccountWithBodyWithResponse request with arbitrary body returning *UpdateSolanaAccountResponse
func (c *ClientWithResponses) UpdateSolanaAccountWithBodyWithResponse(ctx context.Context, address string, params *UpdateSolanaAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSolanaAccountResponse, error) {
	rsp, err := c.UpdateSolanaAccountWithBody(ctx, address, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSolanaAccountResponse(rsp)
}

func (c *ClientWithResponses) UpdateSolanaAccountWithResponse(ctx context.Context, address string, params *UpdateSolanaAccountParams, body UpdateSolanaAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSolanaAccountResponse, error) {
	rsp, err := c.UpdateSolanaAccount(ctx, address, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSolanaAccountResponse(rsp)
}

// ExportSolanaAccountWithBodyWithResponse request with arbitrary body returning *ExportSolanaAccountResponse
func (c *ClientWithResponses) ExportSolanaAccountWithBodyWithResponse(ctx context.Context, address string, params *ExportSolanaAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExportSolanaAccountResponse, error) {
	rsp, err := c.ExportSolanaAccountWithBody(ctx, address, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportSolanaAccountResponse(rsp)
}

func (c *ClientWithResponses) ExportSolanaAccountWithResponse(ctx context.Context, address string, params *ExportSolanaAccountParams, body ExportSolanaAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*ExportSolanaAccountResponse, error) {
	rsp, err := c.ExportSolanaAccount(ctx, address, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportSolanaAccountResponse(rsp)
}

// SignSolanaMessageWithBodyWithResponse request with arbitrary body returning *SignSolanaMessageResponse
func (c *ClientWithResponses) SignSolanaMessageWithBodyWithResponse(ctx context.Context, address string, params *SignSolanaMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SignSolanaMessageResponse, error) {
	rsp, err := c.SignSolanaMessageWithBody(ctx, address, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSignSolanaMessageResponse(rsp)
}

func (c *ClientWithResponses) SignSolanaMessageWithResponse(ctx context.Context, address string, params *SignSolanaMessageParams, body SignSolanaMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*SignSolanaMessageResponse, error) {
	rsp, err := c.SignSolanaMessage(ctx, address, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSignSolanaMessageResponse(rsp)
}

// SignSolanaTransactionWithBodyWithResponse request with arbitrary body returning *SignSolanaTransactionResponse
func (c *ClientWithResponses) SignSolanaTransactionWithBodyWithResponse(ctx context.Context, address string, params *SignSolanaTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SignSolanaTransactionResponse, error) {
	rsp, err := c.SignSolanaTransactionWithBody(ctx, address, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSignSolanaTransactionResponse(rsp)
}

func (c *ClientWithResponses) SignSolanaTransactionWithResponse(ctx context.Context, address string, params *SignSolanaTransactionParams, body SignSolanaTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*SignSolanaTransactionResponse, error) {
	rsp, err := c.SignSolanaTransaction(ctx, address, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSignSolanaTransactionResponse(rsp)
}

// RequestSolanaFaucetWithBodyWithResponse request with arbitrary body returning *RequestSolanaFaucetResponse
func (c *ClientWithResponses) RequestSolanaFaucetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RequestSolanaFaucetResponse, error) {
	rsp, err := c.RequestSolanaFaucetWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRequestSolanaFaucetResponse(rsp)
}

func (c *ClientWithResponses) RequestSolanaFaucetWithResponse(ctx context.Context, body RequestSolanaFaucetJSONRequestBody, reqEditors ...RequestEditorFn) (*RequestSolanaFaucetResponse, error) {
	rsp, err := c.RequestSolanaFaucet(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRequestSolanaFaucetResponse(rsp)
}

// ListSolanaTokenBalancesWithResponse request returning *ListSolanaTokenBalancesResponse
func (c *ClientWithResponses) ListSolanaTokenBalancesWithResponse(ctx context.Context, network ListSolanaTokenBalancesNetwork, address string, params *ListSolanaTokenBalancesParams, reqEditors ...RequestEditorFn) (*ListSolanaTokenBalancesResponse, error) {
	rsp, err := c.ListSolanaTokenBalances(ctx, network, address, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSolanaTokenBalancesResponse(rsp)
}

// ParseRunSQLQueryResponse parses an HTTP response from a RunSQLQueryWithResponse call
func ParseRunSQLQueryResponse(rsp *http.Response) (*RunSQLQueryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RunSQLQueryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OnchainDataResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidSQLQueryError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 408:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON408 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 504:
		var dest TimedOutError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON504 = &dest

	}

	return response, nil
}

// ParseListEvmAccountsResponse parses an HTTP response from a ListEvmAccountsWithResponse call
func ParseListEvmAccountsResponse(rsp *http.Response) (*ListEvmAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListEvmAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Accounts The list of EVM accounts.
			Accounts []EvmAccount `json:"accounts"`

			// NextPageToken The token for the next page of items, if any.
			NextPageToken *string `json:"nextPageToken,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCreateEvmAccountResponse parses an HTTP response from a CreateEvmAccountWithResponse call
func ParseCreateEvmAccountResponse(rsp *http.Response) (*CreateEvmAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateEvmAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest EvmAccount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest PaymentMethodRequiredError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetEvmAccountByNameResponse parses an HTTP response from a GetEvmAccountByNameWithResponse call
func ParseGetEvmAccountByNameResponse(rsp *http.Response) (*GetEvmAccountByNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEvmAccountByNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EvmAccount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseExportEvmAccountByNameResponse parses an HTTP response from a ExportEvmAccountByNameWithResponse call
func ParseExportEvmAccountByNameResponse(rsp *http.Response) (*ExportEvmAccountByNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExportEvmAccountByNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// EncryptedPrivateKey The base64-encoded, encrypted private key of the EVM account which is a 32 byte raw private key. The private key is encrypted in transport using the exportEncryptionKey in the request.
			EncryptedPrivateKey string `json:"encryptedPrivateKey"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest PaymentMethodRequiredError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseImportEvmAccountResponse parses an HTTP response from a ImportEvmAccountWithResponse call
func ParseImportEvmAccountResponse(rsp *http.Response) (*ImportEvmAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ImportEvmAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest EvmAccount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest PaymentMethodRequiredError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetEvmAccountResponse parses an HTTP response from a GetEvmAccountWithResponse call
func ParseGetEvmAccountResponse(rsp *http.Response) (*GetEvmAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEvmAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EvmAccount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseUpdateEvmAccountResponse parses an HTTP response from a UpdateEvmAccountWithResponse call
func ParseUpdateEvmAccountResponse(rsp *http.Response) (*UpdateEvmAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateEvmAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EvmAccount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExistsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseExportEvmAccountResponse parses an HTTP response from a ExportEvmAccountWithResponse call
func ParseExportEvmAccountResponse(rsp *http.Response) (*ExportEvmAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExportEvmAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// EncryptedPrivateKey The base64-encoded, encrypted private key of the EVM account which is a 32 byte raw private key. The private key is encrypted in transport using the exportEncryptionKey in the request.
			EncryptedPrivateKey string `json:"encryptedPrivateKey"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest PaymentMethodRequiredError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSendEvmTransactionResponse parses an HTTP response from a SendEvmTransactionWithResponse call
func ParseSendEvmTransactionResponse(rsp *http.Response) (*SendEvmTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SendEvmTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// TransactionHash The hash of the transaction, as a 0x-prefixed hex string.
			TransactionHash string `json:"transactionHash"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest PaymentMethodRequiredError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExistsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSignEvmHashResponse parses an HTTP response from a SignEvmHashWithResponse call
func ParseSignEvmHashResponse(rsp *http.Response) (*SignEvmHashResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SignEvmHashResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Signature The signature of the hash, as a 0x-prefixed hex string.
			Signature string `json:"signature"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest PaymentMethodRequiredError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExistsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSignEvmMessageResponse parses an HTTP response from a SignEvmMessageWithResponse call
func ParseSignEvmMessageResponse(rsp *http.Response) (*SignEvmMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SignEvmMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Signature The signature of the message, as a 0x-prefixed hex string.
			Signature string `json:"signature"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest PaymentMethodRequiredError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExistsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSignEvmTransactionResponse parses an HTTP response from a SignEvmTransactionWithResponse call
func ParseSignEvmTransactionResponse(rsp *http.Response) (*SignEvmTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SignEvmTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// SignedTransaction The RLP-encoded signed transaction, as a 0x-prefixed hex string.
			SignedTransaction string `json:"signedTransaction"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest PaymentMethodRequiredError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExistsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSignEvmTypedDataResponse parses an HTTP response from a SignEvmTypedDataWithResponse call
func ParseSignEvmTypedDataResponse(rsp *http.Response) (*SignEvmTypedDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SignEvmTypedDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Signature The signature of the typed data, as a 0x-prefixed hex string.
			Signature string `json:"signature"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest PaymentMethodRequiredError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseRequestEvmFaucetResponse parses an HTTP response from a RequestEvmFaucetWithResponse call
func ParseRequestEvmFaucetResponse(rsp *http.Response) (*RequestEvmFaucetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RequestEvmFaucetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// TransactionHash The hash of the transaction that requested the funds.
			// **Note:** In rare cases, when gas conditions are unusually high, the transaction may not confirm, and the system may issue a replacement transaction to complete the faucet request. In these rare cases, the `transactionHash` will be out of sync with the actual faucet transaction that was confirmed onchain.
			TransactionHash string `json:"transactionHash"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseListEvmSmartAccountsResponse parses an HTTP response from a ListEvmSmartAccountsWithResponse call
func ParseListEvmSmartAccountsResponse(rsp *http.Response) (*ListEvmSmartAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListEvmSmartAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Accounts The list of Smart Accounts.
			Accounts []EvmSmartAccount `json:"accounts"`

			// NextPageToken The token for the next page of items, if any.
			NextPageToken *string `json:"nextPageToken,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCreateEvmSmartAccountResponse parses an HTTP response from a CreateEvmSmartAccountWithResponse call
func ParseCreateEvmSmartAccountResponse(rsp *http.Response) (*CreateEvmSmartAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateEvmSmartAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest EvmSmartAccount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest PaymentMethodRequiredError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetEvmSmartAccountByNameResponse parses an HTTP response from a GetEvmSmartAccountByNameWithResponse call
func ParseGetEvmSmartAccountByNameResponse(rsp *http.Response) (*GetEvmSmartAccountByNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEvmSmartAccountByNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EvmSmartAccount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetEvmSmartAccountResponse parses an HTTP response from a GetEvmSmartAccountWithResponse call
func ParseGetEvmSmartAccountResponse(rsp *http.Response) (*GetEvmSmartAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEvmSmartAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EvmSmartAccount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseUpdateEvmSmartAccountResponse parses an HTTP response from a UpdateEvmSmartAccountWithResponse call
func ParseUpdateEvmSmartAccountResponse(rsp *http.Response) (*UpdateEvmSmartAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateEvmSmartAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EvmSmartAccount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExistsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCreateSpendPermissionResponse parses an HTTP response from a CreateSpendPermissionWithResponse call
func ParseCreateSpendPermissionResponse(rsp *http.Response) (*CreateSpendPermissionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSpendPermissionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EvmUserOperation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseListSpendPermissionsResponse parses an HTTP response from a ListSpendPermissionsWithResponse call
func ParseListSpendPermissionsResponse(rsp *http.Response) (*ListSpendPermissionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSpendPermissionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextPageToken The token for the next page of items, if any.
			NextPageToken *string `json:"nextPageToken,omitempty"`

			// SpendPermissions The spend permissions for the smart account.
			SpendPermissions []SpendPermissionResponseObject `json:"spendPermissions"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseRevokeSpendPermissionResponse parses an HTTP response from a RevokeSpendPermissionWithResponse call
func ParseRevokeSpendPermissionResponse(rsp *http.Response) (*RevokeSpendPermissionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevokeSpendPermissionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EvmUserOperation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParsePrepareUserOperationResponse parses an HTTP response from a PrepareUserOperationWithResponse call
func ParsePrepareUserOperationResponse(rsp *http.Response) (*PrepareUserOperationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PrepareUserOperationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest EvmUserOperation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetUserOperationResponse parses an HTTP response from a GetUserOperationWithResponse call
func ParseGetUserOperationResponse(rsp *http.Response) (*GetUserOperationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserOperationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EvmUserOperation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSendUserOperationResponse parses an HTTP response from a SendUserOperationWithResponse call
func ParseSendUserOperationResponse(rsp *http.Response) (*SendUserOperationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SendUserOperationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EvmUserOperation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest PaymentMethodRequiredError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCreateEvmSwapQuoteResponse parses an HTTP response from a CreateEvmSwapQuoteWithResponse call
func ParseCreateEvmSwapQuoteResponse(rsp *http.Response) (*CreateEvmSwapQuoteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateEvmSwapQuoteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateSwapQuoteResponseWrapper
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetEvmSwapPriceResponse parses an HTTP response from a GetEvmSwapPriceWithResponse call
func ParseGetEvmSwapPriceResponse(rsp *http.Response) (*GetEvmSwapPriceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEvmSwapPriceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetSwapPriceResponseWrapper
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseListEvmTokenBalancesResponse parses an HTTP response from a ListEvmTokenBalancesWithResponse call
func ParseListEvmTokenBalancesResponse(rsp *http.Response) (*ListEvmTokenBalancesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListEvmTokenBalancesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Balances The list of EVM token balances.
			Balances []TokenBalance `json:"balances"`

			// NextPageToken The token for the next page of items, if any.
			NextPageToken *string `json:"nextPageToken,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCreateOnrampOrderResponse parses an HTTP response from a CreateOnrampOrderWithResponse call
func ParseCreateOnrampOrderResponse(rsp *http.Response) (*CreateOnrampOrderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOnrampOrderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Order An Onramp order.
			Order OnrampOrder `json:"order"`

			// PaymentLink A payment link to pay for an order.
			//
			// Please refer to the [Onramp docs](https://docs.cdp.coinbase.com/onramp-&-offramp/onramp-apis/onramp-overview) for details on how to integrate with the different payment link types.
			PaymentLink *OnrampPaymentLink `json:"paymentLink,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetOnrampOrderByIdResponse parses an HTTP response from a GetOnrampOrderByIdWithResponse call
func ParseGetOnrampOrderByIdResponse(rsp *http.Response) (*GetOnrampOrderByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOnrampOrderByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Order An Onramp order.
			Order OnrampOrder `json:"order"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitExceeded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCryptoRailsResponse parses an HTTP response from a GetCryptoRailsWithResponse call
func ParseGetCryptoRailsResponse(rsp *http.Response) (*GetCryptoRailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCryptoRailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []CryptoRail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetPaymentMethodsResponse parses an HTTP response from a GetPaymentMethodsWithResponse call
func ParseGetPaymentMethodsResponse(rsp *http.Response) (*GetPaymentMethodsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPaymentMethodsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PaymentMethod
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCreatePaymentTransferQuoteResponse parses an HTTP response from a CreatePaymentTransferQuoteWithResponse call
func ParseCreatePaymentTransferQuoteResponse(rsp *http.Response) (*CreatePaymentTransferQuoteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePaymentTransferQuoteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Transfer The transfer object.
			Transfer Transfer `json:"transfer"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPaymentTransferResponse parses an HTTP response from a GetPaymentTransferWithResponse call
func ParseGetPaymentTransferResponse(rsp *http.Response) (*GetPaymentTransferResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPaymentTransferResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Transfer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseExecutePaymentTransferQuoteResponse parses an HTTP response from a ExecutePaymentTransferQuoteWithResponse call
func ParseExecutePaymentTransferQuoteResponse(rsp *http.Response) (*ExecutePaymentTransferQuoteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExecutePaymentTransferQuoteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Transfer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseListPoliciesResponse parses an HTTP response from a ListPoliciesWithResponse call
func ParseListPoliciesResponse(rsp *http.Response) (*ListPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextPageToken The token for the next page of items, if any.
			NextPageToken *string `json:"nextPageToken,omitempty"`

			// Policies The list of policies.
			Policies []Policy `json:"policies"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCreatePolicyResponse parses an HTTP response from a CreatePolicyWithResponse call
func ParseCreatePolicyResponse(rsp *http.Response) (*CreatePolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Policy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExistsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDeletePolicyResponse parses an HTTP response from a DeletePolicyWithResponse call
func ParseDeletePolicyResponse(rsp *http.Response) (*DeletePolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExistsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetPolicyByIdResponse parses an HTTP response from a GetPolicyByIdWithResponse call
func ParseGetPolicyByIdResponse(rsp *http.Response) (*GetPolicyByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPolicyByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Policy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseUpdatePolicyResponse parses an HTTP response from a UpdatePolicyWithResponse call
func ParseUpdatePolicyResponse(rsp *http.Response) (*UpdatePolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Policy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExistsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseListSolanaAccountsResponse parses an HTTP response from a ListSolanaAccountsWithResponse call
func ParseListSolanaAccountsResponse(rsp *http.Response) (*ListSolanaAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSolanaAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Accounts The list of Solana accounts.
			Accounts []SolanaAccount `json:"accounts"`

			// NextPageToken The token for the next page of items, if any.
			NextPageToken *string `json:"nextPageToken,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCreateSolanaAccountResponse parses an HTTP response from a CreateSolanaAccountWithResponse call
func ParseCreateSolanaAccountResponse(rsp *http.Response) (*CreateSolanaAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSolanaAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SolanaAccount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest PaymentMethodRequiredError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetSolanaAccountByNameResponse parses an HTTP response from a GetSolanaAccountByNameWithResponse call
func ParseGetSolanaAccountByNameResponse(rsp *http.Response) (*GetSolanaAccountByNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSolanaAccountByNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SolanaAccount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseExportSolanaAccountByNameResponse parses an HTTP response from a ExportSolanaAccountByNameWithResponse call
func ParseExportSolanaAccountByNameResponse(rsp *http.Response) (*ExportSolanaAccountByNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExportSolanaAccountByNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// EncryptedPrivateKey The base64-encoded, encrypted private key of the Solana account which is a 32 byte raw private key. The private key is encrypted in transport using the exportEncryptionKey in the request.
			EncryptedPrivateKey string `json:"encryptedPrivateKey"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest PaymentMethodRequiredError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseImportSolanaAccountResponse parses an HTTP response from a ImportSolanaAccountWithResponse call
func ParseImportSolanaAccountResponse(rsp *http.Response) (*ImportSolanaAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ImportSolanaAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SolanaAccount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest PaymentMethodRequiredError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSendSolanaTransactionResponse parses an HTTP response from a SendSolanaTransactionWithResponse call
func ParseSendSolanaTransactionResponse(rsp *http.Response) (*SendSolanaTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SendSolanaTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// TransactionSignature The base58 encoded transaction signature.
			TransactionSignature string `json:"transactionSignature"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest PaymentMethodRequiredError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetSolanaAccountResponse parses an HTTP response from a GetSolanaAccountWithResponse call
func ParseGetSolanaAccountResponse(rsp *http.Response) (*GetSolanaAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSolanaAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SolanaAccount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseUpdateSolanaAccountResponse parses an HTTP response from a UpdateSolanaAccountWithResponse call
func ParseUpdateSolanaAccountResponse(rsp *http.Response) (*UpdateSolanaAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSolanaAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SolanaAccount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExistsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseExportSolanaAccountResponse parses an HTTP response from a ExportSolanaAccountWithResponse call
func ParseExportSolanaAccountResponse(rsp *http.Response) (*ExportSolanaAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExportSolanaAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// EncryptedPrivateKey The base64-encoded, encrypted private key of the Solana account which is a 32 byte raw private key. The private key is encrypted in transport using the exportEncryptionKey in the request.
			EncryptedPrivateKey string `json:"encryptedPrivateKey"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest PaymentMethodRequiredError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSignSolanaMessageResponse parses an HTTP response from a SignSolanaMessageWithResponse call
func ParseSignSolanaMessageResponse(rsp *http.Response) (*SignSolanaMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SignSolanaMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Signature The signature of the message, as a base58 encoded string.
			Signature string `json:"signature"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest PaymentMethodRequiredError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExistsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSignSolanaTransactionResponse parses an HTTP response from a SignSolanaTransactionWithResponse call
func ParseSignSolanaTransactionResponse(rsp *http.Response) (*SignSolanaTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SignSolanaTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// SignedTransaction The base64 encoded signed transaction.
			SignedTransaction string `json:"signedTransaction"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest PaymentMethodRequiredError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExistsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseRequestSolanaFaucetResponse parses an HTTP response from a RequestSolanaFaucetWithResponse call
func ParseRequestSolanaFaucetResponse(rsp *http.Response) (*RequestSolanaFaucetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RequestSolanaFaucetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// TransactionSignature The signature identifying the transaction that requested the funds.
			TransactionSignature string `json:"transactionSignature"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseListSolanaTokenBalancesResponse parses an HTTP response from a ListSolanaTokenBalancesWithResponse call
func ParseListSolanaTokenBalancesResponse(rsp *http.Response) (*ListSolanaTokenBalancesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSolanaTokenBalancesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Balances The list of Solana token balances.
			Balances []SolanaTokenBalance `json:"balances"`

			// NextPageToken The token for the next page of items, if any.
			NextPageToken *string `json:"nextPageToken,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}
