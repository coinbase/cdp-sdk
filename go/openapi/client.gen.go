// Package openapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.16.3 DO NOT EDIT.
package openapi

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

// Defines values for AbiFunctionType.
const (
	Function AbiFunctionType = "function"
)

// Defines values for AbiInputType.
const (
	AbiInputTypeConstructor AbiInputType = "constructor"
	AbiInputTypeError       AbiInputType = "error"
	AbiInputTypeEvent       AbiInputType = "event"
	AbiInputTypeFallback    AbiInputType = "fallback"
	AbiInputTypeReceive     AbiInputType = "receive"
)

// Defines values for AbiStateMutability.
const (
	Nonpayable AbiStateMutability = "nonpayable"
	Payable    AbiStateMutability = "payable"
	Pure       AbiStateMutability = "pure"
	View       AbiStateMutability = "view"
)

// Defines values for CommonSwapResponseLiquidityAvailable.
const (
	CommonSwapResponseLiquidityAvailableTrue CommonSwapResponseLiquidityAvailable = true
)

// Defines values for CreateSwapQuoteResponseLiquidityAvailable.
const (
	CreateSwapQuoteResponseLiquidityAvailableTrue CreateSwapQuoteResponseLiquidityAvailable = true
)

// Defines values for ErrorType.
const (
	ErrorTypeAccountLimitExceeded  ErrorType = "account_limit_exceeded"
	ErrorTypeAlreadyExists         ErrorType = "already_exists"
	ErrorTypeBadGateway            ErrorType = "bad_gateway"
	ErrorTypeFaucetLimitExceeded   ErrorType = "faucet_limit_exceeded"
	ErrorTypeForbidden             ErrorType = "forbidden"
	ErrorTypeIdempotencyError      ErrorType = "idempotency_error"
	ErrorTypeInternalServerError   ErrorType = "internal_server_error"
	ErrorTypeInvalidRequest        ErrorType = "invalid_request"
	ErrorTypeInvalidSignature      ErrorType = "invalid_signature"
	ErrorTypeMalformedTransaction  ErrorType = "malformed_transaction"
	ErrorTypeNotFound              ErrorType = "not_found"
	ErrorTypePaymentMethodRequired ErrorType = "payment_method_required"
	ErrorTypePolicyInUse           ErrorType = "policy_in_use"
	ErrorTypePolicyViolation       ErrorType = "policy_violation"
	ErrorTypeRateLimitExceeded     ErrorType = "rate_limit_exceeded"
	ErrorTypeRequestCanceled       ErrorType = "request_canceled"
	ErrorTypeServiceUnavailable    ErrorType = "service_unavailable"
	ErrorTypeTimedOut              ErrorType = "timed_out"
	ErrorTypeUnauthorized          ErrorType = "unauthorized"
)

// Defines values for EthValueCriterionOperator.
const (
	EthValueCriterionOperatorEmpty      EthValueCriterionOperator = ">"
	EthValueCriterionOperatorEqualEqual EthValueCriterionOperator = "=="
	EthValueCriterionOperatorN1         EthValueCriterionOperator = ">="
	EthValueCriterionOperatorN2         EthValueCriterionOperator = "<"
	EthValueCriterionOperatorN3         EthValueCriterionOperator = "<="
)

// Defines values for EthValueCriterionType.
const (
	EthValue EthValueCriterionType = "ethValue"
)

// Defines values for EvmAddressCriterionOperator.
const (
	EvmAddressCriterionOperatorIn    EvmAddressCriterionOperator = "in"
	EvmAddressCriterionOperatorNotIn EvmAddressCriterionOperator = "not in"
)

// Defines values for EvmAddressCriterionType.
const (
	EvmAddress EvmAddressCriterionType = "evmAddress"
)

// Defines values for EvmDataCriterionType.
const (
	EvmData EvmDataCriterionType = "evmData"
)

// Defines values for EvmDataParameterConditionOperator.
const (
	EvmDataParameterConditionOperatorEmpty      EvmDataParameterConditionOperator = ">"
	EvmDataParameterConditionOperatorEqualEqual EvmDataParameterConditionOperator = "=="
	EvmDataParameterConditionOperatorN1         EvmDataParameterConditionOperator = ">="
	EvmDataParameterConditionOperatorN2         EvmDataParameterConditionOperator = "<"
	EvmDataParameterConditionOperatorN3         EvmDataParameterConditionOperator = "<="
)

// Defines values for EvmDataParameterConditionListOperator.
const (
	EvmDataParameterConditionListOperatorIn    EvmDataParameterConditionListOperator = "in"
	EvmDataParameterConditionListOperatorNotIn EvmDataParameterConditionListOperator = "not in"
)

// Defines values for EvmMessageCriterionType.
const (
	EvmMessage EvmMessageCriterionType = "evmMessage"
)

// Defines values for EvmNetworkCriterionNetworks.
const (
	EvmNetworkCriterionNetworksBase        EvmNetworkCriterionNetworks = "base"
	EvmNetworkCriterionNetworksBaseSepolia EvmNetworkCriterionNetworks = "base-sepolia"
)

// Defines values for EvmNetworkCriterionOperator.
const (
	EvmNetworkCriterionOperatorIn    EvmNetworkCriterionOperator = "in"
	EvmNetworkCriterionOperatorNotIn EvmNetworkCriterionOperator = "not in"
)

// Defines values for EvmNetworkCriterionType.
const (
	EvmNetwork EvmNetworkCriterionType = "evmNetwork"
)

// Defines values for EvmSwapsNetwork.
const (
	EvmSwapsNetworkBase     EvmSwapsNetwork = "base"
	EvmSwapsNetworkEthereum EvmSwapsNetwork = "ethereum"
)

// Defines values for EvmUserOperationNetwork.
const (
	EvmUserOperationNetworkBase        EvmUserOperationNetwork = "base"
	EvmUserOperationNetworkBaseSepolia EvmUserOperationNetwork = "base-sepolia"
)

// Defines values for EvmUserOperationStatus.
const (
	EvmUserOperationStatusBroadcast EvmUserOperationStatus = "broadcast"
	EvmUserOperationStatusComplete  EvmUserOperationStatus = "complete"
	EvmUserOperationStatusDropped   EvmUserOperationStatus = "dropped"
	EvmUserOperationStatusFailed    EvmUserOperationStatus = "failed"
	EvmUserOperationStatusPending   EvmUserOperationStatus = "pending"
	EvmUserOperationStatusSigned    EvmUserOperationStatus = "signed"
)

// Defines values for FeeType.
const (
	ExchangeFee FeeType = "exchange_fee"
	NetworkFee  FeeType = "network_fee"
)

// Defines values for GetSwapPriceResponseLiquidityAvailable.
const (
	True GetSwapPriceResponseLiquidityAvailable = true
)

// Defines values for KnownAbiType.
const (
	Erc1155 KnownAbiType = "erc1155"
	Erc20   KnownAbiType = "erc20"
	Erc721  KnownAbiType = "erc721"
)

// Defines values for ListEvmTokenBalancesNetwork.
const (
	ListEvmTokenBalancesNetworkBase        ListEvmTokenBalancesNetwork = "base"
	ListEvmTokenBalancesNetworkBaseSepolia ListEvmTokenBalancesNetwork = "base-sepolia"
	ListEvmTokenBalancesNetworkEthereum    ListEvmTokenBalancesNetwork = "ethereum"
)

// Defines values for PaymentMethodType.
const (
	Card        PaymentMethodType = "card"
	FiatAccount PaymentMethodType = "fiat_account"
)

// Defines values for PaymentRailAction.
const (
	Source PaymentRailAction = "source"
	Target PaymentRailAction = "target"
)

// Defines values for PolicyScope.
const (
	PolicyScopeAccount PolicyScope = "account"
	PolicyScopeProject PolicyScope = "project"
)

// Defines values for SendEvmTransactionRuleAction.
const (
	SendEvmTransactionRuleActionAccept SendEvmTransactionRuleAction = "accept"
	SendEvmTransactionRuleActionReject SendEvmTransactionRuleAction = "reject"
)

// Defines values for SendEvmTransactionRuleOperation.
const (
	SendEvmTransaction SendEvmTransactionRuleOperation = "sendEvmTransaction"
)

// Defines values for SignEvmHashRuleAction.
const (
	SignEvmHashRuleActionAccept SignEvmHashRuleAction = "accept"
	SignEvmHashRuleActionReject SignEvmHashRuleAction = "reject"
)

// Defines values for SignEvmHashRuleOperation.
const (
	SignEvmHash SignEvmHashRuleOperation = "signEvmHash"
)

// Defines values for SignEvmMessageRuleAction.
const (
	SignEvmMessageRuleActionAccept SignEvmMessageRuleAction = "accept"
	SignEvmMessageRuleActionReject SignEvmMessageRuleAction = "reject"
)

// Defines values for SignEvmMessageRuleOperation.
const (
	SignEvmMessage SignEvmMessageRuleOperation = "signEvmMessage"
)

// Defines values for SignEvmTransactionRuleAction.
const (
	SignEvmTransactionRuleActionAccept SignEvmTransactionRuleAction = "accept"
	SignEvmTransactionRuleActionReject SignEvmTransactionRuleAction = "reject"
)

// Defines values for SignEvmTransactionRuleOperation.
const (
	SignEvmTransaction SignEvmTransactionRuleOperation = "signEvmTransaction"
)

// Defines values for SignSolTransactionRuleAction.
const (
	Accept SignSolTransactionRuleAction = "accept"
	Reject SignSolTransactionRuleAction = "reject"
)

// Defines values for SignSolTransactionRuleOperation.
const (
	SignSolTransaction SignSolTransactionRuleOperation = "signSolTransaction"
)

// Defines values for SolAddressCriterionOperator.
const (
	SolAddressCriterionOperatorIn    SolAddressCriterionOperator = "in"
	SolAddressCriterionOperatorNotIn SolAddressCriterionOperator = "not in"
)

// Defines values for SolAddressCriterionType.
const (
	SolAddress SolAddressCriterionType = "solAddress"
)

// Defines values for SwapUnavailableResponseLiquidityAvailable.
const (
	False SwapUnavailableResponseLiquidityAvailable = false
)

// Defines values for TransferSourceType.
const (
	TransferSourceTypePaymentMethod TransferSourceType = "payment_method"
)

// Defines values for TransferStatus.
const (
	TransferStatusCompleted TransferStatus = "completed"
	TransferStatusCreated   TransferStatus = "created"
	TransferStatusFailed    TransferStatus = "failed"
	TransferStatusPending   TransferStatus = "pending"
	TransferStatusStarted   TransferStatus = "started"
)

// Defines values for TransferTargetType.
const (
	TransferTargetTypeCryptoRail TransferTargetType = "crypto_rail"
)

// Defines values for SendEvmTransactionJSONBodyNetwork.
const (
	SendEvmTransactionJSONBodyNetworkBase            SendEvmTransactionJSONBodyNetwork = "base"
	SendEvmTransactionJSONBodyNetworkBaseSepolia     SendEvmTransactionJSONBodyNetwork = "base-sepolia"
	SendEvmTransactionJSONBodyNetworkEthereum        SendEvmTransactionJSONBodyNetwork = "ethereum"
	SendEvmTransactionJSONBodyNetworkEthereumSepolia SendEvmTransactionJSONBodyNetwork = "ethereum-sepolia"
)

// Defines values for RequestEvmFaucetJSONBodyNetwork.
const (
	RequestEvmFaucetJSONBodyNetworkBaseSepolia     RequestEvmFaucetJSONBodyNetwork = "base-sepolia"
	RequestEvmFaucetJSONBodyNetworkEthereumHoodi   RequestEvmFaucetJSONBodyNetwork = "ethereum-hoodi"
	RequestEvmFaucetJSONBodyNetworkEthereumSepolia RequestEvmFaucetJSONBodyNetwork = "ethereum-sepolia"
)

// Defines values for RequestEvmFaucetJSONBodyToken.
const (
	RequestEvmFaucetJSONBodyTokenCbbtc RequestEvmFaucetJSONBodyToken = "cbbtc"
	RequestEvmFaucetJSONBodyTokenEth   RequestEvmFaucetJSONBodyToken = "eth"
	RequestEvmFaucetJSONBodyTokenEurc  RequestEvmFaucetJSONBodyToken = "eurc"
	RequestEvmFaucetJSONBodyTokenUsdc  RequestEvmFaucetJSONBodyToken = "usdc"
)

// Defines values for PrepareUserOperationJSONBodyNetwork.
const (
	Base        PrepareUserOperationJSONBodyNetwork = "base"
	BaseSepolia PrepareUserOperationJSONBodyNetwork = "base-sepolia"
)

// Defines values for CreatePaymentTransferQuoteJSONBodySourceType.
const (
	CreatePaymentTransferQuoteJSONBodySourceTypePaymentMethod CreatePaymentTransferQuoteJSONBodySourceType = "payment_method"
)

// Defines values for CreatePaymentTransferQuoteJSONBodyTargetType.
const (
	CreatePaymentTransferQuoteJSONBodyTargetTypeCryptoRail CreatePaymentTransferQuoteJSONBodyTargetType = "crypto_rail"
)

// Defines values for ListPoliciesParamsScope.
const (
	ListPoliciesParamsScopeAccount ListPoliciesParamsScope = "account"
	ListPoliciesParamsScopeProject ListPoliciesParamsScope = "project"
)

// Defines values for CreatePolicyJSONBodyScope.
const (
	Account CreatePolicyJSONBodyScope = "account"
	Project CreatePolicyJSONBodyScope = "project"
)

// Defines values for RequestSolanaFaucetJSONBodyToken.
const (
	RequestSolanaFaucetJSONBodyTokenSol  RequestSolanaFaucetJSONBodyToken = "sol"
	RequestSolanaFaucetJSONBodyTokenUsdc RequestSolanaFaucetJSONBodyToken = "usdc"
)

// Abi Contract ABI Specification following Solidity's external JSON interface format.
type Abi = []Abi_Item

// Abi_Item defines model for Abi.Item.
type Abi_Item struct {
	union json.RawMessage
}

// AbiFunction ABI function type for contract functions.
type AbiFunction struct {
	// Constant Deprecated. Use pure or view from stateMutability instead.
	Constant *bool `json:"constant,omitempty"`

	// Gas Deprecated. Vyper used to provide gas estimates.
	Gas *int `json:"gas,omitempty"`

	// Inputs The list of ABI parameters used for this function.
	Inputs []AbiParameter `json:"inputs"`

	// Name The name of the ABI function.
	Name string `json:"name"`

	// Outputs The values returned by this function.
	Outputs []AbiParameter `json:"outputs"`

	// Payable Deprecated. Use payable or nonpayable from `stateMutability` instead.
	Payable *bool `json:"payable,omitempty"`

	// StateMutability State mutability of a function in Solidity.
	StateMutability AbiStateMutability `json:"stateMutability"`

	// Type The type of the ABI item, must be `function`.
	Type AbiFunctionType `json:"type"`
}

// AbiFunctionType The type of the ABI item, must be `function`.
type AbiFunctionType string

// AbiInput Generic ABI item type encapsulating all other types besides `function`.
type AbiInput struct {
	// AdditionalProperties For additional information on the ABI JSON specification, see [the Solidity documentation](https://docs.soliditylang.org/en/latest/abi-spec.html#json).
	AdditionalProperties *interface{} `json:"additionalProperties,omitempty"`

	// Type The type of the ABI item.
	Type AbiInputType `json:"type"`
}

// AbiInputType The type of the ABI item.
type AbiInputType string

// AbiParameter Parameter definition for ABI functions, errors, and constructors.
type AbiParameter struct {
	// Components Used for tuple types.
	Components *[]AbiParameter `json:"components,omitempty"`

	// InternalType The internal Solidity type used by the compiler.
	InternalType *string `json:"internalType,omitempty"`

	// Name The name of the parameter.
	Name *string `json:"name,omitempty"`

	// Type The canonical type of the parameter.
	Type string `json:"type"`
}

// AbiStateMutability State mutability of a function in Solidity.
type AbiStateMutability string

// CommonSwapResponse defines model for CommonSwapResponse.
type CommonSwapResponse struct {
	// BlockNumber The block number at which the liquidity conditions were examined.
	BlockNumber string `json:"blockNumber"`

	// Fees The estimated fees for the swap.
	Fees struct {
		// GasFee The estimated gas fee for the swap.
		GasFee *TokenFee `json:"gasFee"`

		// ProtocolFee The estimated protocol fee for the swap.
		ProtocolFee *TokenFee `json:"protocolFee"`
	} `json:"fees"`

	// FromAmount The amount of the `fromToken` that will be sent in this swap, in atomic units of the `fromToken`. For example, `1000000000000000000` when sending ETH equates to 1 ETH, `1000000` when sending USDC equates to 1 USDC, etc.
	FromAmount string `json:"fromAmount"`

	// FromToken The 0x-prefixed contract address of the token that will be sent.
	FromToken string `json:"fromToken"`

	// Issues An object containing potential issues discovered during validation that could prevent the swap from being executed successfully.
	Issues struct {
		// Allowance Details of the allowances that the taker must set in order to execute the swap successfully. Null if no allowance is required.
		Allowance *struct {
			// CurrentAllowance The current allowance of the `fromToken` by the `taker`.
			CurrentAllowance string `json:"currentAllowance"`

			// Spender The 0x-prefixed address of to set the allowance on.
			Spender string `json:"spender"`
		} `json:"allowance"`

		// Balance Details of the balance of the `fromToken` that the `taker` must hold. Null if the `taker` has a sufficient balance.
		Balance *struct {
			// CurrentBalance The current balance of the `fromToken` by the `taker`.
			CurrentBalance string `json:"currentBalance"`

			// RequiredBalance The amount of the token that the `taker` must hold.
			RequiredBalance string `json:"requiredBalance"`

			// Token The 0x-prefixed contract address of the token.
			Token string `json:"token"`
		} `json:"balance"`

		// SimulationIncomplete This is set to true when the transaction cannot be validated. This can happen when the taker has an insufficient balance of the `fromToken`. Note that this does not necessarily mean that the trade will revert.
		SimulationIncomplete bool `json:"simulationIncomplete"`
	} `json:"issues"`

	// LiquidityAvailable Whether sufficient liquidity is available to settle the swap. All other fields in the response will be empty if this is false.
	LiquidityAvailable CommonSwapResponseLiquidityAvailable `json:"liquidityAvailable"`

	// MinToAmount The minimum amount of the `toToken` that must be received for the swap to succeed, in atomic units of the `toToken`.  For example, `1000000000000000000` when receiving ETH equates to 1 ETH, `1000000` when receiving USDC equates to 1 USDC, etc. This value is influenced by the `slippageBps` parameter.
	MinToAmount string `json:"minToAmount"`

	// ToAmount The amount of the `toToken` that will be received in atomic units of the `toToken`. For example, `1000000000000000000` when receiving ETH equates to 1 ETH, `1000000` when receiving USDC equates to 1 USDC, etc.
	ToAmount string `json:"toAmount"`

	// ToToken The 0x-prefixed contract address of the token that will be received.
	ToToken string `json:"toToken"`
}

// CommonSwapResponseLiquidityAvailable Whether sufficient liquidity is available to settle the swap. All other fields in the response will be empty if this is false.
type CommonSwapResponseLiquidityAvailable bool

// CreateSwapQuoteResponse defines model for CreateSwapQuoteResponse.
type CreateSwapQuoteResponse struct {
	// BlockNumber The block number at which the liquidity conditions were examined.
	BlockNumber string `json:"blockNumber"`

	// Fees The estimated fees for the swap.
	Fees struct {
		// GasFee The estimated gas fee for the swap.
		GasFee *TokenFee `json:"gasFee"`

		// ProtocolFee The estimated protocol fee for the swap.
		ProtocolFee *TokenFee `json:"protocolFee"`
	} `json:"fees"`

	// FromAmount The amount of the `fromToken` that will be sent in this swap, in atomic units of the `fromToken`. For example, `1000000000000000000` when sending ETH equates to 1 ETH, `1000000` when sending USDC equates to 1 USDC, etc.
	FromAmount string `json:"fromAmount"`

	// FromToken The 0x-prefixed contract address of the token that will be sent.
	FromToken string `json:"fromToken"`

	// Issues An object containing potential issues discovered during validation that could prevent the swap from being executed successfully.
	Issues struct {
		// Allowance Details of the allowances that the taker must set in order to execute the swap successfully. Null if no allowance is required.
		Allowance *struct {
			// CurrentAllowance The current allowance of the `fromToken` by the `taker`.
			CurrentAllowance string `json:"currentAllowance"`

			// Spender The 0x-prefixed address of to set the allowance on.
			Spender string `json:"spender"`
		} `json:"allowance"`

		// Balance Details of the balance of the `fromToken` that the `taker` must hold. Null if the `taker` has a sufficient balance.
		Balance *struct {
			// CurrentBalance The current balance of the `fromToken` by the `taker`.
			CurrentBalance string `json:"currentBalance"`

			// RequiredBalance The amount of the token that the `taker` must hold.
			RequiredBalance string `json:"requiredBalance"`

			// Token The 0x-prefixed contract address of the token.
			Token string `json:"token"`
		} `json:"balance"`

		// SimulationIncomplete This is set to true when the transaction cannot be validated. This can happen when the taker has an insufficient balance of the `fromToken`. Note that this does not necessarily mean that the trade will revert.
		SimulationIncomplete bool `json:"simulationIncomplete"`
	} `json:"issues"`

	// LiquidityAvailable Whether sufficient liquidity is available to settle the swap. All other fields in the response will be empty if this is false.
	LiquidityAvailable CreateSwapQuoteResponseLiquidityAvailable `json:"liquidityAvailable"`

	// MinToAmount The minimum amount of the `toToken` that must be received for the swap to succeed, in atomic units of the `toToken`.  For example, `1000000000000000000` when receiving ETH equates to 1 ETH, `1000000` when receiving USDC equates to 1 USDC, etc. This value is influenced by the `slippageBps` parameter.
	MinToAmount string `json:"minToAmount"`

	// Permit2 The approval object which contains the necessary fields to submit an approval for this transaction. Null if the `fromToken` is the native token or the transaction is a native token wrap / unwrap.
	Permit2 *struct {
		// Eip712 The message to sign using EIP-712.
		Eip712 EIP712Message `json:"eip712"`

		// Hash The hash for the approval according to [EIP-712](https://eips.ethereum.org/EIPS/eip-712). Computing the hash of the `eip712` field should match the value of this field.
		Hash string `json:"hash"`
	} `json:"permit2"`

	// ToAmount The amount of the `toToken` that will be received in atomic units of the `toToken`. For example, `1000000000000000000` when receiving ETH equates to 1 ETH, `1000000` when receiving USDC equates to 1 USDC, etc.
	ToAmount string `json:"toAmount"`

	// ToToken The 0x-prefixed contract address of the token that will be received.
	ToToken string `json:"toToken"`

	// Transaction The details of the transaction to be signed and submitted to execute the swap.
	Transaction struct {
		// Data The hex-encoded call data to send to the contract.
		Data string `json:"data"`

		// Gas The estimated gas limit that should be used to send the transaction to guarantee settlement.
		Gas string `json:"gas"`

		// GasPrice The gas price, in Wei, that should be used to send the transaction. For EIP-1559 transactions, this value should be seen as the `maxFeePerGas` value. The transaction should be sent with this gas price to guarantee settlement.
		GasPrice string `json:"gasPrice"`

		// To The 0x-prefixed address of the contract to call.
		To string `json:"to"`

		// Value The value of the transaction in Wei.
		Value string `json:"value"`
	} `json:"transaction"`
}

// CreateSwapQuoteResponseLiquidityAvailable Whether sufficient liquidity is available to settle the swap. All other fields in the response will be empty if this is false.
type CreateSwapQuoteResponseLiquidityAvailable bool

// CreateSwapQuoteResponseWrapper A wrapper for the response of a swap quote operation.
type CreateSwapQuoteResponseWrapper struct {
	union json.RawMessage
}

// CryptoRail The crypto rails available.
type CryptoRail struct {
	// Actions The actions for the crypto rail.
	Actions []PaymentRailAction `json:"actions"`

	// Currency The currency symbol of the asset.
	Currency string `json:"currency"`

	// Name The name of the asset.
	Name string `json:"name"`

	// Networks All available networks of the asset.
	Networks []struct {
		// ChainId The chain ID of the network.
		ChainId *int64 `json:"chainId,omitempty"`

		// ContractAddress The contract address of the asset on the network.
		ContractAddress *string `json:"contractAddress,omitempty"`

		// Name The name of the network.
		Name *string `json:"name,omitempty"`
	} `json:"networks"`
}

// CryptoRailAddress The crypto rail input object which specifies the symbol, network, and address which is the source or destination wallet address.
type CryptoRailAddress struct {
	// Address The address of the payment rail. This is the source or destination wallet address. It is not a contract address.
	Address string `json:"address"`

	// Currency The symbol of the currency of the payment rail.
	Currency string `json:"currency"`

	// Network The network of the payment rail.
	Network string `json:"network"`
}

// EIP712Domain The domain of the EIP-712 typed data.
type EIP712Domain struct {
	// ChainId The chain ID of the EVM network.
	ChainId *int64 `json:"chainId,omitempty"`

	// Name The name of the DApp or protocol.
	Name *string `json:"name,omitempty"`

	// Salt The optional 32-byte 0x-prefixed hex salt for domain separation.
	Salt *string `json:"salt,omitempty"`

	// VerifyingContract The 0x-prefixed EVM address of the verifying smart contract.
	VerifyingContract *string `json:"verifyingContract,omitempty"`

	// Version The version of the DApp or protocol.
	Version *string `json:"version,omitempty"`
}

// EIP712Message The message to sign using EIP-712.
type EIP712Message struct {
	// Domain The domain of the EIP-712 typed data.
	Domain EIP712Domain `json:"domain"`

	// Message The message to sign. The structure of this message must match the `primaryType` struct in the `types` object.
	Message map[string]interface{} `json:"message"`

	// PrimaryType The primary type of the message. This is the name of the struct in the `types` object that is the root of the message.
	PrimaryType string `json:"primaryType"`

	// Types A mapping of struct names to an array of type objects (name + type).
	// Each key corresponds to a type name (e.g., "`EIP712Domain`", "`PermitTransferFrom`").
	Types EIP712Types `json:"types"`
}

// EIP712Types A mapping of struct names to an array of type objects (name + type).
// Each key corresponds to a type name (e.g., "`EIP712Domain`", "`PermitTransferFrom`").
type EIP712Types = map[string]interface{}

// Error An error response including the code for the type of error and a human-readable message describing the error.
type Error struct {
	// CorrelationId A unique identifier for the request that generated the error. This can be used to help debug issues with the API.
	CorrelationId *string `json:"correlationId,omitempty"`

	// ErrorLink A link to the corresponding error documentation.
	ErrorLink *string `json:"errorLink,omitempty"`

	// ErrorMessage The error message.
	ErrorMessage string `json:"errorMessage"`

	// ErrorType The code that indicates the type of error that occurred. These error codes can be used to determine how to handle the error.
	ErrorType ErrorType `json:"errorType"`
}

// ErrorType The code that indicates the type of error that occurred. These error codes can be used to determine how to handle the error.
type ErrorType string

// EthValueCriterion A schema for specifying a criterion for the `value` field of an EVM transaction.
type EthValueCriterion struct {
	// EthValue The amount of ETH, in wei, that the transaction's `value` field should be compared to.
	EthValue string `json:"ethValue"`

	// Operator The operator to use for the comparison. The transaction's `value` field will be on the left-hand side of the operator, and the `ethValue` field will be on the right-hand side.
	Operator EthValueCriterionOperator `json:"operator"`

	// Type The type of criterion to use. This should be `ethValue`.
	Type EthValueCriterionType `json:"type"`
}

// EthValueCriterionOperator The operator to use for the comparison. The transaction's `value` field will be on the left-hand side of the operator, and the `ethValue` field will be on the right-hand side.
type EthValueCriterionOperator string

// EthValueCriterionType The type of criterion to use. This should be `ethValue`.
type EthValueCriterionType string

// EvmAccount defines model for EvmAccount.
type EvmAccount struct {
	// Address The 0x-prefixed, checksum EVM address.
	Address string `json:"address"`

	// CreatedAt The UTC ISO 8601 timestamp at which the account was created.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Name An optional name for the account.
	// Account names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.
	// Account names are guaranteed to be unique across all EVM accounts in the developer's CDP Project.
	Name *string `json:"name,omitempty"`

	// Policies The list of policy IDs that apply to the account. This will include both the project-level policy and the account-level policy, if one exists.
	Policies *[]string `json:"policies,omitempty"`

	// UpdatedAt The UTC ISO 8601 timestamp at which the account was last updated.
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
}

// EvmAddressCriterion A schema for specifying a criterion for the `to` field of an EVM transaction.
type EvmAddressCriterion struct {
	// Addresses A list of 0x-prefixed EVM addresses that the transaction's `to` field should be compared to. There is a limit of 100 addresses per criterion.
	Addresses []string `json:"addresses"`

	// Operator The operator to use for the comparison. The transaction's `to` field will be on the left-hand side of the operator, and the `addresses` field will be on the right-hand side.
	Operator EvmAddressCriterionOperator `json:"operator"`

	// Type The type of criterion to use. This should be `evmAddress`.
	Type EvmAddressCriterionType `json:"type"`
}

// EvmAddressCriterionOperator The operator to use for the comparison. The transaction's `to` field will be on the left-hand side of the operator, and the `addresses` field will be on the right-hand side.
type EvmAddressCriterionOperator string

// EvmAddressCriterionType The type of criterion to use. This should be `evmAddress`.
type EvmAddressCriterionType string

// EvmCall defines model for EvmCall.
type EvmCall struct {
	// Data The call data to send. This is the hex-encoded data of the function call consisting of the method selector and the function arguments.
	Data string `json:"data"`

	// To The address the call is directed to.
	To string `json:"to"`

	// Value The amount of ETH to send with the call, in wei.
	Value string `json:"value"`
}

// EvmDataCondition A single condition to apply against the function and encoded arguments in the transaction's `data` field. Each `parameter` configuration must be successfully evaluated against the corresponding function argument in order for a policy to be accepted.
type EvmDataCondition struct {
	// Function The name of a smart contract function being called.
	Function string `json:"function"`

	// Params An optional list of parameter conditions to apply against encoded arguments in the transaction's `data` field.
	Params *[]EvmDataCondition_Params_Item `json:"params,omitempty"`
}

// EvmDataCondition_Params_Item A list of parameter conditions to apply against encoded arguments in the transaction's `data` field.
type EvmDataCondition_Params_Item struct {
	union json.RawMessage
}

// EvmDataCriterion A schema for specifying a criterion for the `data` field of an EVM transaction.
type EvmDataCriterion struct {
	// Abi The ABI of the smart contract being called. This can be a partial structure with only specific functions.
	Abi EvmDataCriterion_Abi `json:"abi"`

	// Conditions A list of conditions to apply against the function and encoded arguments in the transaction's `data` field. Each condition must be met in order for this policy to be accepted or rejected.
	Conditions []EvmDataCondition `json:"conditions"`

	// Type The type of criterion to use. This should be `evmData`.
	Type EvmDataCriterionType `json:"type"`
}

// EvmDataCriterion_Abi The ABI of the smart contract being called. This can be a partial structure with only specific functions.
type EvmDataCriterion_Abi struct {
	union json.RawMessage
}

// EvmDataCriterionType The type of criterion to use. This should be `evmData`.
type EvmDataCriterionType string

// EvmDataParameterCondition defines model for EvmDataParameterCondition.
type EvmDataParameterCondition struct {
	// Name The name of the parameter to check against a transaction's calldata. If name is unknown, or is not named, you may supply an array index, e.g., `0` for first parameter.
	Name string `json:"name"`

	// Operator The operator to use for the comparison. The value resolved at the `name` will be on the left-hand side of the operator, and the `value` field will be on the right-hand side.
	Operator EvmDataParameterConditionOperator `json:"operator"`

	// Value A single value to compare the value resolved at `name` to. All values are encoded as strings. Refer to the table in the documentation for how values should be encoded, and which operators are supported for each type.
	Value string `json:"value"`
}

// EvmDataParameterConditionOperator The operator to use for the comparison. The value resolved at the `name` will be on the left-hand side of the operator, and the `value` field will be on the right-hand side.
type EvmDataParameterConditionOperator string

// EvmDataParameterConditionList defines model for EvmDataParameterConditionList.
type EvmDataParameterConditionList struct {
	// Name The name of the parameter to check against a transaction's calldata. If name is unknown, or is not named, you may supply an array index, e.g., `0` for first parameter.
	Name string `json:"name"`

	// Operator The operator to use for the comparison. The value resolved at the `name` will be on the left-hand side of the operator, and the `values` field will be on the right-hand side.
	Operator EvmDataParameterConditionListOperator `json:"operator"`

	// Values Values to compare against the resolved `name` value. All values are encoded as strings. Refer to the table in the documentation for how values should be encoded, and which operators are supported for each type.
	Values []string `json:"values"`
}

// EvmDataParameterConditionListOperator The operator to use for the comparison. The value resolved at the `name` will be on the left-hand side of the operator, and the `values` field will be on the right-hand side.
type EvmDataParameterConditionListOperator string

// EvmMessageCriterion A schema for specifying a criterion for the message being signed.
type EvmMessageCriterion struct {
	// Match A regular expression the message is matched against. Accepts valid regular expression syntax described by [RE2](https://github.com/google/re2/wiki/Syntax).
	Match string `json:"match"`

	// Type The type of criterion to use. This should be `evmMessage`.
	Type EvmMessageCriterionType `json:"type"`
}

// EvmMessageCriterionType The type of criterion to use. This should be `evmMessage`.
type EvmMessageCriterionType string

// EvmNetworkCriterion A schema for specifying a criterion for the intended `network` of an EVM transaction.
type EvmNetworkCriterion struct {
	// Networks A list of EVM network identifiers that the transaction's intended `network` should be compared to.
	Networks []EvmNetworkCriterionNetworks `json:"networks"`

	// Operator The operator to use for the comparison. The transaction's intended `network` will be on the left-hand side of the operator, and the `networks` field will be on the right-hand side.
	Operator EvmNetworkCriterionOperator `json:"operator"`

	// Type The type of criterion to use. This should be `evmNetwork`.
	Type EvmNetworkCriterionType `json:"type"`
}

// EvmNetworkCriterionNetworks The network the transaction is for.
type EvmNetworkCriterionNetworks string

// EvmNetworkCriterionOperator The operator to use for the comparison. The transaction's intended `network` will be on the left-hand side of the operator, and the `networks` field will be on the right-hand side.
type EvmNetworkCriterionOperator string

// EvmNetworkCriterionType The type of criterion to use. This should be `evmNetwork`.
type EvmNetworkCriterionType string

// EvmSmartAccount defines model for EvmSmartAccount.
type EvmSmartAccount struct {
	// Address The 0x-prefixed, checksum address of the Smart Account.
	Address string `json:"address"`

	// CreatedAt The UTC ISO 8601 timestamp at which the account was created.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Name An optional name for the account.
	// Account names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.
	// Account names are guaranteed to be unique across all Smart Accounts in the developer's CDP Project.
	Name *string `json:"name,omitempty"`

	// Owners Today, only a single owner can be set for a Smart Account, but this is an array to allow having multiple owners in the future. The address is a 0x-prefixed, checksum address.
	Owners []string `json:"owners"`

	// UpdatedAt The UTC ISO 8601 timestamp at which the account was last updated.
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
}

// EvmSwapsNetwork The network on which to perform the swap.
type EvmSwapsNetwork string

// EvmUserOperation defines model for EvmUserOperation.
type EvmUserOperation struct {
	// Calls The list of calls in the user operation.
	Calls []EvmCall `json:"calls"`

	// Network The network the user operation is for.
	Network EvmUserOperationNetwork `json:"network"`

	// Status The status of the user operation.
	Status EvmUserOperationStatus `json:"status"`

	// TransactionHash The hash of the transaction that included this particular user operation. This gets set after the user operation is broadcasted and the transaction is included in a block.
	TransactionHash *string `json:"transactionHash,omitempty"`

	// UserOpHash The hash of the user operation. This is not the transaction hash, as a transaction consists of multiple user operations. The user operation hash is the hash of this particular user operation which gets signed by the owner of the Smart Account.
	UserOpHash string `json:"userOpHash"`
}

// EvmUserOperationNetwork The network the user operation is for.
type EvmUserOperationNetwork string

// EvmUserOperationStatus The status of the user operation.
type EvmUserOperationStatus string

// Fee The fee for the transfer.
type Fee struct {
	// Amount The amount of the fee.
	Amount string `json:"amount"`

	// Currency The currency of the fee.
	Currency string `json:"currency"`

	// Description The description of the fee.
	Description *string `json:"description,omitempty"`

	// Type The type of fee.
	Type FeeType `json:"type"`
}

// FeeType The type of fee.
type FeeType string

// GetSwapPriceResponse defines model for GetSwapPriceResponse.
type GetSwapPriceResponse struct {
	// BlockNumber The block number at which the liquidity conditions were examined.
	BlockNumber string `json:"blockNumber"`

	// Fees The estimated fees for the swap.
	Fees struct {
		// GasFee The estimated gas fee for the swap.
		GasFee *TokenFee `json:"gasFee"`

		// ProtocolFee The estimated protocol fee for the swap.
		ProtocolFee *TokenFee `json:"protocolFee"`
	} `json:"fees"`

	// FromAmount The amount of the `fromToken` that will be sent in this swap, in atomic units of the `fromToken`. For example, `1000000000000000000` when sending ETH equates to 1 ETH, `1000000` when sending USDC equates to 1 USDC, etc.
	FromAmount string `json:"fromAmount"`

	// FromToken The 0x-prefixed contract address of the token that will be sent.
	FromToken string `json:"fromToken"`

	// Gas The estimated gas limit that should be used to send the transaction to guarantee settlement.
	Gas *string `json:"gas"`

	// GasPrice The gas price, in Wei, that should be used to send the transaction. For EIP-1559 transactions, this value should be seen as the `maxFeePerGas` value. The transaction should be sent with this gas price to guarantee settlement.
	GasPrice string `json:"gasPrice"`

	// Issues An object containing potential issues discovered during validation that could prevent the swap from being executed successfully.
	Issues struct {
		// Allowance Details of the allowances that the taker must set in order to execute the swap successfully. Null if no allowance is required.
		Allowance *struct {
			// CurrentAllowance The current allowance of the `fromToken` by the `taker`.
			CurrentAllowance string `json:"currentAllowance"`

			// Spender The 0x-prefixed address of to set the allowance on.
			Spender string `json:"spender"`
		} `json:"allowance"`

		// Balance Details of the balance of the `fromToken` that the `taker` must hold. Null if the `taker` has a sufficient balance.
		Balance *struct {
			// CurrentBalance The current balance of the `fromToken` by the `taker`.
			CurrentBalance string `json:"currentBalance"`

			// RequiredBalance The amount of the token that the `taker` must hold.
			RequiredBalance string `json:"requiredBalance"`

			// Token The 0x-prefixed contract address of the token.
			Token string `json:"token"`
		} `json:"balance"`

		// SimulationIncomplete This is set to true when the transaction cannot be validated. This can happen when the taker has an insufficient balance of the `fromToken`. Note that this does not necessarily mean that the trade will revert.
		SimulationIncomplete bool `json:"simulationIncomplete"`
	} `json:"issues"`

	// LiquidityAvailable Whether sufficient liquidity is available to settle the swap. All other fields in the response will be empty if this is false.
	LiquidityAvailable GetSwapPriceResponseLiquidityAvailable `json:"liquidityAvailable"`

	// MinToAmount The minimum amount of the `toToken` that must be received for the swap to succeed, in atomic units of the `toToken`.  For example, `1000000000000000000` when receiving ETH equates to 1 ETH, `1000000` when receiving USDC equates to 1 USDC, etc. This value is influenced by the `slippageBps` parameter.
	MinToAmount string `json:"minToAmount"`

	// ToAmount The amount of the `toToken` that will be received in atomic units of the `toToken`. For example, `1000000000000000000` when receiving ETH equates to 1 ETH, `1000000` when receiving USDC equates to 1 USDC, etc.
	ToAmount string `json:"toAmount"`

	// ToToken The 0x-prefixed contract address of the token that will be received.
	ToToken string `json:"toToken"`
}

// GetSwapPriceResponseLiquidityAvailable Whether sufficient liquidity is available to settle the swap. All other fields in the response will be empty if this is false.
type GetSwapPriceResponseLiquidityAvailable bool

// GetSwapPriceResponseWrapper A wrapper for the response of a swap price operation.
type GetSwapPriceResponseWrapper struct {
	union json.RawMessage
}

// KnownAbiType A reference to an established EIP standard. When referencing a `KnownAbiType` within a policy rule configuring an `EvmDataCriterion`, criteria will only decode function data officially documented in the standard. For more information on supported token standards, see the links below.
//   - [erc20 - Token Standard](https://eips.ethereum.org/EIPS/eip-20).
//   - [erc721 - Non-Fungible Token Standard](https://eips.ethereum.org/EIPS/eip-721).
//   - [erc1155 - Multi Token Standard](https://eips.ethereum.org/EIPS/eip-1155).
type KnownAbiType string

// ListEvmTokenBalancesNetwork The name of the supported EVM networks in human-readable format.
type ListEvmTokenBalancesNetwork string

// ListResponse defines model for ListResponse.
type ListResponse struct {
	// NextPageToken The token for the next page of items, if any.
	NextPageToken *string `json:"nextPageToken,omitempty"`
}

// PaymentMethod The fiat payment method object.
type PaymentMethod struct {
	// Actions The actions for the payment method.
	Actions []PaymentRailAction `json:"actions"`

	// Currency The currency of the payment method.
	Currency string `json:"currency"`

	// Id The ID of the payment method which previously was added.
	Id string `json:"id"`

	// Limits The limits of the payment method.
	Limits *struct {
		// SourceLimit The limit for this payment method being used as a source for transfers.
		SourceLimit *struct {
			// Amount The amount of the limit.
			Amount *string `json:"amount,omitempty"`

			// Currency The currency of the limit.
			Currency *string `json:"currency,omitempty"`
		} `json:"sourceLimit,omitempty"`

		// TargetLimit The limit for this payment method being used as a target for transfers.
		TargetLimit *struct {
			// Amount The amount of the limit.
			Amount *string `json:"amount,omitempty"`

			// Currency The currency of the limit.
			Currency *string `json:"currency,omitempty"`
		} `json:"targetLimit,omitempty"`
	} `json:"limits,omitempty"`

	// Type The type of payment method.
	Type PaymentMethodType `json:"type"`
}

// PaymentMethodType The type of payment method.
type PaymentMethodType string

// PaymentMethodRequest The fiat payment method request object.
type PaymentMethodRequest struct {
	// Id The ID of the payment method.
	Id string `json:"id"`
}

// PaymentRailAction The action of the payment method.
type PaymentRailAction string

// Policy defines model for Policy.
type Policy struct {
	// CreatedAt The ISO 8601 timestamp at which the Policy was created.
	CreatedAt string `json:"createdAt"`

	// Description An optional human-readable description of the policy.
	// Policy descriptions can consist of alphanumeric characters, spaces, commas, and periods, and be 50 characters or less.
	Description *string `json:"description,omitempty"`

	// Id The unique identifier for the policy.
	Id string `json:"id"`

	// Rules A list of rules that comprise the policy.
	Rules []Rule `json:"rules"`

	// Scope The scope of the policy. Only one project-level policy can exist at any time.
	Scope PolicyScope `json:"scope"`

	// UpdatedAt The ISO 8601 timestamp at which the Policy was last updated.
	UpdatedAt string `json:"updatedAt"`
}

// PolicyScope The scope of the policy. Only one project-level policy can exist at any time.
type PolicyScope string

// Rule A rule that limits the behavior of an account.
type Rule struct {
	union json.RawMessage
}

// SendEvmTransactionCriteria A schema for specifying criteria for the SignEvmTransaction operation.
type SendEvmTransactionCriteria = []SendEvmTransactionCriteria_Item

// SendEvmTransactionCriteria_Item defines model for SendEvmTransactionCriteria.Item.
type SendEvmTransactionCriteria_Item struct {
	union json.RawMessage
}

// SendEvmTransactionRule defines model for SendEvmTransactionRule.
type SendEvmTransactionRule struct {
	// Action Whether matching the rule will cause the request to be rejected or accepted.
	Action SendEvmTransactionRuleAction `json:"action"`

	// Criteria A schema for specifying criteria for the SignEvmTransaction operation.
	Criteria SendEvmTransactionCriteria `json:"criteria"`

	// Operation The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.
	Operation SendEvmTransactionRuleOperation `json:"operation"`
}

// SendEvmTransactionRuleAction Whether matching the rule will cause the request to be rejected or accepted.
type SendEvmTransactionRuleAction string

// SendEvmTransactionRuleOperation The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.
type SendEvmTransactionRuleOperation string

// SignEvmHashRule defines model for SignEvmHashRule.
type SignEvmHashRule struct {
	// Action Whether any attempts to sign a hash will be accepted or rejected. This rule does not accept any criteria.
	Action SignEvmHashRuleAction `json:"action"`

	// Operation The operation to which the rule applies.
	Operation SignEvmHashRuleOperation `json:"operation"`
}

// SignEvmHashRuleAction Whether any attempts to sign a hash will be accepted or rejected. This rule does not accept any criteria.
type SignEvmHashRuleAction string

// SignEvmHashRuleOperation The operation to which the rule applies.
type SignEvmHashRuleOperation string

// SignEvmMessageCriteria A schema for specifying the rejection criteria for the SignEvmMessage operation.
type SignEvmMessageCriteria = []SignEvmMessageCriteria_Item

// SignEvmMessageCriteria_Item defines model for SignEvmMessageCriteria.Item.
type SignEvmMessageCriteria_Item struct {
	union json.RawMessage
}

// SignEvmMessageRule defines model for SignEvmMessageRule.
type SignEvmMessageRule struct {
	// Action Whether matching the rule will cause the request to be rejected or accepted.
	Action SignEvmMessageRuleAction `json:"action"`

	// Criteria A schema for specifying the rejection criteria for the SignEvmMessage operation.
	Criteria SignEvmMessageCriteria `json:"criteria"`

	// Operation The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.
	Operation SignEvmMessageRuleOperation `json:"operation"`
}

// SignEvmMessageRuleAction Whether matching the rule will cause the request to be rejected or accepted.
type SignEvmMessageRuleAction string

// SignEvmMessageRuleOperation The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.
type SignEvmMessageRuleOperation string

// SignEvmTransactionCriteria A schema for specifying criteria for the SignEvmTransaction operation.
type SignEvmTransactionCriteria = []SignEvmTransactionCriteria_Item

// SignEvmTransactionCriteria_Item defines model for SignEvmTransactionCriteria.Item.
type SignEvmTransactionCriteria_Item struct {
	union json.RawMessage
}

// SignEvmTransactionRule defines model for SignEvmTransactionRule.
type SignEvmTransactionRule struct {
	// Action Whether matching the rule will cause the request to be rejected or accepted.
	Action SignEvmTransactionRuleAction `json:"action"`

	// Criteria A schema for specifying criteria for the SignEvmTransaction operation.
	Criteria SignEvmTransactionCriteria `json:"criteria"`

	// Operation The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.
	Operation SignEvmTransactionRuleOperation `json:"operation"`
}

// SignEvmTransactionRuleAction Whether matching the rule will cause the request to be rejected or accepted.
type SignEvmTransactionRuleAction string

// SignEvmTransactionRuleOperation The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.
type SignEvmTransactionRuleOperation string

// SignSolTransactionCriteria A schema for specifying criteria for the SignSolTransaction operation.
type SignSolTransactionCriteria = []SignSolTransactionCriteria_Item

// SignSolTransactionCriteria_Item defines model for SignSolTransactionCriteria.Item.
type SignSolTransactionCriteria_Item struct {
	union json.RawMessage
}

// SignSolTransactionRule defines model for SignSolTransactionRule.
type SignSolTransactionRule struct {
	// Action Whether matching the rule will cause the request to be rejected or accepted.
	Action SignSolTransactionRuleAction `json:"action"`

	// Criteria A schema for specifying criteria for the SignSolTransaction operation.
	Criteria SignSolTransactionCriteria `json:"criteria"`

	// Operation The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.
	Operation SignSolTransactionRuleOperation `json:"operation"`
}

// SignSolTransactionRuleAction Whether matching the rule will cause the request to be rejected or accepted.
type SignSolTransactionRuleAction string

// SignSolTransactionRuleOperation The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.
type SignSolTransactionRuleOperation string

// SolAddressCriterion The criterion for the recipient addresses of a Solana transaction.
type SolAddressCriterion struct {
	// Addresses The Solana addresses that are compared to the list of addresses in the transaction's `accountKeys` (for legacy transactions) or `staticAccountKeys` (for V0 transactions) array.
	Addresses []string `json:"addresses"`

	// Operator The operator to use for the comparison. Each of the addresses in the transaction's `accountKeys` (for legacy transactions) or `staticAccountKeys` (for V0 transactions) array will be on the left-hand side of the operator, and the addresses field will be on the right-hand side.
	Operator SolAddressCriterionOperator `json:"operator"`

	// Type The type of criterion to use. This should be `solAddress`.
	Type SolAddressCriterionType `json:"type"`
}

// SolAddressCriterionOperator The operator to use for the comparison. Each of the addresses in the transaction's `accountKeys` (for legacy transactions) or `staticAccountKeys` (for V0 transactions) array will be on the left-hand side of the operator, and the addresses field will be on the right-hand side.
type SolAddressCriterionOperator string

// SolAddressCriterionType The type of criterion to use. This should be `solAddress`.
type SolAddressCriterionType string

// SolanaAccount defines model for SolanaAccount.
type SolanaAccount struct {
	// Address The base58 encoded Solana address.
	Address string `json:"address"`

	// CreatedAt The ISO 8601 UTC timestamp at which the account was created.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Name An optional name for the account.
	// Account names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.
	// Account names are guaranteed to be unique across all Solana accounts in the developer's CDP Project.
	Name *string `json:"name,omitempty"`

	// Policies The list of policy IDs that apply to the account. This will include both the project-level policy and the account-level policy, if one exists.
	Policies *[]string `json:"policies,omitempty"`

	// UpdatedAt The ISO 8601 UTC timestamp at which the account was last updated.
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
}

// SwapUnavailableResponse defines model for SwapUnavailableResponse.
type SwapUnavailableResponse struct {
	// LiquidityAvailable Whether sufficient liquidity is available to settle the swap. All other fields in the response will be empty if this is false.
	LiquidityAvailable SwapUnavailableResponseLiquidityAvailable `json:"liquidityAvailable"`
}

// SwapUnavailableResponseLiquidityAvailable Whether sufficient liquidity is available to settle the swap. All other fields in the response will be empty if this is false.
type SwapUnavailableResponseLiquidityAvailable bool

// Token General information about a token. Includes the type, the network, and other identifying information.
type Token struct {
	// ContractAddress The contract address of the token.
	// For Ether, the contract address is `0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE` per [EIP-7528](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-7528.md). For ERC-20 tokens, this is the contract address where the token is deployed.
	ContractAddress string `json:"contractAddress"`

	// Name The name of this token (ex: "Solana", "Ether", "USD Coin").
	// The token name is not unique. It is possible for two different tokens to have the same name.
	// For native gas tokens, this name is defined via convention. As an example, for ETH on Ethereum mainnet, the name is "Ether". For ERC-20 tokens, this name is defined via configuration. `name` will be the string returned by `function name() public view returns (string)` on the underlying token contract.
	// Not all tokens have a name, as this function is [optional in the ERC-20 specification](https://eips.ethereum.org/EIPS/eip-20#name). This field will only be populated when the token's underlying ERC-20 contract has a `name()` function.
	// Further, this endpoint will only populate this value for a small subset of whitelisted ERC-20 tokens at this time. We intend to improve coverage in the future.
	Name *string `json:"name,omitempty"`

	// Network The name of the supported EVM networks in human-readable format.
	Network ListEvmTokenBalancesNetwork `json:"network"`

	// Symbol The symbol of this token (ex: SOL, ETH, USDC).
	// The token symbol is not unique. It is possible for two different tokens to have the same symbol.
	// For native gas tokens, this symbol is defined via convention. As an example, for ETH on Ethereum mainnet, the symbol is "ETH". For ERC-20 tokens, this symbol is defined via configuration. `symbol` will be the string returned by `function symbol() public view returns (string)` on the underlying token contract.
	// Not all tokens have a symbol, as this function is [optional in the ERC-20 specification](https://eips.ethereum.org/EIPS/eip-20#symbol). This field will only be populated when the token's underlying ERC-20 contract has a `symbol()` function.
	// Further, this endpoint will only populate this value for a small subset of whitelisted ERC-20 tokens at this time. We intend to improve coverage in the future.
	Symbol *string `json:"symbol,omitempty"`
}

// TokenAmount Amount of a given token.
type TokenAmount struct {
	// Amount The amount is denominated in the smallest indivisible unit of the token. For ETH, the smallest indivisible unit is Wei (10^-18 ETH). For ERC-20s, the smallest unit is the unit returned from `function totalSupply() public view returns (uint256)`.
	Amount string `json:"amount"`

	// Decimals 'decimals' is the exponential value N that satisfies the equation `amount * 10^-N = standard_denomination`. The standard denomination is the most commonly used denomination for the token.
	// - In the case of the native gas token, `decimals` is defined via convention. As an example, for ETH of Ethereum mainnet, the standard denomination is 10^-18 the smallest denomination (Wei). As such, for ETH on Ethereum mainnet, `decimals` is 18. - In the case of ERC-20 tokens, `decimals` is defined via configuration. `decimals` will be the number returned by `function decimals() public view returns (uint8)` on the underlying token contract.
	// Not all tokens have a `decimals` field, as this function is [optional in the ERC-20 specification](https://eips.ethereum.org/EIPS/eip-20#decimals). This field will be left empty if the underlying token contract doesn't implement `decimals`.
	// Further, this endpoint will only populate this value for a small subset of whitelisted ERC-20 tokens at this time. We intend to improve coverage in the future.
	Decimals int64 `json:"decimals"`
}

// TokenBalance defines model for TokenBalance.
type TokenBalance struct {
	// Amount Amount of a given token.
	Amount TokenAmount `json:"amount"`

	// Token General information about a token. Includes the type, the network, and other identifying information.
	Token Token `json:"token"`
}

// TokenFee defines model for TokenFee.
type TokenFee struct {
	// Amount The estimated amount of the fee in atomic units of the `token`. For example, `1000000000000000` if the fee is in ETH equates to 0.001 ETH, `10000` if the fee is in USDC equates to 0.01 USDC, etc.
	Amount string `json:"amount"`

	// Token The contract address of the token that the fee is paid in. The address `0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE` is used for the native token of the network (e.g. ETH).
	Token string `json:"token"`
}

// Transfer The transfer object.
type Transfer struct {
	// CreatedAt The UTC date and time in ISO 8601 format the transfer was created.
	CreatedAt string `json:"createdAt"`

	// Fees The fees for the transfer.
	Fees []Fee `json:"fees"`

	// Id The ID of the transfer.
	Id string `json:"id"`

	// Source The source of the transfer.
	Source Transfer_Source `json:"source"`

	// SourceAmount The amount the source will transfer.
	SourceAmount string `json:"sourceAmount"`

	// SourceCurrency The currency the source will transfer.
	SourceCurrency string `json:"sourceCurrency"`

	// SourceType The type of the source of the transfer.
	SourceType TransferSourceType `json:"sourceType"`

	// Status The status of the transfer.
	Status TransferStatus `json:"status"`

	// Target The target of the transfer.
	Target Transfer_Target `json:"target"`

	// TargetAmount The amount the target will receive.
	TargetAmount string `json:"targetAmount"`

	// TargetCurrency The currency the target will receive.
	TargetCurrency string `json:"targetCurrency"`

	// TargetType The type of the target of the transfer.
	TargetType TransferTargetType `json:"targetType"`

	// TransactionHash The transaction hash or transaction signature of the transfer.
	TransactionHash *string `json:"transactionHash,omitempty"`

	// UpdatedAt The UTC date and time in ISO 8601 format the transfer was updated.
	UpdatedAt string `json:"updatedAt"`

	// UserAmount The amount the customer put in to transfer.
	UserAmount string `json:"userAmount"`

	// UserCurrency The currency the customer put in to transfer.
	UserCurrency string `json:"userCurrency"`
}

// Transfer_Source The source of the transfer.
type Transfer_Source struct {
	union json.RawMessage
}

// TransferSourceType The type of the source of the transfer.
type TransferSourceType string

// TransferStatus The status of the transfer.
type TransferStatus string

// Transfer_Target The target of the transfer.
type Transfer_Target struct {
	union json.RawMessage
}

// TransferTargetType The type of the target of the transfer.
type TransferTargetType string

// TransferSource The source of the transfer.
type TransferSource struct {
	union json.RawMessage
}

// TransferTarget The target of the transfer.
type TransferTarget struct {
	union json.RawMessage
}

// FromAmount The amount of the `fromToken` to send in atomic units of the token. For example, `1000000000000000000` when sending ETH equates to 1 ETH, `1000000` when sending USDC equates to 1 USDC, etc.
type FromAmount = string

// FromToken The 0x-prefixed contract address of the token to send.
type FromToken = string

// GasPrice The target gas price for the swap transaction, in Wei. For EIP-1559 transactions, this value should be seen as the `maxFeePerGas` value. If not provided, the API will use an estimate based on the current network conditions.
type GasPrice = string

// SignerAddress The 0x-prefixed Externally Owned Account (EOA) address that will sign the `Permit2` EIP-712 permit message. This is only needed if `taker` is a smart contract.
type SignerAddress = string

// SlippageBps The maximum acceptable slippage of the `toToken` in basis points. If this parameter is set to 0, no slippage will be tolerated. If not provided, the default slippage tolerance is 100 bps (i.e., 1%).
type SlippageBps = int

// Taker The 0x-prefixed address that holds the `fromToken` balance and has the `Permit2` allowance set for the swap.
type Taker = string

// ToToken The 0x-prefixed contract address of the token to receive.
type ToToken = string

// IdempotencyKey defines model for IdempotencyKey.
type IdempotencyKey = string

// XWalletAuth defines model for XWalletAuth.
type XWalletAuth = string

// AlreadyExistsError An error response including the code for the type of error and a human-readable message describing the error.
type AlreadyExistsError = Error

// BadGatewayError An error response including the code for the type of error and a human-readable message describing the error.
type BadGatewayError = Error

// IdempotencyError An error response including the code for the type of error and a human-readable message describing the error.
type IdempotencyError = Error

// InternalServerError An error response including the code for the type of error and a human-readable message describing the error.
type InternalServerError = Error

// PaymentMethodRequiredError An error response including the code for the type of error and a human-readable message describing the error.
type PaymentMethodRequiredError = Error

// ServiceUnavailableError An error response including the code for the type of error and a human-readable message describing the error.
type ServiceUnavailableError = Error

// ListEvmAccountsParams defines parameters for ListEvmAccounts.
type ListEvmAccountsParams struct {
	// PageSize The number of accounts to return per page.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// PageToken The token for the next page of accounts, if any.
	PageToken *string `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// CreateEvmAccountJSONBody defines parameters for CreateEvmAccount.
type CreateEvmAccountJSONBody struct {
	// AccountPolicy The ID of the account-level policy to apply to the account.
	AccountPolicy *string `json:"accountPolicy,omitempty"`

	// Name An optional name for the account.
	// Account names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.
	// Account names must be unique across all EVM accounts in the developer's CDP Project.
	Name *string `json:"name,omitempty"`
}

// CreateEvmAccountParams defines parameters for CreateEvmAccount.
type CreateEvmAccountParams struct {
	// XWalletAuth A JWT signed using your Wallet Secret, encoded in base64. Refer to the
	// [Generate Wallet Token](https://docs.cdp.coinbase.com/api-v2/docs/authentication#2-generate-wallet-token)
	// section of our Authentication docs for more details on how to generate your Wallet Token.
	XWalletAuth *XWalletAuth `json:"X-Wallet-Auth,omitempty"`

	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-v2/docs/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// ExportEvmAccountByNameJSONBody defines parameters for ExportEvmAccountByName.
type ExportEvmAccountByNameJSONBody struct {
	// ExportEncryptionKey The base64-encoded, public part of the RSA key in DER format used to encrypt the account private key.
	ExportEncryptionKey string `json:"exportEncryptionKey"`
}

// ExportEvmAccountByNameParams defines parameters for ExportEvmAccountByName.
type ExportEvmAccountByNameParams struct {
	// XWalletAuth A JWT signed using your Wallet Secret, encoded in base64. Refer to the
	// [Generate Wallet Token](https://docs.cdp.coinbase.com/api-v2/docs/authentication#2-generate-wallet-token)
	// section of our Authentication docs for more details on how to generate your Wallet Token.
	XWalletAuth *XWalletAuth `json:"X-Wallet-Auth,omitempty"`

	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-v2/docs/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// ImportEvmAccountJSONBody defines parameters for ImportEvmAccount.
type ImportEvmAccountJSONBody struct {
	// AccountPolicy The ID of the account-level policy to apply to the account.
	AccountPolicy *string `json:"accountPolicy,omitempty"`

	// EncryptedPrivateKey The base64-encoded, encrypted private key of the EVM account. The private key must be encrypted using the CDP SDK's encryption scheme.
	EncryptedPrivateKey string `json:"encryptedPrivateKey"`

	// Name An optional name for the account.
	// Account names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.
	// Account names must be unique across all EVM accounts in the developer's CDP Project.
	Name *string `json:"name,omitempty"`
}

// ImportEvmAccountParams defines parameters for ImportEvmAccount.
type ImportEvmAccountParams struct {
	// XWalletAuth A JWT signed using your Wallet Secret, encoded in base64. Refer to the
	// [Generate Wallet Token](https://docs.cdp.coinbase.com/api-v2/docs/authentication#2-generate-wallet-token)
	// section of our Authentication docs for more details on how to generate your Wallet Token.
	XWalletAuth *XWalletAuth `json:"X-Wallet-Auth,omitempty"`

	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-v2/docs/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// UpdateEvmAccountJSONBody defines parameters for UpdateEvmAccount.
type UpdateEvmAccountJSONBody struct {
	// AccountPolicy The ID of the account-level policy to apply to the account, or an empty string to unset attached policy.
	AccountPolicy *string `json:"accountPolicy,omitempty"`

	// Name An optional name for the account.
	// Account names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.
	// Account names must be unique across all EVM accounts in the developer's CDP Project.
	Name *string `json:"name,omitempty"`
}

// UpdateEvmAccountParams defines parameters for UpdateEvmAccount.
type UpdateEvmAccountParams struct {
	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-v2/docs/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// ExportEvmAccountJSONBody defines parameters for ExportEvmAccount.
type ExportEvmAccountJSONBody struct {
	// ExportEncryptionKey The base64-encoded, public part of the RSA key in DER format used to encrypt the account private key.
	ExportEncryptionKey string `json:"exportEncryptionKey"`
}

// ExportEvmAccountParams defines parameters for ExportEvmAccount.
type ExportEvmAccountParams struct {
	// XWalletAuth A JWT signed using your Wallet Secret, encoded in base64. Refer to the
	// [Generate Wallet Token](https://docs.cdp.coinbase.com/api-v2/docs/authentication#2-generate-wallet-token)
	// section of our Authentication docs for more details on how to generate your Wallet Token.
	XWalletAuth *XWalletAuth `json:"X-Wallet-Auth,omitempty"`

	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-v2/docs/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// SendEvmTransactionJSONBody defines parameters for SendEvmTransaction.
type SendEvmTransactionJSONBody struct {
	// Network The network to send the transaction to.
	Network SendEvmTransactionJSONBodyNetwork `json:"network"`

	// Transaction The RLP-encoded transaction to sign and send, as a 0x-prefixed hex string.
	Transaction string `json:"transaction"`
}

// SendEvmTransactionParams defines parameters for SendEvmTransaction.
type SendEvmTransactionParams struct {
	// XWalletAuth A JWT signed using your Wallet Secret, encoded in base64. Refer to the
	// [Generate Wallet Token](https://docs.cdp.coinbase.com/api-v2/docs/authentication#2-generate-wallet-token)
	// section of our Authentication docs for more details on how to generate your Wallet Token.
	XWalletAuth *XWalletAuth `json:"X-Wallet-Auth,omitempty"`

	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-v2/docs/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// SendEvmTransactionJSONBodyNetwork defines parameters for SendEvmTransaction.
type SendEvmTransactionJSONBodyNetwork string

// SignEvmHashJSONBody defines parameters for SignEvmHash.
type SignEvmHashJSONBody struct {
	// Hash The arbitrary 32 byte hash to sign.
	Hash string `json:"hash"`
}

// SignEvmHashParams defines parameters for SignEvmHash.
type SignEvmHashParams struct {
	// XWalletAuth A JWT signed using your Wallet Secret, encoded in base64. Refer to the
	// [Generate Wallet Token](https://docs.cdp.coinbase.com/api-v2/docs/authentication#2-generate-wallet-token)
	// section of our Authentication docs for more details on how to generate your Wallet Token.
	XWalletAuth *XWalletAuth `json:"X-Wallet-Auth,omitempty"`

	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-v2/docs/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// SignEvmMessageJSONBody defines parameters for SignEvmMessage.
type SignEvmMessageJSONBody struct {
	// Message The message to sign.
	Message string `json:"message"`
}

// SignEvmMessageParams defines parameters for SignEvmMessage.
type SignEvmMessageParams struct {
	// XWalletAuth A JWT signed using your Wallet Secret, encoded in base64. Refer to the
	// [Generate Wallet Token](https://docs.cdp.coinbase.com/api-v2/docs/authentication#2-generate-wallet-token)
	// section of our Authentication docs for more details on how to generate your Wallet Token.
	XWalletAuth *XWalletAuth `json:"X-Wallet-Auth,omitempty"`

	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-v2/docs/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// SignEvmTransactionJSONBody defines parameters for SignEvmTransaction.
type SignEvmTransactionJSONBody struct {
	// Transaction The RLP-encoded transaction to sign, as a 0x-prefixed hex string.
	Transaction string `json:"transaction"`
}

// SignEvmTransactionParams defines parameters for SignEvmTransaction.
type SignEvmTransactionParams struct {
	// XWalletAuth A JWT signed using your Wallet Secret, encoded in base64. Refer to the
	// [Generate Wallet Token](https://docs.cdp.coinbase.com/api-v2/docs/authentication#2-generate-wallet-token)
	// section of our Authentication docs for more details on how to generate your Wallet Token.
	XWalletAuth *XWalletAuth `json:"X-Wallet-Auth,omitempty"`

	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-v2/docs/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// SignEvmTypedDataParams defines parameters for SignEvmTypedData.
type SignEvmTypedDataParams struct {
	// XWalletAuth A JWT signed using your Wallet Secret, encoded in base64. Refer to the
	// [Generate Wallet Token](https://docs.cdp.coinbase.com/api-v2/docs/authentication#2-generate-wallet-token)
	// section of our Authentication docs for more details on how to generate your Wallet Token.
	XWalletAuth *XWalletAuth `json:"X-Wallet-Auth,omitempty"`

	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-v2/docs/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// RequestEvmFaucetJSONBody defines parameters for RequestEvmFaucet.
type RequestEvmFaucetJSONBody struct {
	// Address The address to request funds to, which is a 0x-prefixed hexadecimal string.
	Address string `json:"address"`

	// Network The network to request funds from.
	Network RequestEvmFaucetJSONBodyNetwork `json:"network"`

	// Token The token to request funds for.
	Token RequestEvmFaucetJSONBodyToken `json:"token"`
}

// RequestEvmFaucetJSONBodyNetwork defines parameters for RequestEvmFaucet.
type RequestEvmFaucetJSONBodyNetwork string

// RequestEvmFaucetJSONBodyToken defines parameters for RequestEvmFaucet.
type RequestEvmFaucetJSONBodyToken string

// ListEvmSmartAccountsParams defines parameters for ListEvmSmartAccounts.
type ListEvmSmartAccountsParams struct {
	// PageSize The number of accounts to return per page.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// PageToken The token for the next page of accounts, if any.
	PageToken *string `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// CreateEvmSmartAccountJSONBody defines parameters for CreateEvmSmartAccount.
type CreateEvmSmartAccountJSONBody struct {
	// Name An optional name for the account.
	// Account names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.
	// Account names must be unique across all EVM accounts in the developer's CDP Project.
	Name *string `json:"name,omitempty"`

	// Owners Today, only a single owner can be set for a Smart Account, but this is an array to allow setting multiple owners in the future.
	Owners []string `json:"owners"`
}

// PrepareUserOperationJSONBody defines parameters for PrepareUserOperation.
type PrepareUserOperationJSONBody struct {
	// Calls The list of calls to make from the Smart Account.
	Calls []EvmCall `json:"calls"`

	// Network The network to prepare the user operation for.
	Network PrepareUserOperationJSONBodyNetwork `json:"network"`

	// PaymasterUrl The URL of the paymaster to use for the user operation.
	PaymasterUrl *string `json:"paymasterUrl,omitempty"`
}

// PrepareUserOperationJSONBodyNetwork defines parameters for PrepareUserOperation.
type PrepareUserOperationJSONBodyNetwork string

// SendUserOperationJSONBody defines parameters for SendUserOperation.
type SendUserOperationJSONBody struct {
	// Signature The hex-encoded signature of the user operation. This should be a 65-byte signature consisting of the `r`, `s`, and `v` values of the ECDSA signature. Note that the `v` value should conform to the `personal_sign` standard, which means it should be 27 or 28.
	Signature string `json:"signature"`
}

// CreateEvmSwapQuoteJSONBody defines parameters for CreateEvmSwapQuote.
type CreateEvmSwapQuoteJSONBody struct {
	// FromAmount The amount of the `fromToken` to send in atomic units of the token. For example, `1000000000000000000` when sending ETH equates to 1 ETH, `1000000` when sending USDC equates to 1 USDC, etc.
	FromAmount string `json:"fromAmount"`

	// FromToken The 0x-prefixed contract address of the token to send.
	FromToken string `json:"fromToken"`

	// GasPrice The target gas price for the swap transaction, in Wei. For EIP-1559 transactions, this value should be seen as the `maxFeePerGas` value. If not provided, the API will use an estimate based on the current network conditions.
	GasPrice *string `json:"gasPrice,omitempty"`

	// Network The network on which to perform the swap.
	Network EvmSwapsNetwork `json:"network"`

	// SignerAddress The 0x-prefixed Externally Owned Account (EOA) address that will sign the `Permit2` EIP-712 permit message. This is only needed if `taker` is a smart contract.
	SignerAddress *string `json:"signerAddress,omitempty"`

	// SlippageBps The maximum acceptable slippage of the `toToken` in basis points. If this parameter is set to 0, no slippage will be tolerated. If not provided, the default slippage tolerance is 100 bps (i.e., 1%).
	SlippageBps *int `json:"slippageBps,omitempty"`

	// Taker The 0x-prefixed address that holds the `fromToken` balance and has the `Permit2` allowance set for the swap.
	Taker string `json:"taker"`

	// ToToken The 0x-prefixed contract address of the token to receive.
	ToToken string `json:"toToken"`
}

// CreateEvmSwapQuoteParams defines parameters for CreateEvmSwapQuote.
type CreateEvmSwapQuoteParams struct {
	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-v2/docs/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// GetEvmSwapPriceParams defines parameters for GetEvmSwapPrice.
type GetEvmSwapPriceParams struct {
	Network       EvmSwapsNetwork `form:"network" json:"network"`
	ToToken       ToToken         `form:"toToken" json:"toToken"`
	FromToken     FromToken       `form:"fromToken" json:"fromToken"`
	FromAmount    FromAmount      `form:"fromAmount" json:"fromAmount"`
	Taker         Taker           `form:"taker" json:"taker"`
	SignerAddress *SignerAddress  `form:"signerAddress,omitempty" json:"signerAddress,omitempty"`
	GasPrice      *GasPrice       `form:"gasPrice,omitempty" json:"gasPrice,omitempty"`
	SlippageBps   *SlippageBps    `form:"slippageBps,omitempty" json:"slippageBps,omitempty"`
}

// ListEvmTokenBalancesParams defines parameters for ListEvmTokenBalances.
type ListEvmTokenBalancesParams struct {
	// PageSize The number of balances to return per page.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// PageToken The token for the next page of balances. Will be empty if there are no more balances to fetch.
	PageToken *string `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// GetCryptoRailsParams defines parameters for GetCryptoRails.
type GetCryptoRailsParams struct {
	// Networks Comma separated list of networks to filter the rails by.
	Networks *string `form:"networks,omitempty" json:"networks,omitempty"`
}

// CreatePaymentTransferQuoteJSONBody defines parameters for CreatePaymentTransferQuote.
type CreatePaymentTransferQuoteJSONBody struct {
	// Amount The amount of the transfer, which is either for the source currency to buy, or the target currency to receive.
	Amount string `json:"amount"`

	// Currency The currency of the transfer. This can be specified as the source currency, which would be used to buy, or else the target currency, which is how much will be received.
	Currency string `json:"currency"`

	// Execute Whether to execute the transfer. If true, the transfer will be committed and executed. If false, the quote will be generated and returned.
	Execute *bool `json:"execute,omitempty"`

	// Source The source of the transfer.
	Source TransferSource `json:"source"`

	// SourceType The type of the source of the transfer.
	SourceType CreatePaymentTransferQuoteJSONBodySourceType `json:"sourceType"`

	// Target The target of the transfer.
	Target TransferTarget `json:"target"`

	// TargetType The type of the target of the transfer.
	TargetType CreatePaymentTransferQuoteJSONBodyTargetType `json:"targetType"`
}

// CreatePaymentTransferQuoteJSONBodySourceType defines parameters for CreatePaymentTransferQuote.
type CreatePaymentTransferQuoteJSONBodySourceType string

// CreatePaymentTransferQuoteJSONBodyTargetType defines parameters for CreatePaymentTransferQuote.
type CreatePaymentTransferQuoteJSONBodyTargetType string

// ListPoliciesParams defines parameters for ListPolicies.
type ListPoliciesParams struct {
	// PageSize The number of policies to return per page.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// PageToken The token for the next page of policies, if any.
	PageToken *string `form:"pageToken,omitempty" json:"pageToken,omitempty"`

	// Scope The scope of the policies to return. If `project`, the response will include exactly one policy, which is the project-level policy. If `account`, the response will include all account-level policies for the developer's CDP Project.
	Scope *ListPoliciesParamsScope `form:"scope,omitempty" json:"scope,omitempty"`
}

// ListPoliciesParamsScope defines parameters for ListPolicies.
type ListPoliciesParamsScope string

// CreatePolicyJSONBody defines parameters for CreatePolicy.
type CreatePolicyJSONBody struct {
	// Description An optional human-readable description for the policy.
	// Policy descriptions can consist of alphanumeric characters, spaces, commas, and periods, and be 50 characters or less.
	Description *string `json:"description,omitempty"`

	// Rules A list of rules that comprise the policy. There is a limit of 10 rules per policy.
	Rules []Rule `json:"rules"`

	// Scope The scope of the policy.
	Scope CreatePolicyJSONBodyScope `json:"scope"`
}

// CreatePolicyParams defines parameters for CreatePolicy.
type CreatePolicyParams struct {
	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-v2/docs/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// CreatePolicyJSONBodyScope defines parameters for CreatePolicy.
type CreatePolicyJSONBodyScope string

// DeletePolicyParams defines parameters for DeletePolicy.
type DeletePolicyParams struct {
	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-v2/docs/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// UpdatePolicyJSONBody defines parameters for UpdatePolicy.
type UpdatePolicyJSONBody struct {
	// Description An optional human-readable description for the policy.
	// Policy descriptions can consist of alphanumeric characters, spaces, commas, and periods, and be 50 characters or less.
	Description *string `json:"description,omitempty"`

	// Rules A list of rules that comprise the policy. There is a limit of 10 rules per policy.
	Rules []Rule `json:"rules"`
}

// UpdatePolicyParams defines parameters for UpdatePolicy.
type UpdatePolicyParams struct {
	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-v2/docs/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// ListSolanaAccountsParams defines parameters for ListSolanaAccounts.
type ListSolanaAccountsParams struct {
	// PageSize The number of accounts to return per page.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// PageToken The token for the next page of accounts, if any.
	PageToken *string `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// CreateSolanaAccountJSONBody defines parameters for CreateSolanaAccount.
type CreateSolanaAccountJSONBody struct {
	// AccountPolicy The ID of the account-level policy to apply to the account.
	AccountPolicy *string `json:"accountPolicy,omitempty"`

	// Name An optional name for the account.
	// Account names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.
	// Account names must be unique across all Solana accounts in the developer's CDP Project.
	Name *string `json:"name,omitempty"`
}

// CreateSolanaAccountParams defines parameters for CreateSolanaAccount.
type CreateSolanaAccountParams struct {
	// XWalletAuth A JWT signed using your Wallet Secret, encoded in base64. Refer to the
	// [Generate Wallet Token](https://docs.cdp.coinbase.com/api-v2/docs/authentication#2-generate-wallet-token)
	// section of our Authentication docs for more details on how to generate your Wallet Token.
	XWalletAuth *XWalletAuth `json:"X-Wallet-Auth,omitempty"`

	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-v2/docs/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// ExportSolanaAccountByNameJSONBody defines parameters for ExportSolanaAccountByName.
type ExportSolanaAccountByNameJSONBody struct {
	// ExportEncryptionKey The base64-encoded, public part of the RSA key in DER format used to encrypt the account private key.
	ExportEncryptionKey string `json:"exportEncryptionKey"`
}

// ExportSolanaAccountByNameParams defines parameters for ExportSolanaAccountByName.
type ExportSolanaAccountByNameParams struct {
	// XWalletAuth A JWT signed using your Wallet Secret, encoded in base64. Refer to the
	// [Generate Wallet Token](https://docs.cdp.coinbase.com/api-v2/docs/authentication#2-generate-wallet-token)
	// section of our Authentication docs for more details on how to generate your Wallet Token.
	XWalletAuth *XWalletAuth `json:"X-Wallet-Auth,omitempty"`

	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-v2/docs/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// UpdateSolanaAccountJSONBody defines parameters for UpdateSolanaAccount.
type UpdateSolanaAccountJSONBody struct {
	// AccountPolicy The ID of the account-level policy to apply to the account, or an empty string to unset attached policy.
	AccountPolicy *string `json:"accountPolicy,omitempty"`

	// Name An optional name for the account. Account names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.
	// Account names must be unique across all Solana accounts in the developer's CDP Project.
	Name *string `json:"name,omitempty"`
}

// UpdateSolanaAccountParams defines parameters for UpdateSolanaAccount.
type UpdateSolanaAccountParams struct {
	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-v2/docs/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// ExportSolanaAccountJSONBody defines parameters for ExportSolanaAccount.
type ExportSolanaAccountJSONBody struct {
	// ExportEncryptionKey The base64-encoded, public part of the RSA key in DER format used to encrypt the account private key.
	ExportEncryptionKey string `json:"exportEncryptionKey"`
}

// ExportSolanaAccountParams defines parameters for ExportSolanaAccount.
type ExportSolanaAccountParams struct {
	// XWalletAuth A JWT signed using your Wallet Secret, encoded in base64. Refer to the
	// [Generate Wallet Token](https://docs.cdp.coinbase.com/api-v2/docs/authentication#2-generate-wallet-token)
	// section of our Authentication docs for more details on how to generate your Wallet Token.
	XWalletAuth *XWalletAuth `json:"X-Wallet-Auth,omitempty"`

	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-v2/docs/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// SignSolanaMessageJSONBody defines parameters for SignSolanaMessage.
type SignSolanaMessageJSONBody struct {
	// Message The arbitrary message to sign.
	Message string `json:"message"`
}

// SignSolanaMessageParams defines parameters for SignSolanaMessage.
type SignSolanaMessageParams struct {
	// XWalletAuth A JWT signed using your Wallet Secret, encoded in base64. Refer to the
	// [Generate Wallet Token](https://docs.cdp.coinbase.com/api-v2/docs/authentication#2-generate-wallet-token)
	// section of our Authentication docs for more details on how to generate your Wallet Token.
	XWalletAuth *XWalletAuth `json:"X-Wallet-Auth,omitempty"`

	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-v2/docs/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// SignSolanaTransactionJSONBody defines parameters for SignSolanaTransaction.
type SignSolanaTransactionJSONBody struct {
	// Transaction The base64 encoded transaction to sign.
	Transaction string `json:"transaction"`
}

// SignSolanaTransactionParams defines parameters for SignSolanaTransaction.
type SignSolanaTransactionParams struct {
	// XWalletAuth A JWT signed using your Wallet Secret, encoded in base64. Refer to the
	// [Generate Wallet Token](https://docs.cdp.coinbase.com/api-v2/docs/authentication#2-generate-wallet-token)
	// section of our Authentication docs for more details on how to generate your Wallet Token.
	XWalletAuth *XWalletAuth `json:"X-Wallet-Auth,omitempty"`

	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-v2/docs/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// RequestSolanaFaucetJSONBody defines parameters for RequestSolanaFaucet.
type RequestSolanaFaucetJSONBody struct {
	// Address The address to request funds to, which is a base58-encoded string.
	Address string `json:"address"`

	// Token The token to request funds for.
	Token RequestSolanaFaucetJSONBodyToken `json:"token"`
}

// RequestSolanaFaucetJSONBodyToken defines parameters for RequestSolanaFaucet.
type RequestSolanaFaucetJSONBodyToken string

// CreateEvmAccountJSONRequestBody defines body for CreateEvmAccount for application/json ContentType.
type CreateEvmAccountJSONRequestBody CreateEvmAccountJSONBody

// ExportEvmAccountByNameJSONRequestBody defines body for ExportEvmAccountByName for application/json ContentType.
type ExportEvmAccountByNameJSONRequestBody ExportEvmAccountByNameJSONBody

// ImportEvmAccountJSONRequestBody defines body for ImportEvmAccount for application/json ContentType.
type ImportEvmAccountJSONRequestBody ImportEvmAccountJSONBody

// UpdateEvmAccountJSONRequestBody defines body for UpdateEvmAccount for application/json ContentType.
type UpdateEvmAccountJSONRequestBody UpdateEvmAccountJSONBody

// ExportEvmAccountJSONRequestBody defines body for ExportEvmAccount for application/json ContentType.
type ExportEvmAccountJSONRequestBody ExportEvmAccountJSONBody

// SendEvmTransactionJSONRequestBody defines body for SendEvmTransaction for application/json ContentType.
type SendEvmTransactionJSONRequestBody SendEvmTransactionJSONBody

// SignEvmHashJSONRequestBody defines body for SignEvmHash for application/json ContentType.
type SignEvmHashJSONRequestBody SignEvmHashJSONBody

// SignEvmMessageJSONRequestBody defines body for SignEvmMessage for application/json ContentType.
type SignEvmMessageJSONRequestBody SignEvmMessageJSONBody

// SignEvmTransactionJSONRequestBody defines body for SignEvmTransaction for application/json ContentType.
type SignEvmTransactionJSONRequestBody SignEvmTransactionJSONBody

// SignEvmTypedDataJSONRequestBody defines body for SignEvmTypedData for application/json ContentType.
type SignEvmTypedDataJSONRequestBody = EIP712Message

// RequestEvmFaucetJSONRequestBody defines body for RequestEvmFaucet for application/json ContentType.
type RequestEvmFaucetJSONRequestBody RequestEvmFaucetJSONBody

// CreateEvmSmartAccountJSONRequestBody defines body for CreateEvmSmartAccount for application/json ContentType.
type CreateEvmSmartAccountJSONRequestBody CreateEvmSmartAccountJSONBody

// PrepareUserOperationJSONRequestBody defines body for PrepareUserOperation for application/json ContentType.
type PrepareUserOperationJSONRequestBody PrepareUserOperationJSONBody

// SendUserOperationJSONRequestBody defines body for SendUserOperation for application/json ContentType.
type SendUserOperationJSONRequestBody SendUserOperationJSONBody

// CreateEvmSwapQuoteJSONRequestBody defines body for CreateEvmSwapQuote for application/json ContentType.
type CreateEvmSwapQuoteJSONRequestBody CreateEvmSwapQuoteJSONBody

// CreatePaymentTransferQuoteJSONRequestBody defines body for CreatePaymentTransferQuote for application/json ContentType.
type CreatePaymentTransferQuoteJSONRequestBody CreatePaymentTransferQuoteJSONBody

// CreatePolicyJSONRequestBody defines body for CreatePolicy for application/json ContentType.
type CreatePolicyJSONRequestBody CreatePolicyJSONBody

// UpdatePolicyJSONRequestBody defines body for UpdatePolicy for application/json ContentType.
type UpdatePolicyJSONRequestBody UpdatePolicyJSONBody

// CreateSolanaAccountJSONRequestBody defines body for CreateSolanaAccount for application/json ContentType.
type CreateSolanaAccountJSONRequestBody CreateSolanaAccountJSONBody

// ExportSolanaAccountByNameJSONRequestBody defines body for ExportSolanaAccountByName for application/json ContentType.
type ExportSolanaAccountByNameJSONRequestBody ExportSolanaAccountByNameJSONBody

// UpdateSolanaAccountJSONRequestBody defines body for UpdateSolanaAccount for application/json ContentType.
type UpdateSolanaAccountJSONRequestBody UpdateSolanaAccountJSONBody

// ExportSolanaAccountJSONRequestBody defines body for ExportSolanaAccount for application/json ContentType.
type ExportSolanaAccountJSONRequestBody ExportSolanaAccountJSONBody

// SignSolanaMessageJSONRequestBody defines body for SignSolanaMessage for application/json ContentType.
type SignSolanaMessageJSONRequestBody SignSolanaMessageJSONBody

// SignSolanaTransactionJSONRequestBody defines body for SignSolanaTransaction for application/json ContentType.
type SignSolanaTransactionJSONRequestBody SignSolanaTransactionJSONBody

// RequestSolanaFaucetJSONRequestBody defines body for RequestSolanaFaucet for application/json ContentType.
type RequestSolanaFaucetJSONRequestBody RequestSolanaFaucetJSONBody

// AsAbiFunction returns the union data inside the Abi_Item as a AbiFunction
func (t Abi_Item) AsAbiFunction() (AbiFunction, error) {
	var body AbiFunction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAbiFunction overwrites any union data inside the Abi_Item as the provided AbiFunction
func (t *Abi_Item) FromAbiFunction(v AbiFunction) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAbiFunction performs a merge with any union data inside the Abi_Item, using the provided AbiFunction
func (t *Abi_Item) MergeAbiFunction(v AbiFunction) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAbiInput returns the union data inside the Abi_Item as a AbiInput
func (t Abi_Item) AsAbiInput() (AbiInput, error) {
	var body AbiInput
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAbiInput overwrites any union data inside the Abi_Item as the provided AbiInput
func (t *Abi_Item) FromAbiInput(v AbiInput) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAbiInput performs a merge with any union data inside the Abi_Item, using the provided AbiInput
func (t *Abi_Item) MergeAbiInput(v AbiInput) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t Abi_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Abi_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCreateSwapQuoteResponse returns the union data inside the CreateSwapQuoteResponseWrapper as a CreateSwapQuoteResponse
func (t CreateSwapQuoteResponseWrapper) AsCreateSwapQuoteResponse() (CreateSwapQuoteResponse, error) {
	var body CreateSwapQuoteResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateSwapQuoteResponse overwrites any union data inside the CreateSwapQuoteResponseWrapper as the provided CreateSwapQuoteResponse
func (t *CreateSwapQuoteResponseWrapper) FromCreateSwapQuoteResponse(v CreateSwapQuoteResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateSwapQuoteResponse performs a merge with any union data inside the CreateSwapQuoteResponseWrapper, using the provided CreateSwapQuoteResponse
func (t *CreateSwapQuoteResponseWrapper) MergeCreateSwapQuoteResponse(v CreateSwapQuoteResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSwapUnavailableResponse returns the union data inside the CreateSwapQuoteResponseWrapper as a SwapUnavailableResponse
func (t CreateSwapQuoteResponseWrapper) AsSwapUnavailableResponse() (SwapUnavailableResponse, error) {
	var body SwapUnavailableResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSwapUnavailableResponse overwrites any union data inside the CreateSwapQuoteResponseWrapper as the provided SwapUnavailableResponse
func (t *CreateSwapQuoteResponseWrapper) FromSwapUnavailableResponse(v SwapUnavailableResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSwapUnavailableResponse performs a merge with any union data inside the CreateSwapQuoteResponseWrapper, using the provided SwapUnavailableResponse
func (t *CreateSwapQuoteResponseWrapper) MergeSwapUnavailableResponse(v SwapUnavailableResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateSwapQuoteResponseWrapper) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateSwapQuoteResponseWrapper) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsEvmDataParameterCondition returns the union data inside the EvmDataCondition_Params_Item as a EvmDataParameterCondition
func (t EvmDataCondition_Params_Item) AsEvmDataParameterCondition() (EvmDataParameterCondition, error) {
	var body EvmDataParameterCondition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEvmDataParameterCondition overwrites any union data inside the EvmDataCondition_Params_Item as the provided EvmDataParameterCondition
func (t *EvmDataCondition_Params_Item) FromEvmDataParameterCondition(v EvmDataParameterCondition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEvmDataParameterCondition performs a merge with any union data inside the EvmDataCondition_Params_Item, using the provided EvmDataParameterCondition
func (t *EvmDataCondition_Params_Item) MergeEvmDataParameterCondition(v EvmDataParameterCondition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsEvmDataParameterConditionList returns the union data inside the EvmDataCondition_Params_Item as a EvmDataParameterConditionList
func (t EvmDataCondition_Params_Item) AsEvmDataParameterConditionList() (EvmDataParameterConditionList, error) {
	var body EvmDataParameterConditionList
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEvmDataParameterConditionList overwrites any union data inside the EvmDataCondition_Params_Item as the provided EvmDataParameterConditionList
func (t *EvmDataCondition_Params_Item) FromEvmDataParameterConditionList(v EvmDataParameterConditionList) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEvmDataParameterConditionList performs a merge with any union data inside the EvmDataCondition_Params_Item, using the provided EvmDataParameterConditionList
func (t *EvmDataCondition_Params_Item) MergeEvmDataParameterConditionList(v EvmDataParameterConditionList) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t EvmDataCondition_Params_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *EvmDataCondition_Params_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsKnownAbiType returns the union data inside the EvmDataCriterion_Abi as a KnownAbiType
func (t EvmDataCriterion_Abi) AsKnownAbiType() (KnownAbiType, error) {
	var body KnownAbiType
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromKnownAbiType overwrites any union data inside the EvmDataCriterion_Abi as the provided KnownAbiType
func (t *EvmDataCriterion_Abi) FromKnownAbiType(v KnownAbiType) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeKnownAbiType performs a merge with any union data inside the EvmDataCriterion_Abi, using the provided KnownAbiType
func (t *EvmDataCriterion_Abi) MergeKnownAbiType(v KnownAbiType) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAbi returns the union data inside the EvmDataCriterion_Abi as a Abi
func (t EvmDataCriterion_Abi) AsAbi() (Abi, error) {
	var body Abi
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAbi overwrites any union data inside the EvmDataCriterion_Abi as the provided Abi
func (t *EvmDataCriterion_Abi) FromAbi(v Abi) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAbi performs a merge with any union data inside the EvmDataCriterion_Abi, using the provided Abi
func (t *EvmDataCriterion_Abi) MergeAbi(v Abi) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t EvmDataCriterion_Abi) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *EvmDataCriterion_Abi) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsGetSwapPriceResponse returns the union data inside the GetSwapPriceResponseWrapper as a GetSwapPriceResponse
func (t GetSwapPriceResponseWrapper) AsGetSwapPriceResponse() (GetSwapPriceResponse, error) {
	var body GetSwapPriceResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetSwapPriceResponse overwrites any union data inside the GetSwapPriceResponseWrapper as the provided GetSwapPriceResponse
func (t *GetSwapPriceResponseWrapper) FromGetSwapPriceResponse(v GetSwapPriceResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetSwapPriceResponse performs a merge with any union data inside the GetSwapPriceResponseWrapper, using the provided GetSwapPriceResponse
func (t *GetSwapPriceResponseWrapper) MergeGetSwapPriceResponse(v GetSwapPriceResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSwapUnavailableResponse returns the union data inside the GetSwapPriceResponseWrapper as a SwapUnavailableResponse
func (t GetSwapPriceResponseWrapper) AsSwapUnavailableResponse() (SwapUnavailableResponse, error) {
	var body SwapUnavailableResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSwapUnavailableResponse overwrites any union data inside the GetSwapPriceResponseWrapper as the provided SwapUnavailableResponse
func (t *GetSwapPriceResponseWrapper) FromSwapUnavailableResponse(v SwapUnavailableResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSwapUnavailableResponse performs a merge with any union data inside the GetSwapPriceResponseWrapper, using the provided SwapUnavailableResponse
func (t *GetSwapPriceResponseWrapper) MergeSwapUnavailableResponse(v SwapUnavailableResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetSwapPriceResponseWrapper) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetSwapPriceResponseWrapper) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSignEvmTransactionRule returns the union data inside the Rule as a SignEvmTransactionRule
func (t Rule) AsSignEvmTransactionRule() (SignEvmTransactionRule, error) {
	var body SignEvmTransactionRule
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSignEvmTransactionRule overwrites any union data inside the Rule as the provided SignEvmTransactionRule
func (t *Rule) FromSignEvmTransactionRule(v SignEvmTransactionRule) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSignEvmTransactionRule performs a merge with any union data inside the Rule, using the provided SignEvmTransactionRule
func (t *Rule) MergeSignEvmTransactionRule(v SignEvmTransactionRule) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSendEvmTransactionRule returns the union data inside the Rule as a SendEvmTransactionRule
func (t Rule) AsSendEvmTransactionRule() (SendEvmTransactionRule, error) {
	var body SendEvmTransactionRule
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSendEvmTransactionRule overwrites any union data inside the Rule as the provided SendEvmTransactionRule
func (t *Rule) FromSendEvmTransactionRule(v SendEvmTransactionRule) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSendEvmTransactionRule performs a merge with any union data inside the Rule, using the provided SendEvmTransactionRule
func (t *Rule) MergeSendEvmTransactionRule(v SendEvmTransactionRule) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSignEvmMessageRule returns the union data inside the Rule as a SignEvmMessageRule
func (t Rule) AsSignEvmMessageRule() (SignEvmMessageRule, error) {
	var body SignEvmMessageRule
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSignEvmMessageRule overwrites any union data inside the Rule as the provided SignEvmMessageRule
func (t *Rule) FromSignEvmMessageRule(v SignEvmMessageRule) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSignEvmMessageRule performs a merge with any union data inside the Rule, using the provided SignEvmMessageRule
func (t *Rule) MergeSignEvmMessageRule(v SignEvmMessageRule) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSignSolTransactionRule returns the union data inside the Rule as a SignSolTransactionRule
func (t Rule) AsSignSolTransactionRule() (SignSolTransactionRule, error) {
	var body SignSolTransactionRule
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSignSolTransactionRule overwrites any union data inside the Rule as the provided SignSolTransactionRule
func (t *Rule) FromSignSolTransactionRule(v SignSolTransactionRule) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSignSolTransactionRule performs a merge with any union data inside the Rule, using the provided SignSolTransactionRule
func (t *Rule) MergeSignSolTransactionRule(v SignSolTransactionRule) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSignEvmHashRule returns the union data inside the Rule as a SignEvmHashRule
func (t Rule) AsSignEvmHashRule() (SignEvmHashRule, error) {
	var body SignEvmHashRule
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSignEvmHashRule overwrites any union data inside the Rule as the provided SignEvmHashRule
func (t *Rule) FromSignEvmHashRule(v SignEvmHashRule) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSignEvmHashRule performs a merge with any union data inside the Rule, using the provided SignEvmHashRule
func (t *Rule) MergeSignEvmHashRule(v SignEvmHashRule) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t Rule) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Rule) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsEthValueCriterion returns the union data inside the SendEvmTransactionCriteria_Item as a EthValueCriterion
func (t SendEvmTransactionCriteria_Item) AsEthValueCriterion() (EthValueCriterion, error) {
	var body EthValueCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEthValueCriterion overwrites any union data inside the SendEvmTransactionCriteria_Item as the provided EthValueCriterion
func (t *SendEvmTransactionCriteria_Item) FromEthValueCriterion(v EthValueCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEthValueCriterion performs a merge with any union data inside the SendEvmTransactionCriteria_Item, using the provided EthValueCriterion
func (t *SendEvmTransactionCriteria_Item) MergeEthValueCriterion(v EthValueCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsEvmAddressCriterion returns the union data inside the SendEvmTransactionCriteria_Item as a EvmAddressCriterion
func (t SendEvmTransactionCriteria_Item) AsEvmAddressCriterion() (EvmAddressCriterion, error) {
	var body EvmAddressCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEvmAddressCriterion overwrites any union data inside the SendEvmTransactionCriteria_Item as the provided EvmAddressCriterion
func (t *SendEvmTransactionCriteria_Item) FromEvmAddressCriterion(v EvmAddressCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEvmAddressCriterion performs a merge with any union data inside the SendEvmTransactionCriteria_Item, using the provided EvmAddressCriterion
func (t *SendEvmTransactionCriteria_Item) MergeEvmAddressCriterion(v EvmAddressCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsEvmNetworkCriterion returns the union data inside the SendEvmTransactionCriteria_Item as a EvmNetworkCriterion
func (t SendEvmTransactionCriteria_Item) AsEvmNetworkCriterion() (EvmNetworkCriterion, error) {
	var body EvmNetworkCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEvmNetworkCriterion overwrites any union data inside the SendEvmTransactionCriteria_Item as the provided EvmNetworkCriterion
func (t *SendEvmTransactionCriteria_Item) FromEvmNetworkCriterion(v EvmNetworkCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEvmNetworkCriterion performs a merge with any union data inside the SendEvmTransactionCriteria_Item, using the provided EvmNetworkCriterion
func (t *SendEvmTransactionCriteria_Item) MergeEvmNetworkCriterion(v EvmNetworkCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsEvmDataCriterion returns the union data inside the SendEvmTransactionCriteria_Item as a EvmDataCriterion
func (t SendEvmTransactionCriteria_Item) AsEvmDataCriterion() (EvmDataCriterion, error) {
	var body EvmDataCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEvmDataCriterion overwrites any union data inside the SendEvmTransactionCriteria_Item as the provided EvmDataCriterion
func (t *SendEvmTransactionCriteria_Item) FromEvmDataCriterion(v EvmDataCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEvmDataCriterion performs a merge with any union data inside the SendEvmTransactionCriteria_Item, using the provided EvmDataCriterion
func (t *SendEvmTransactionCriteria_Item) MergeEvmDataCriterion(v EvmDataCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t SendEvmTransactionCriteria_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SendEvmTransactionCriteria_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsEvmMessageCriterion returns the union data inside the SignEvmMessageCriteria_Item as a EvmMessageCriterion
func (t SignEvmMessageCriteria_Item) AsEvmMessageCriterion() (EvmMessageCriterion, error) {
	var body EvmMessageCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEvmMessageCriterion overwrites any union data inside the SignEvmMessageCriteria_Item as the provided EvmMessageCriterion
func (t *SignEvmMessageCriteria_Item) FromEvmMessageCriterion(v EvmMessageCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEvmMessageCriterion performs a merge with any union data inside the SignEvmMessageCriteria_Item, using the provided EvmMessageCriterion
func (t *SignEvmMessageCriteria_Item) MergeEvmMessageCriterion(v EvmMessageCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t SignEvmMessageCriteria_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SignEvmMessageCriteria_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsEthValueCriterion returns the union data inside the SignEvmTransactionCriteria_Item as a EthValueCriterion
func (t SignEvmTransactionCriteria_Item) AsEthValueCriterion() (EthValueCriterion, error) {
	var body EthValueCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEthValueCriterion overwrites any union data inside the SignEvmTransactionCriteria_Item as the provided EthValueCriterion
func (t *SignEvmTransactionCriteria_Item) FromEthValueCriterion(v EthValueCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEthValueCriterion performs a merge with any union data inside the SignEvmTransactionCriteria_Item, using the provided EthValueCriterion
func (t *SignEvmTransactionCriteria_Item) MergeEthValueCriterion(v EthValueCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsEvmAddressCriterion returns the union data inside the SignEvmTransactionCriteria_Item as a EvmAddressCriterion
func (t SignEvmTransactionCriteria_Item) AsEvmAddressCriterion() (EvmAddressCriterion, error) {
	var body EvmAddressCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEvmAddressCriterion overwrites any union data inside the SignEvmTransactionCriteria_Item as the provided EvmAddressCriterion
func (t *SignEvmTransactionCriteria_Item) FromEvmAddressCriterion(v EvmAddressCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEvmAddressCriterion performs a merge with any union data inside the SignEvmTransactionCriteria_Item, using the provided EvmAddressCriterion
func (t *SignEvmTransactionCriteria_Item) MergeEvmAddressCriterion(v EvmAddressCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsEvmDataCriterion returns the union data inside the SignEvmTransactionCriteria_Item as a EvmDataCriterion
func (t SignEvmTransactionCriteria_Item) AsEvmDataCriterion() (EvmDataCriterion, error) {
	var body EvmDataCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEvmDataCriterion overwrites any union data inside the SignEvmTransactionCriteria_Item as the provided EvmDataCriterion
func (t *SignEvmTransactionCriteria_Item) FromEvmDataCriterion(v EvmDataCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEvmDataCriterion performs a merge with any union data inside the SignEvmTransactionCriteria_Item, using the provided EvmDataCriterion
func (t *SignEvmTransactionCriteria_Item) MergeEvmDataCriterion(v EvmDataCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t SignEvmTransactionCriteria_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SignEvmTransactionCriteria_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSolAddressCriterion returns the union data inside the SignSolTransactionCriteria_Item as a SolAddressCriterion
func (t SignSolTransactionCriteria_Item) AsSolAddressCriterion() (SolAddressCriterion, error) {
	var body SolAddressCriterion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSolAddressCriterion overwrites any union data inside the SignSolTransactionCriteria_Item as the provided SolAddressCriterion
func (t *SignSolTransactionCriteria_Item) FromSolAddressCriterion(v SolAddressCriterion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSolAddressCriterion performs a merge with any union data inside the SignSolTransactionCriteria_Item, using the provided SolAddressCriterion
func (t *SignSolTransactionCriteria_Item) MergeSolAddressCriterion(v SolAddressCriterion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t SignSolTransactionCriteria_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SignSolTransactionCriteria_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPaymentMethodRequest returns the union data inside the Transfer_Source as a PaymentMethodRequest
func (t Transfer_Source) AsPaymentMethodRequest() (PaymentMethodRequest, error) {
	var body PaymentMethodRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPaymentMethodRequest overwrites any union data inside the Transfer_Source as the provided PaymentMethodRequest
func (t *Transfer_Source) FromPaymentMethodRequest(v PaymentMethodRequest) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePaymentMethodRequest performs a merge with any union data inside the Transfer_Source, using the provided PaymentMethodRequest
func (t *Transfer_Source) MergePaymentMethodRequest(v PaymentMethodRequest) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t Transfer_Source) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Transfer_Source) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCryptoRailAddress returns the union data inside the Transfer_Target as a CryptoRailAddress
func (t Transfer_Target) AsCryptoRailAddress() (CryptoRailAddress, error) {
	var body CryptoRailAddress
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCryptoRailAddress overwrites any union data inside the Transfer_Target as the provided CryptoRailAddress
func (t *Transfer_Target) FromCryptoRailAddress(v CryptoRailAddress) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCryptoRailAddress performs a merge with any union data inside the Transfer_Target, using the provided CryptoRailAddress
func (t *Transfer_Target) MergeCryptoRailAddress(v CryptoRailAddress) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t Transfer_Target) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Transfer_Target) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPaymentMethodRequest returns the union data inside the TransferSource as a PaymentMethodRequest
func (t TransferSource) AsPaymentMethodRequest() (PaymentMethodRequest, error) {
	var body PaymentMethodRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPaymentMethodRequest overwrites any union data inside the TransferSource as the provided PaymentMethodRequest
func (t *TransferSource) FromPaymentMethodRequest(v PaymentMethodRequest) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePaymentMethodRequest performs a merge with any union data inside the TransferSource, using the provided PaymentMethodRequest
func (t *TransferSource) MergePaymentMethodRequest(v PaymentMethodRequest) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t TransferSource) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *TransferSource) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCryptoRailAddress returns the union data inside the TransferTarget as a CryptoRailAddress
func (t TransferTarget) AsCryptoRailAddress() (CryptoRailAddress, error) {
	var body CryptoRailAddress
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCryptoRailAddress overwrites any union data inside the TransferTarget as the provided CryptoRailAddress
func (t *TransferTarget) FromCryptoRailAddress(v CryptoRailAddress) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCryptoRailAddress performs a merge with any union data inside the TransferTarget, using the provided CryptoRailAddress
func (t *TransferTarget) MergeCryptoRailAddress(v CryptoRailAddress) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t TransferTarget) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *TransferTarget) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// CDPClient which conforms to the OpenAPI3 specification for this service.
type CDPClient struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*CDPClient) error

// Creates a new CDPClient, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*CDPClient, error) {
	// create a client with sane default values
	client := CDPClient{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *CDPClient) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *CDPClient) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListEvmAccounts request
	ListEvmAccounts(ctx context.Context, params *ListEvmAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateEvmAccountWithBody request with any body
	CreateEvmAccountWithBody(ctx context.Context, params *CreateEvmAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateEvmAccount(ctx context.Context, params *CreateEvmAccountParams, body CreateEvmAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEvmAccountByName request
	GetEvmAccountByName(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExportEvmAccountByNameWithBody request with any body
	ExportEvmAccountByNameWithBody(ctx context.Context, name string, params *ExportEvmAccountByNameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ExportEvmAccountByName(ctx context.Context, name string, params *ExportEvmAccountByNameParams, body ExportEvmAccountByNameJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ImportEvmAccountWithBody request with any body
	ImportEvmAccountWithBody(ctx context.Context, params *ImportEvmAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ImportEvmAccount(ctx context.Context, params *ImportEvmAccountParams, body ImportEvmAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEvmAccount request
	GetEvmAccount(ctx context.Context, address string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateEvmAccountWithBody request with any body
	UpdateEvmAccountWithBody(ctx context.Context, address string, params *UpdateEvmAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateEvmAccount(ctx context.Context, address string, params *UpdateEvmAccountParams, body UpdateEvmAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExportEvmAccountWithBody request with any body
	ExportEvmAccountWithBody(ctx context.Context, address string, params *ExportEvmAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ExportEvmAccount(ctx context.Context, address string, params *ExportEvmAccountParams, body ExportEvmAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendEvmTransactionWithBody request with any body
	SendEvmTransactionWithBody(ctx context.Context, address string, params *SendEvmTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SendEvmTransaction(ctx context.Context, address string, params *SendEvmTransactionParams, body SendEvmTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SignEvmHashWithBody request with any body
	SignEvmHashWithBody(ctx context.Context, address string, params *SignEvmHashParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SignEvmHash(ctx context.Context, address string, params *SignEvmHashParams, body SignEvmHashJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SignEvmMessageWithBody request with any body
	SignEvmMessageWithBody(ctx context.Context, address string, params *SignEvmMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SignEvmMessage(ctx context.Context, address string, params *SignEvmMessageParams, body SignEvmMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SignEvmTransactionWithBody request with any body
	SignEvmTransactionWithBody(ctx context.Context, address string, params *SignEvmTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SignEvmTransaction(ctx context.Context, address string, params *SignEvmTransactionParams, body SignEvmTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SignEvmTypedDataWithBody request with any body
	SignEvmTypedDataWithBody(ctx context.Context, address string, params *SignEvmTypedDataParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SignEvmTypedData(ctx context.Context, address string, params *SignEvmTypedDataParams, body SignEvmTypedDataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RequestEvmFaucetWithBody request with any body
	RequestEvmFaucetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RequestEvmFaucet(ctx context.Context, body RequestEvmFaucetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListEvmSmartAccounts request
	ListEvmSmartAccounts(ctx context.Context, params *ListEvmSmartAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateEvmSmartAccountWithBody request with any body
	CreateEvmSmartAccountWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateEvmSmartAccount(ctx context.Context, body CreateEvmSmartAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEvmSmartAccountByName request
	GetEvmSmartAccountByName(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEvmSmartAccount request
	GetEvmSmartAccount(ctx context.Context, address string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PrepareUserOperationWithBody request with any body
	PrepareUserOperationWithBody(ctx context.Context, address string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PrepareUserOperation(ctx context.Context, address string, body PrepareUserOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserOperation request
	GetUserOperation(ctx context.Context, address string, userOpHash string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendUserOperationWithBody request with any body
	SendUserOperationWithBody(ctx context.Context, address string, userOpHash string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SendUserOperation(ctx context.Context, address string, userOpHash string, body SendUserOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateEvmSwapQuoteWithBody request with any body
	CreateEvmSwapQuoteWithBody(ctx context.Context, params *CreateEvmSwapQuoteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateEvmSwapQuote(ctx context.Context, params *CreateEvmSwapQuoteParams, body CreateEvmSwapQuoteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEvmSwapPrice request
	GetEvmSwapPrice(ctx context.Context, params *GetEvmSwapPriceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListEvmTokenBalances request
	ListEvmTokenBalances(ctx context.Context, network ListEvmTokenBalancesNetwork, address string, params *ListEvmTokenBalancesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCryptoRails request
	GetCryptoRails(ctx context.Context, params *GetCryptoRailsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPaymentMethods request
	GetPaymentMethods(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePaymentTransferQuoteWithBody request with any body
	CreatePaymentTransferQuoteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePaymentTransferQuote(ctx context.Context, body CreatePaymentTransferQuoteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPaymentTransfer request
	GetPaymentTransfer(ctx context.Context, transferId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExecutePaymentTransferQuote request
	ExecutePaymentTransferQuote(ctx context.Context, transferId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPolicies request
	ListPolicies(ctx context.Context, params *ListPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePolicyWithBody request with any body
	CreatePolicyWithBody(ctx context.Context, params *CreatePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePolicy(ctx context.Context, params *CreatePolicyParams, body CreatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePolicy request
	DeletePolicy(ctx context.Context, policyId string, params *DeletePolicyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPolicyById request
	GetPolicyById(ctx context.Context, policyId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePolicyWithBody request with any body
	UpdatePolicyWithBody(ctx context.Context, policyId string, params *UpdatePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePolicy(ctx context.Context, policyId string, params *UpdatePolicyParams, body UpdatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSolanaAccounts request
	ListSolanaAccounts(ctx context.Context, params *ListSolanaAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSolanaAccountWithBody request with any body
	CreateSolanaAccountWithBody(ctx context.Context, params *CreateSolanaAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSolanaAccount(ctx context.Context, params *CreateSolanaAccountParams, body CreateSolanaAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSolanaAccountByName request
	GetSolanaAccountByName(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExportSolanaAccountByNameWithBody request with any body
	ExportSolanaAccountByNameWithBody(ctx context.Context, name string, params *ExportSolanaAccountByNameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ExportSolanaAccountByName(ctx context.Context, name string, params *ExportSolanaAccountByNameParams, body ExportSolanaAccountByNameJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSolanaAccount request
	GetSolanaAccount(ctx context.Context, address string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSolanaAccountWithBody request with any body
	UpdateSolanaAccountWithBody(ctx context.Context, address string, params *UpdateSolanaAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSolanaAccount(ctx context.Context, address string, params *UpdateSolanaAccountParams, body UpdateSolanaAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExportSolanaAccountWithBody request with any body
	ExportSolanaAccountWithBody(ctx context.Context, address string, params *ExportSolanaAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ExportSolanaAccount(ctx context.Context, address string, params *ExportSolanaAccountParams, body ExportSolanaAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SignSolanaMessageWithBody request with any body
	SignSolanaMessageWithBody(ctx context.Context, address string, params *SignSolanaMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SignSolanaMessage(ctx context.Context, address string, params *SignSolanaMessageParams, body SignSolanaMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SignSolanaTransactionWithBody request with any body
	SignSolanaTransactionWithBody(ctx context.Context, address string, params *SignSolanaTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SignSolanaTransaction(ctx context.Context, address string, params *SignSolanaTransactionParams, body SignSolanaTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RequestSolanaFaucetWithBody request with any body
	RequestSolanaFaucetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RequestSolanaFaucet(ctx context.Context, body RequestSolanaFaucetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *CDPClient) ListEvmAccounts(ctx context.Context, params *ListEvmAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListEvmAccountsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) CreateEvmAccountWithBody(ctx context.Context, params *CreateEvmAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEvmAccountRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) CreateEvmAccount(ctx context.Context, params *CreateEvmAccountParams, body CreateEvmAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEvmAccountRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) GetEvmAccountByName(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEvmAccountByNameRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) ExportEvmAccountByNameWithBody(ctx context.Context, name string, params *ExportEvmAccountByNameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportEvmAccountByNameRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) ExportEvmAccountByName(ctx context.Context, name string, params *ExportEvmAccountByNameParams, body ExportEvmAccountByNameJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportEvmAccountByNameRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) ImportEvmAccountWithBody(ctx context.Context, params *ImportEvmAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportEvmAccountRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) ImportEvmAccount(ctx context.Context, params *ImportEvmAccountParams, body ImportEvmAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportEvmAccountRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) GetEvmAccount(ctx context.Context, address string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEvmAccountRequest(c.Server, address)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) UpdateEvmAccountWithBody(ctx context.Context, address string, params *UpdateEvmAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEvmAccountRequestWithBody(c.Server, address, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) UpdateEvmAccount(ctx context.Context, address string, params *UpdateEvmAccountParams, body UpdateEvmAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEvmAccountRequest(c.Server, address, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) ExportEvmAccountWithBody(ctx context.Context, address string, params *ExportEvmAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportEvmAccountRequestWithBody(c.Server, address, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) ExportEvmAccount(ctx context.Context, address string, params *ExportEvmAccountParams, body ExportEvmAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportEvmAccountRequest(c.Server, address, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SendEvmTransactionWithBody(ctx context.Context, address string, params *SendEvmTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendEvmTransactionRequestWithBody(c.Server, address, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SendEvmTransaction(ctx context.Context, address string, params *SendEvmTransactionParams, body SendEvmTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendEvmTransactionRequest(c.Server, address, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SignEvmHashWithBody(ctx context.Context, address string, params *SignEvmHashParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSignEvmHashRequestWithBody(c.Server, address, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SignEvmHash(ctx context.Context, address string, params *SignEvmHashParams, body SignEvmHashJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSignEvmHashRequest(c.Server, address, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SignEvmMessageWithBody(ctx context.Context, address string, params *SignEvmMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSignEvmMessageRequestWithBody(c.Server, address, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SignEvmMessage(ctx context.Context, address string, params *SignEvmMessageParams, body SignEvmMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSignEvmMessageRequest(c.Server, address, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SignEvmTransactionWithBody(ctx context.Context, address string, params *SignEvmTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSignEvmTransactionRequestWithBody(c.Server, address, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SignEvmTransaction(ctx context.Context, address string, params *SignEvmTransactionParams, body SignEvmTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSignEvmTransactionRequest(c.Server, address, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SignEvmTypedDataWithBody(ctx context.Context, address string, params *SignEvmTypedDataParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSignEvmTypedDataRequestWithBody(c.Server, address, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SignEvmTypedData(ctx context.Context, address string, params *SignEvmTypedDataParams, body SignEvmTypedDataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSignEvmTypedDataRequest(c.Server, address, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) RequestEvmFaucetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRequestEvmFaucetRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) RequestEvmFaucet(ctx context.Context, body RequestEvmFaucetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRequestEvmFaucetRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) ListEvmSmartAccounts(ctx context.Context, params *ListEvmSmartAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListEvmSmartAccountsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) CreateEvmSmartAccountWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEvmSmartAccountRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) CreateEvmSmartAccount(ctx context.Context, body CreateEvmSmartAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEvmSmartAccountRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) GetEvmSmartAccountByName(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEvmSmartAccountByNameRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) GetEvmSmartAccount(ctx context.Context, address string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEvmSmartAccountRequest(c.Server, address)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) PrepareUserOperationWithBody(ctx context.Context, address string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPrepareUserOperationRequestWithBody(c.Server, address, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) PrepareUserOperation(ctx context.Context, address string, body PrepareUserOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPrepareUserOperationRequest(c.Server, address, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) GetUserOperation(ctx context.Context, address string, userOpHash string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserOperationRequest(c.Server, address, userOpHash)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SendUserOperationWithBody(ctx context.Context, address string, userOpHash string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendUserOperationRequestWithBody(c.Server, address, userOpHash, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SendUserOperation(ctx context.Context, address string, userOpHash string, body SendUserOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendUserOperationRequest(c.Server, address, userOpHash, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) CreateEvmSwapQuoteWithBody(ctx context.Context, params *CreateEvmSwapQuoteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEvmSwapQuoteRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) CreateEvmSwapQuote(ctx context.Context, params *CreateEvmSwapQuoteParams, body CreateEvmSwapQuoteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEvmSwapQuoteRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) GetEvmSwapPrice(ctx context.Context, params *GetEvmSwapPriceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEvmSwapPriceRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) ListEvmTokenBalances(ctx context.Context, network ListEvmTokenBalancesNetwork, address string, params *ListEvmTokenBalancesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListEvmTokenBalancesRequest(c.Server, network, address, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) GetCryptoRails(ctx context.Context, params *GetCryptoRailsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCryptoRailsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) GetPaymentMethods(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPaymentMethodsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) CreatePaymentTransferQuoteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePaymentTransferQuoteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) CreatePaymentTransferQuote(ctx context.Context, body CreatePaymentTransferQuoteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePaymentTransferQuoteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) GetPaymentTransfer(ctx context.Context, transferId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPaymentTransferRequest(c.Server, transferId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) ExecutePaymentTransferQuote(ctx context.Context, transferId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExecutePaymentTransferQuoteRequest(c.Server, transferId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) ListPolicies(ctx context.Context, params *ListPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) CreatePolicyWithBody(ctx context.Context, params *CreatePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePolicyRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) CreatePolicy(ctx context.Context, params *CreatePolicyParams, body CreatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePolicyRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) DeletePolicy(ctx context.Context, policyId string, params *DeletePolicyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePolicyRequest(c.Server, policyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) GetPolicyById(ctx context.Context, policyId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPolicyByIdRequest(c.Server, policyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) UpdatePolicyWithBody(ctx context.Context, policyId string, params *UpdatePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePolicyRequestWithBody(c.Server, policyId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) UpdatePolicy(ctx context.Context, policyId string, params *UpdatePolicyParams, body UpdatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePolicyRequest(c.Server, policyId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) ListSolanaAccounts(ctx context.Context, params *ListSolanaAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSolanaAccountsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) CreateSolanaAccountWithBody(ctx context.Context, params *CreateSolanaAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSolanaAccountRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) CreateSolanaAccount(ctx context.Context, params *CreateSolanaAccountParams, body CreateSolanaAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSolanaAccountRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) GetSolanaAccountByName(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSolanaAccountByNameRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) ExportSolanaAccountByNameWithBody(ctx context.Context, name string, params *ExportSolanaAccountByNameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportSolanaAccountByNameRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) ExportSolanaAccountByName(ctx context.Context, name string, params *ExportSolanaAccountByNameParams, body ExportSolanaAccountByNameJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportSolanaAccountByNameRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) GetSolanaAccount(ctx context.Context, address string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSolanaAccountRequest(c.Server, address)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) UpdateSolanaAccountWithBody(ctx context.Context, address string, params *UpdateSolanaAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSolanaAccountRequestWithBody(c.Server, address, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) UpdateSolanaAccount(ctx context.Context, address string, params *UpdateSolanaAccountParams, body UpdateSolanaAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSolanaAccountRequest(c.Server, address, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) ExportSolanaAccountWithBody(ctx context.Context, address string, params *ExportSolanaAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportSolanaAccountRequestWithBody(c.Server, address, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) ExportSolanaAccount(ctx context.Context, address string, params *ExportSolanaAccountParams, body ExportSolanaAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportSolanaAccountRequest(c.Server, address, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SignSolanaMessageWithBody(ctx context.Context, address string, params *SignSolanaMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSignSolanaMessageRequestWithBody(c.Server, address, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SignSolanaMessage(ctx context.Context, address string, params *SignSolanaMessageParams, body SignSolanaMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSignSolanaMessageRequest(c.Server, address, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SignSolanaTransactionWithBody(ctx context.Context, address string, params *SignSolanaTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSignSolanaTransactionRequestWithBody(c.Server, address, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SignSolanaTransaction(ctx context.Context, address string, params *SignSolanaTransactionParams, body SignSolanaTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSignSolanaTransactionRequest(c.Server, address, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) RequestSolanaFaucetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRequestSolanaFaucetRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) RequestSolanaFaucet(ctx context.Context, body RequestSolanaFaucetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRequestSolanaFaucetRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListEvmAccountsRequest generates requests for ListEvmAccounts
func NewListEvmAccountsRequest(server string, params *ListEvmAccountsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/accounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateEvmAccountRequest calls the generic CreateEvmAccount builder with application/json body
func NewCreateEvmAccountRequest(server string, params *CreateEvmAccountParams, body CreateEvmAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateEvmAccountRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateEvmAccountRequestWithBody generates requests for CreateEvmAccount with any type of body
func NewCreateEvmAccountRequestWithBody(server string, params *CreateEvmAccountParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/accounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XWalletAuth != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Wallet-Auth", runtime.ParamLocationHeader, *params.XWalletAuth)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Wallet-Auth", headerParam0)
		}

		if params.XIdempotencyKey != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam1)
		}

	}

	return req, nil
}

// NewGetEvmAccountByNameRequest generates requests for GetEvmAccountByName
func NewGetEvmAccountByNameRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/accounts/by-name/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExportEvmAccountByNameRequest calls the generic ExportEvmAccountByName builder with application/json body
func NewExportEvmAccountByNameRequest(server string, name string, params *ExportEvmAccountByNameParams, body ExportEvmAccountByNameJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExportEvmAccountByNameRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewExportEvmAccountByNameRequestWithBody generates requests for ExportEvmAccountByName with any type of body
func NewExportEvmAccountByNameRequestWithBody(server string, name string, params *ExportEvmAccountByNameParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/accounts/export/by-name/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XWalletAuth != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Wallet-Auth", runtime.ParamLocationHeader, *params.XWalletAuth)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Wallet-Auth", headerParam0)
		}

		if params.XIdempotencyKey != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam1)
		}

	}

	return req, nil
}

// NewImportEvmAccountRequest calls the generic ImportEvmAccount builder with application/json body
func NewImportEvmAccountRequest(server string, params *ImportEvmAccountParams, body ImportEvmAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewImportEvmAccountRequestWithBody(server, params, "application/json", bodyReader)
}

// NewImportEvmAccountRequestWithBody generates requests for ImportEvmAccount with any type of body
func NewImportEvmAccountRequestWithBody(server string, params *ImportEvmAccountParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/accounts/import")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XWalletAuth != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Wallet-Auth", runtime.ParamLocationHeader, *params.XWalletAuth)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Wallet-Auth", headerParam0)
		}

		if params.XIdempotencyKey != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam1)
		}

	}

	return req, nil
}

// NewGetEvmAccountRequest generates requests for GetEvmAccount
func NewGetEvmAccountRequest(server string, address string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/accounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateEvmAccountRequest calls the generic UpdateEvmAccount builder with application/json body
func NewUpdateEvmAccountRequest(server string, address string, params *UpdateEvmAccountParams, body UpdateEvmAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateEvmAccountRequestWithBody(server, address, params, "application/json", bodyReader)
}

// NewUpdateEvmAccountRequestWithBody generates requests for UpdateEvmAccount with any type of body
func NewUpdateEvmAccountRequestWithBody(server string, address string, params *UpdateEvmAccountParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/accounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XIdempotencyKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam0)
		}

	}

	return req, nil
}

// NewExportEvmAccountRequest calls the generic ExportEvmAccount builder with application/json body
func NewExportEvmAccountRequest(server string, address string, params *ExportEvmAccountParams, body ExportEvmAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExportEvmAccountRequestWithBody(server, address, params, "application/json", bodyReader)
}

// NewExportEvmAccountRequestWithBody generates requests for ExportEvmAccount with any type of body
func NewExportEvmAccountRequestWithBody(server string, address string, params *ExportEvmAccountParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/accounts/%s/export", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XWalletAuth != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Wallet-Auth", runtime.ParamLocationHeader, *params.XWalletAuth)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Wallet-Auth", headerParam0)
		}

		if params.XIdempotencyKey != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam1)
		}

	}

	return req, nil
}

// NewSendEvmTransactionRequest calls the generic SendEvmTransaction builder with application/json body
func NewSendEvmTransactionRequest(server string, address string, params *SendEvmTransactionParams, body SendEvmTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSendEvmTransactionRequestWithBody(server, address, params, "application/json", bodyReader)
}

// NewSendEvmTransactionRequestWithBody generates requests for SendEvmTransaction with any type of body
func NewSendEvmTransactionRequestWithBody(server string, address string, params *SendEvmTransactionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/accounts/%s/send/transaction", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XWalletAuth != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Wallet-Auth", runtime.ParamLocationHeader, *params.XWalletAuth)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Wallet-Auth", headerParam0)
		}

		if params.XIdempotencyKey != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam1)
		}

	}

	return req, nil
}

// NewSignEvmHashRequest calls the generic SignEvmHash builder with application/json body
func NewSignEvmHashRequest(server string, address string, params *SignEvmHashParams, body SignEvmHashJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSignEvmHashRequestWithBody(server, address, params, "application/json", bodyReader)
}

// NewSignEvmHashRequestWithBody generates requests for SignEvmHash with any type of body
func NewSignEvmHashRequestWithBody(server string, address string, params *SignEvmHashParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/accounts/%s/sign", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XWalletAuth != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Wallet-Auth", runtime.ParamLocationHeader, *params.XWalletAuth)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Wallet-Auth", headerParam0)
		}

		if params.XIdempotencyKey != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam1)
		}

	}

	return req, nil
}

// NewSignEvmMessageRequest calls the generic SignEvmMessage builder with application/json body
func NewSignEvmMessageRequest(server string, address string, params *SignEvmMessageParams, body SignEvmMessageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSignEvmMessageRequestWithBody(server, address, params, "application/json", bodyReader)
}

// NewSignEvmMessageRequestWithBody generates requests for SignEvmMessage with any type of body
func NewSignEvmMessageRequestWithBody(server string, address string, params *SignEvmMessageParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/accounts/%s/sign/message", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XWalletAuth != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Wallet-Auth", runtime.ParamLocationHeader, *params.XWalletAuth)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Wallet-Auth", headerParam0)
		}

		if params.XIdempotencyKey != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam1)
		}

	}

	return req, nil
}

// NewSignEvmTransactionRequest calls the generic SignEvmTransaction builder with application/json body
func NewSignEvmTransactionRequest(server string, address string, params *SignEvmTransactionParams, body SignEvmTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSignEvmTransactionRequestWithBody(server, address, params, "application/json", bodyReader)
}

// NewSignEvmTransactionRequestWithBody generates requests for SignEvmTransaction with any type of body
func NewSignEvmTransactionRequestWithBody(server string, address string, params *SignEvmTransactionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/accounts/%s/sign/transaction", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XWalletAuth != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Wallet-Auth", runtime.ParamLocationHeader, *params.XWalletAuth)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Wallet-Auth", headerParam0)
		}

		if params.XIdempotencyKey != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam1)
		}

	}

	return req, nil
}

// NewSignEvmTypedDataRequest calls the generic SignEvmTypedData builder with application/json body
func NewSignEvmTypedDataRequest(server string, address string, params *SignEvmTypedDataParams, body SignEvmTypedDataJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSignEvmTypedDataRequestWithBody(server, address, params, "application/json", bodyReader)
}

// NewSignEvmTypedDataRequestWithBody generates requests for SignEvmTypedData with any type of body
func NewSignEvmTypedDataRequestWithBody(server string, address string, params *SignEvmTypedDataParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/accounts/%s/sign/typed-data", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XWalletAuth != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Wallet-Auth", runtime.ParamLocationHeader, *params.XWalletAuth)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Wallet-Auth", headerParam0)
		}

		if params.XIdempotencyKey != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam1)
		}

	}

	return req, nil
}

// NewRequestEvmFaucetRequest calls the generic RequestEvmFaucet builder with application/json body
func NewRequestEvmFaucetRequest(server string, body RequestEvmFaucetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRequestEvmFaucetRequestWithBody(server, "application/json", bodyReader)
}

// NewRequestEvmFaucetRequestWithBody generates requests for RequestEvmFaucet with any type of body
func NewRequestEvmFaucetRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/faucet")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListEvmSmartAccountsRequest generates requests for ListEvmSmartAccounts
func NewListEvmSmartAccountsRequest(server string, params *ListEvmSmartAccountsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/smart-accounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateEvmSmartAccountRequest calls the generic CreateEvmSmartAccount builder with application/json body
func NewCreateEvmSmartAccountRequest(server string, body CreateEvmSmartAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateEvmSmartAccountRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateEvmSmartAccountRequestWithBody generates requests for CreateEvmSmartAccount with any type of body
func NewCreateEvmSmartAccountRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/smart-accounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetEvmSmartAccountByNameRequest generates requests for GetEvmSmartAccountByName
func NewGetEvmSmartAccountByNameRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/smart-accounts/by-name/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEvmSmartAccountRequest generates requests for GetEvmSmartAccount
func NewGetEvmSmartAccountRequest(server string, address string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/smart-accounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPrepareUserOperationRequest calls the generic PrepareUserOperation builder with application/json body
func NewPrepareUserOperationRequest(server string, address string, body PrepareUserOperationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPrepareUserOperationRequestWithBody(server, address, "application/json", bodyReader)
}

// NewPrepareUserOperationRequestWithBody generates requests for PrepareUserOperation with any type of body
func NewPrepareUserOperationRequestWithBody(server string, address string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/smart-accounts/%s/user-operations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUserOperationRequest generates requests for GetUserOperation
func NewGetUserOperationRequest(server string, address string, userOpHash string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userOpHash", runtime.ParamLocationPath, userOpHash)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/smart-accounts/%s/user-operations/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSendUserOperationRequest calls the generic SendUserOperation builder with application/json body
func NewSendUserOperationRequest(server string, address string, userOpHash string, body SendUserOperationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSendUserOperationRequestWithBody(server, address, userOpHash, "application/json", bodyReader)
}

// NewSendUserOperationRequestWithBody generates requests for SendUserOperation with any type of body
func NewSendUserOperationRequestWithBody(server string, address string, userOpHash string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userOpHash", runtime.ParamLocationPath, userOpHash)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/smart-accounts/%s/user-operations/%s/send", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateEvmSwapQuoteRequest calls the generic CreateEvmSwapQuote builder with application/json body
func NewCreateEvmSwapQuoteRequest(server string, params *CreateEvmSwapQuoteParams, body CreateEvmSwapQuoteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateEvmSwapQuoteRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateEvmSwapQuoteRequestWithBody generates requests for CreateEvmSwapQuote with any type of body
func NewCreateEvmSwapQuoteRequestWithBody(server string, params *CreateEvmSwapQuoteParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/swaps")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XIdempotencyKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam0)
		}

	}

	return req, nil
}

// NewGetEvmSwapPriceRequest generates requests for GetEvmSwapPrice
func NewGetEvmSwapPriceRequest(server string, params *GetEvmSwapPriceParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/swaps/quote")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "network", runtime.ParamLocationQuery, params.Network); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "toToken", runtime.ParamLocationQuery, params.ToToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fromToken", runtime.ParamLocationQuery, params.FromToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fromAmount", runtime.ParamLocationQuery, params.FromAmount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "taker", runtime.ParamLocationQuery, params.Taker); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.SignerAddress != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "signerAddress", runtime.ParamLocationQuery, *params.SignerAddress); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GasPrice != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gasPrice", runtime.ParamLocationQuery, *params.GasPrice); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SlippageBps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "slippageBps", runtime.ParamLocationQuery, *params.SlippageBps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListEvmTokenBalancesRequest generates requests for ListEvmTokenBalances
func NewListEvmTokenBalancesRequest(server string, network ListEvmTokenBalancesNetwork, address string, params *ListEvmTokenBalancesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "network", runtime.ParamLocationPath, network)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/token-balances/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCryptoRailsRequest generates requests for GetCryptoRails
func NewGetCryptoRailsRequest(server string, params *GetCryptoRailsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/payments/rails/crypto")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Networks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "networks", runtime.ParamLocationQuery, *params.Networks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPaymentMethodsRequest generates requests for GetPaymentMethods
func NewGetPaymentMethodsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/payments/rails/payment-methods")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePaymentTransferQuoteRequest calls the generic CreatePaymentTransferQuote builder with application/json body
func NewCreatePaymentTransferQuoteRequest(server string, body CreatePaymentTransferQuoteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePaymentTransferQuoteRequestWithBody(server, "application/json", bodyReader)
}

// NewCreatePaymentTransferQuoteRequestWithBody generates requests for CreatePaymentTransferQuote with any type of body
func NewCreatePaymentTransferQuoteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/payments/transfers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPaymentTransferRequest generates requests for GetPaymentTransfer
func NewGetPaymentTransferRequest(server string, transferId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "transferId", runtime.ParamLocationPath, transferId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/payments/transfers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExecutePaymentTransferQuoteRequest generates requests for ExecutePaymentTransferQuote
func NewExecutePaymentTransferQuoteRequest(server string, transferId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "transferId", runtime.ParamLocationPath, transferId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/payments/transfers/%s/execute", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPoliciesRequest generates requests for ListPolicies
func NewListPoliciesRequest(server string, params *ListPoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/policy-engine/policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Scope != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scope", runtime.ParamLocationQuery, *params.Scope); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePolicyRequest calls the generic CreatePolicy builder with application/json body
func NewCreatePolicyRequest(server string, params *CreatePolicyParams, body CreatePolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePolicyRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreatePolicyRequestWithBody generates requests for CreatePolicy with any type of body
func NewCreatePolicyRequestWithBody(server string, params *CreatePolicyParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/policy-engine/policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XIdempotencyKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam0)
		}

	}

	return req, nil
}

// NewDeletePolicyRequest generates requests for DeletePolicy
func NewDeletePolicyRequest(server string, policyId string, params *DeletePolicyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "policyId", runtime.ParamLocationPath, policyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/policy-engine/policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XIdempotencyKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam0)
		}

	}

	return req, nil
}

// NewGetPolicyByIdRequest generates requests for GetPolicyById
func NewGetPolicyByIdRequest(server string, policyId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "policyId", runtime.ParamLocationPath, policyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/policy-engine/policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePolicyRequest calls the generic UpdatePolicy builder with application/json body
func NewUpdatePolicyRequest(server string, policyId string, params *UpdatePolicyParams, body UpdatePolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePolicyRequestWithBody(server, policyId, params, "application/json", bodyReader)
}

// NewUpdatePolicyRequestWithBody generates requests for UpdatePolicy with any type of body
func NewUpdatePolicyRequestWithBody(server string, policyId string, params *UpdatePolicyParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "policyId", runtime.ParamLocationPath, policyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/policy-engine/policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XIdempotencyKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam0)
		}

	}

	return req, nil
}

// NewListSolanaAccountsRequest generates requests for ListSolanaAccounts
func NewListSolanaAccountsRequest(server string, params *ListSolanaAccountsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/solana/accounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSolanaAccountRequest calls the generic CreateSolanaAccount builder with application/json body
func NewCreateSolanaAccountRequest(server string, params *CreateSolanaAccountParams, body CreateSolanaAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSolanaAccountRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateSolanaAccountRequestWithBody generates requests for CreateSolanaAccount with any type of body
func NewCreateSolanaAccountRequestWithBody(server string, params *CreateSolanaAccountParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/solana/accounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XWalletAuth != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Wallet-Auth", runtime.ParamLocationHeader, *params.XWalletAuth)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Wallet-Auth", headerParam0)
		}

		if params.XIdempotencyKey != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam1)
		}

	}

	return req, nil
}

// NewGetSolanaAccountByNameRequest generates requests for GetSolanaAccountByName
func NewGetSolanaAccountByNameRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/solana/accounts/by-name/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExportSolanaAccountByNameRequest calls the generic ExportSolanaAccountByName builder with application/json body
func NewExportSolanaAccountByNameRequest(server string, name string, params *ExportSolanaAccountByNameParams, body ExportSolanaAccountByNameJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExportSolanaAccountByNameRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewExportSolanaAccountByNameRequestWithBody generates requests for ExportSolanaAccountByName with any type of body
func NewExportSolanaAccountByNameRequestWithBody(server string, name string, params *ExportSolanaAccountByNameParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/solana/accounts/export/by-name/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XWalletAuth != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Wallet-Auth", runtime.ParamLocationHeader, *params.XWalletAuth)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Wallet-Auth", headerParam0)
		}

		if params.XIdempotencyKey != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam1)
		}

	}

	return req, nil
}

// NewGetSolanaAccountRequest generates requests for GetSolanaAccount
func NewGetSolanaAccountRequest(server string, address string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/solana/accounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateSolanaAccountRequest calls the generic UpdateSolanaAccount builder with application/json body
func NewUpdateSolanaAccountRequest(server string, address string, params *UpdateSolanaAccountParams, body UpdateSolanaAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSolanaAccountRequestWithBody(server, address, params, "application/json", bodyReader)
}

// NewUpdateSolanaAccountRequestWithBody generates requests for UpdateSolanaAccount with any type of body
func NewUpdateSolanaAccountRequestWithBody(server string, address string, params *UpdateSolanaAccountParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/solana/accounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XIdempotencyKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam0)
		}

	}

	return req, nil
}

// NewExportSolanaAccountRequest calls the generic ExportSolanaAccount builder with application/json body
func NewExportSolanaAccountRequest(server string, address string, params *ExportSolanaAccountParams, body ExportSolanaAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExportSolanaAccountRequestWithBody(server, address, params, "application/json", bodyReader)
}

// NewExportSolanaAccountRequestWithBody generates requests for ExportSolanaAccount with any type of body
func NewExportSolanaAccountRequestWithBody(server string, address string, params *ExportSolanaAccountParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/solana/accounts/%s/export", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XWalletAuth != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Wallet-Auth", runtime.ParamLocationHeader, *params.XWalletAuth)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Wallet-Auth", headerParam0)
		}

		if params.XIdempotencyKey != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam1)
		}

	}

	return req, nil
}

// NewSignSolanaMessageRequest calls the generic SignSolanaMessage builder with application/json body
func NewSignSolanaMessageRequest(server string, address string, params *SignSolanaMessageParams, body SignSolanaMessageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSignSolanaMessageRequestWithBody(server, address, params, "application/json", bodyReader)
}

// NewSignSolanaMessageRequestWithBody generates requests for SignSolanaMessage with any type of body
func NewSignSolanaMessageRequestWithBody(server string, address string, params *SignSolanaMessageParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/solana/accounts/%s/sign/message", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XWalletAuth != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Wallet-Auth", runtime.ParamLocationHeader, *params.XWalletAuth)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Wallet-Auth", headerParam0)
		}

		if params.XIdempotencyKey != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam1)
		}

	}

	return req, nil
}

// NewSignSolanaTransactionRequest calls the generic SignSolanaTransaction builder with application/json body
func NewSignSolanaTransactionRequest(server string, address string, params *SignSolanaTransactionParams, body SignSolanaTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSignSolanaTransactionRequestWithBody(server, address, params, "application/json", bodyReader)
}

// NewSignSolanaTransactionRequestWithBody generates requests for SignSolanaTransaction with any type of body
func NewSignSolanaTransactionRequestWithBody(server string, address string, params *SignSolanaTransactionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/solana/accounts/%s/sign/transaction", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XWalletAuth != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Wallet-Auth", runtime.ParamLocationHeader, *params.XWalletAuth)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Wallet-Auth", headerParam0)
		}

		if params.XIdempotencyKey != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam1)
		}

	}

	return req, nil
}

// NewRequestSolanaFaucetRequest calls the generic RequestSolanaFaucet builder with application/json body
func NewRequestSolanaFaucetRequest(server string, body RequestSolanaFaucetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRequestSolanaFaucetRequestWithBody(server, "application/json", bodyReader)
}

// NewRequestSolanaFaucetRequestWithBody generates requests for RequestSolanaFaucet with any type of body
func NewRequestSolanaFaucetRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/solana/faucet")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *CDPClient) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *CDPClient) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListEvmAccountsWithResponse request
	ListEvmAccountsWithResponse(ctx context.Context, params *ListEvmAccountsParams, reqEditors ...RequestEditorFn) (*ListEvmAccountsResponse, error)

	// CreateEvmAccountWithBodyWithResponse request with any body
	CreateEvmAccountWithBodyWithResponse(ctx context.Context, params *CreateEvmAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEvmAccountResponse, error)

	CreateEvmAccountWithResponse(ctx context.Context, params *CreateEvmAccountParams, body CreateEvmAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEvmAccountResponse, error)

	// GetEvmAccountByNameWithResponse request
	GetEvmAccountByNameWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetEvmAccountByNameResponse, error)

	// ExportEvmAccountByNameWithBodyWithResponse request with any body
	ExportEvmAccountByNameWithBodyWithResponse(ctx context.Context, name string, params *ExportEvmAccountByNameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExportEvmAccountByNameResponse, error)

	ExportEvmAccountByNameWithResponse(ctx context.Context, name string, params *ExportEvmAccountByNameParams, body ExportEvmAccountByNameJSONRequestBody, reqEditors ...RequestEditorFn) (*ExportEvmAccountByNameResponse, error)

	// ImportEvmAccountWithBodyWithResponse request with any body
	ImportEvmAccountWithBodyWithResponse(ctx context.Context, params *ImportEvmAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ImportEvmAccountResponse, error)

	ImportEvmAccountWithResponse(ctx context.Context, params *ImportEvmAccountParams, body ImportEvmAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*ImportEvmAccountResponse, error)

	// GetEvmAccountWithResponse request
	GetEvmAccountWithResponse(ctx context.Context, address string, reqEditors ...RequestEditorFn) (*GetEvmAccountResponse, error)

	// UpdateEvmAccountWithBodyWithResponse request with any body
	UpdateEvmAccountWithBodyWithResponse(ctx context.Context, address string, params *UpdateEvmAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEvmAccountResponse, error)

	UpdateEvmAccountWithResponse(ctx context.Context, address string, params *UpdateEvmAccountParams, body UpdateEvmAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEvmAccountResponse, error)

	// ExportEvmAccountWithBodyWithResponse request with any body
	ExportEvmAccountWithBodyWithResponse(ctx context.Context, address string, params *ExportEvmAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExportEvmAccountResponse, error)

	ExportEvmAccountWithResponse(ctx context.Context, address string, params *ExportEvmAccountParams, body ExportEvmAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*ExportEvmAccountResponse, error)

	// SendEvmTransactionWithBodyWithResponse request with any body
	SendEvmTransactionWithBodyWithResponse(ctx context.Context, address string, params *SendEvmTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendEvmTransactionResponse, error)

	SendEvmTransactionWithResponse(ctx context.Context, address string, params *SendEvmTransactionParams, body SendEvmTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*SendEvmTransactionResponse, error)

	// SignEvmHashWithBodyWithResponse request with any body
	SignEvmHashWithBodyWithResponse(ctx context.Context, address string, params *SignEvmHashParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SignEvmHashResponse, error)

	SignEvmHashWithResponse(ctx context.Context, address string, params *SignEvmHashParams, body SignEvmHashJSONRequestBody, reqEditors ...RequestEditorFn) (*SignEvmHashResponse, error)

	// SignEvmMessageWithBodyWithResponse request with any body
	SignEvmMessageWithBodyWithResponse(ctx context.Context, address string, params *SignEvmMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SignEvmMessageResponse, error)

	SignEvmMessageWithResponse(ctx context.Context, address string, params *SignEvmMessageParams, body SignEvmMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*SignEvmMessageResponse, error)

	// SignEvmTransactionWithBodyWithResponse request with any body
	SignEvmTransactionWithBodyWithResponse(ctx context.Context, address string, params *SignEvmTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SignEvmTransactionResponse, error)

	SignEvmTransactionWithResponse(ctx context.Context, address string, params *SignEvmTransactionParams, body SignEvmTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*SignEvmTransactionResponse, error)

	// SignEvmTypedDataWithBodyWithResponse request with any body
	SignEvmTypedDataWithBodyWithResponse(ctx context.Context, address string, params *SignEvmTypedDataParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SignEvmTypedDataResponse, error)

	SignEvmTypedDataWithResponse(ctx context.Context, address string, params *SignEvmTypedDataParams, body SignEvmTypedDataJSONRequestBody, reqEditors ...RequestEditorFn) (*SignEvmTypedDataResponse, error)

	// RequestEvmFaucetWithBodyWithResponse request with any body
	RequestEvmFaucetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RequestEvmFaucetResponse, error)

	RequestEvmFaucetWithResponse(ctx context.Context, body RequestEvmFaucetJSONRequestBody, reqEditors ...RequestEditorFn) (*RequestEvmFaucetResponse, error)

	// ListEvmSmartAccountsWithResponse request
	ListEvmSmartAccountsWithResponse(ctx context.Context, params *ListEvmSmartAccountsParams, reqEditors ...RequestEditorFn) (*ListEvmSmartAccountsResponse, error)

	// CreateEvmSmartAccountWithBodyWithResponse request with any body
	CreateEvmSmartAccountWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEvmSmartAccountResponse, error)

	CreateEvmSmartAccountWithResponse(ctx context.Context, body CreateEvmSmartAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEvmSmartAccountResponse, error)

	// GetEvmSmartAccountByNameWithResponse request
	GetEvmSmartAccountByNameWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetEvmSmartAccountByNameResponse, error)

	// GetEvmSmartAccountWithResponse request
	GetEvmSmartAccountWithResponse(ctx context.Context, address string, reqEditors ...RequestEditorFn) (*GetEvmSmartAccountResponse, error)

	// PrepareUserOperationWithBodyWithResponse request with any body
	PrepareUserOperationWithBodyWithResponse(ctx context.Context, address string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PrepareUserOperationResponse, error)

	PrepareUserOperationWithResponse(ctx context.Context, address string, body PrepareUserOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*PrepareUserOperationResponse, error)

	// GetUserOperationWithResponse request
	GetUserOperationWithResponse(ctx context.Context, address string, userOpHash string, reqEditors ...RequestEditorFn) (*GetUserOperationResponse, error)

	// SendUserOperationWithBodyWithResponse request with any body
	SendUserOperationWithBodyWithResponse(ctx context.Context, address string, userOpHash string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendUserOperationResponse, error)

	SendUserOperationWithResponse(ctx context.Context, address string, userOpHash string, body SendUserOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*SendUserOperationResponse, error)

	// CreateEvmSwapQuoteWithBodyWithResponse request with any body
	CreateEvmSwapQuoteWithBodyWithResponse(ctx context.Context, params *CreateEvmSwapQuoteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEvmSwapQuoteResponse, error)

	CreateEvmSwapQuoteWithResponse(ctx context.Context, params *CreateEvmSwapQuoteParams, body CreateEvmSwapQuoteJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEvmSwapQuoteResponse, error)

	// GetEvmSwapPriceWithResponse request
	GetEvmSwapPriceWithResponse(ctx context.Context, params *GetEvmSwapPriceParams, reqEditors ...RequestEditorFn) (*GetEvmSwapPriceResponse, error)

	// ListEvmTokenBalancesWithResponse request
	ListEvmTokenBalancesWithResponse(ctx context.Context, network ListEvmTokenBalancesNetwork, address string, params *ListEvmTokenBalancesParams, reqEditors ...RequestEditorFn) (*ListEvmTokenBalancesResponse, error)

	// GetCryptoRailsWithResponse request
	GetCryptoRailsWithResponse(ctx context.Context, params *GetCryptoRailsParams, reqEditors ...RequestEditorFn) (*GetCryptoRailsResponse, error)

	// GetPaymentMethodsWithResponse request
	GetPaymentMethodsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPaymentMethodsResponse, error)

	// CreatePaymentTransferQuoteWithBodyWithResponse request with any body
	CreatePaymentTransferQuoteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePaymentTransferQuoteResponse, error)

	CreatePaymentTransferQuoteWithResponse(ctx context.Context, body CreatePaymentTransferQuoteJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePaymentTransferQuoteResponse, error)

	// GetPaymentTransferWithResponse request
	GetPaymentTransferWithResponse(ctx context.Context, transferId string, reqEditors ...RequestEditorFn) (*GetPaymentTransferResponse, error)

	// ExecutePaymentTransferQuoteWithResponse request
	ExecutePaymentTransferQuoteWithResponse(ctx context.Context, transferId string, reqEditors ...RequestEditorFn) (*ExecutePaymentTransferQuoteResponse, error)

	// ListPoliciesWithResponse request
	ListPoliciesWithResponse(ctx context.Context, params *ListPoliciesParams, reqEditors ...RequestEditorFn) (*ListPoliciesResponse, error)

	// CreatePolicyWithBodyWithResponse request with any body
	CreatePolicyWithBodyWithResponse(ctx context.Context, params *CreatePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePolicyResponse, error)

	CreatePolicyWithResponse(ctx context.Context, params *CreatePolicyParams, body CreatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePolicyResponse, error)

	// DeletePolicyWithResponse request
	DeletePolicyWithResponse(ctx context.Context, policyId string, params *DeletePolicyParams, reqEditors ...RequestEditorFn) (*DeletePolicyResponse, error)

	// GetPolicyByIdWithResponse request
	GetPolicyByIdWithResponse(ctx context.Context, policyId string, reqEditors ...RequestEditorFn) (*GetPolicyByIdResponse, error)

	// UpdatePolicyWithBodyWithResponse request with any body
	UpdatePolicyWithBodyWithResponse(ctx context.Context, policyId string, params *UpdatePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePolicyResponse, error)

	UpdatePolicyWithResponse(ctx context.Context, policyId string, params *UpdatePolicyParams, body UpdatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePolicyResponse, error)

	// ListSolanaAccountsWithResponse request
	ListSolanaAccountsWithResponse(ctx context.Context, params *ListSolanaAccountsParams, reqEditors ...RequestEditorFn) (*ListSolanaAccountsResponse, error)

	// CreateSolanaAccountWithBodyWithResponse request with any body
	CreateSolanaAccountWithBodyWithResponse(ctx context.Context, params *CreateSolanaAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSolanaAccountResponse, error)

	CreateSolanaAccountWithResponse(ctx context.Context, params *CreateSolanaAccountParams, body CreateSolanaAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSolanaAccountResponse, error)

	// GetSolanaAccountByNameWithResponse request
	GetSolanaAccountByNameWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetSolanaAccountByNameResponse, error)

	// ExportSolanaAccountByNameWithBodyWithResponse request with any body
	ExportSolanaAccountByNameWithBodyWithResponse(ctx context.Context, name string, params *ExportSolanaAccountByNameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExportSolanaAccountByNameResponse, error)

	ExportSolanaAccountByNameWithResponse(ctx context.Context, name string, params *ExportSolanaAccountByNameParams, body ExportSolanaAccountByNameJSONRequestBody, reqEditors ...RequestEditorFn) (*ExportSolanaAccountByNameResponse, error)

	// GetSolanaAccountWithResponse request
	GetSolanaAccountWithResponse(ctx context.Context, address string, reqEditors ...RequestEditorFn) (*GetSolanaAccountResponse, error)

	// UpdateSolanaAccountWithBodyWithResponse request with any body
	UpdateSolanaAccountWithBodyWithResponse(ctx context.Context, address string, params *UpdateSolanaAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSolanaAccountResponse, error)

	UpdateSolanaAccountWithResponse(ctx context.Context, address string, params *UpdateSolanaAccountParams, body UpdateSolanaAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSolanaAccountResponse, error)

	// ExportSolanaAccountWithBodyWithResponse request with any body
	ExportSolanaAccountWithBodyWithResponse(ctx context.Context, address string, params *ExportSolanaAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExportSolanaAccountResponse, error)

	ExportSolanaAccountWithResponse(ctx context.Context, address string, params *ExportSolanaAccountParams, body ExportSolanaAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*ExportSolanaAccountResponse, error)

	// SignSolanaMessageWithBodyWithResponse request with any body
	SignSolanaMessageWithBodyWithResponse(ctx context.Context, address string, params *SignSolanaMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SignSolanaMessageResponse, error)

	SignSolanaMessageWithResponse(ctx context.Context, address string, params *SignSolanaMessageParams, body SignSolanaMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*SignSolanaMessageResponse, error)

	// SignSolanaTransactionWithBodyWithResponse request with any body
	SignSolanaTransactionWithBodyWithResponse(ctx context.Context, address string, params *SignSolanaTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SignSolanaTransactionResponse, error)

	SignSolanaTransactionWithResponse(ctx context.Context, address string, params *SignSolanaTransactionParams, body SignSolanaTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*SignSolanaTransactionResponse, error)

	// RequestSolanaFaucetWithBodyWithResponse request with any body
	RequestSolanaFaucetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RequestSolanaFaucetResponse, error)

	RequestSolanaFaucetWithResponse(ctx context.Context, body RequestSolanaFaucetJSONRequestBody, reqEditors ...RequestEditorFn) (*RequestSolanaFaucetResponse, error)
}

type ListEvmAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Accounts The list of EVM accounts.
		Accounts []EvmAccount `json:"accounts"`

		// NextPageToken The token for the next page of items, if any.
		NextPageToken *string `json:"nextPageToken,omitempty"`
	}
	JSON500 *InternalServerError
	JSON502 *BadGatewayError
	JSON503 *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r ListEvmAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEvmAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateEvmAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *EvmAccount
	JSON400      *Error
	JSON401      *Error
	JSON402      *PaymentMethodRequiredError
	JSON409      *Error
	JSON422      *IdempotencyError
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r CreateEvmAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateEvmAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEvmAccountByNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EvmAccount
	JSON400      *Error
	JSON404      *Error
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r GetEvmAccountByNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEvmAccountByNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExportEvmAccountByNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// EncryptedPrivateKey The base64-encoded, encrypted private key of the EVM account which is a 32 byte raw private key. The private key is encrypted in transport using the exportEncryptionKey in the request.
		EncryptedPrivateKey string `json:"encryptedPrivateKey"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON402 *PaymentMethodRequiredError
	JSON404 *Error
	JSON422 *IdempotencyError
	JSON500 *InternalServerError
	JSON502 *BadGatewayError
	JSON503 *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r ExportEvmAccountByNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExportEvmAccountByNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ImportEvmAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *EvmAccount
	JSON400      *Error
	JSON401      *Error
	JSON402      *PaymentMethodRequiredError
	JSON409      *Error
	JSON422      *IdempotencyError
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r ImportEvmAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ImportEvmAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEvmAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EvmAccount
	JSON400      *Error
	JSON404      *Error
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r GetEvmAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEvmAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateEvmAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EvmAccount
	JSON400      *Error
	JSON404      *Error
	JSON409      *AlreadyExistsError
	JSON422      *IdempotencyError
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r UpdateEvmAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateEvmAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExportEvmAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// EncryptedPrivateKey The base64-encoded, encrypted private key of the EVM account which is a 32 byte raw private key. The private key is encrypted in transport using the exportEncryptionKey in the request.
		EncryptedPrivateKey string `json:"encryptedPrivateKey"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON402 *PaymentMethodRequiredError
	JSON404 *Error
	JSON422 *IdempotencyError
	JSON500 *InternalServerError
	JSON502 *BadGatewayError
	JSON503 *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r ExportEvmAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExportEvmAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendEvmTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// TransactionHash The hash of the transaction, as a 0x-prefixed hex string.
		TransactionHash string `json:"transactionHash"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON402 *PaymentMethodRequiredError
	JSON403 *Error
	JSON404 *Error
	JSON409 *AlreadyExistsError
	JSON422 *IdempotencyError
	JSON500 *InternalServerError
	JSON502 *BadGatewayError
	JSON503 *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r SendEvmTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendEvmTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SignEvmHashResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Signature The signature of the hash, as a 0x-prefixed hex string.
		Signature string `json:"signature"`
	}
	JSON400 *Error
	JSON402 *PaymentMethodRequiredError
	JSON404 *Error
	JSON409 *AlreadyExistsError
	JSON422 *IdempotencyError
	JSON500 *InternalServerError
	JSON502 *BadGatewayError
	JSON503 *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r SignEvmHashResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SignEvmHashResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SignEvmMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Signature The signature of the message, as a 0x-prefixed hex string.
		Signature string `json:"signature"`
	}
	JSON401 *Error
	JSON402 *PaymentMethodRequiredError
	JSON404 *Error
	JSON409 *AlreadyExistsError
	JSON422 *IdempotencyError
	JSON500 *InternalServerError
	JSON502 *BadGatewayError
	JSON503 *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r SignEvmMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SignEvmMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SignEvmTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// SignedTransaction The RLP-encoded signed transaction, as a 0x-prefixed hex string.
		SignedTransaction string `json:"signedTransaction"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON402 *PaymentMethodRequiredError
	JSON403 *Error
	JSON404 *Error
	JSON409 *AlreadyExistsError
	JSON422 *IdempotencyError
	JSON500 *InternalServerError
	JSON502 *BadGatewayError
	JSON503 *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r SignEvmTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SignEvmTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SignEvmTypedDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Signature The signature of the typed data, as a 0x-prefixed hex string.
		Signature string `json:"signature"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON402 *PaymentMethodRequiredError
	JSON404 *Error
	JSON422 *IdempotencyError
	JSON500 *InternalServerError
	JSON502 *BadGatewayError
	JSON503 *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r SignEvmTypedDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SignEvmTypedDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RequestEvmFaucetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// TransactionHash The hash of the transaction that requested the funds.
		// **Note:** In rare cases, when gas conditions are unusually high, the transaction may not confirm, and the system may issue a replacement transaction to complete the faucet request. In these rare cases, the `transactionHash` will be out of sync with the actual faucet transaction that was confirmed onchain.
		TransactionHash string `json:"transactionHash"`
	}
	JSON400 *Error
	JSON403 *Error
	JSON429 *Error
	JSON500 *InternalServerError
	JSON502 *BadGatewayError
	JSON503 *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r RequestEvmFaucetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RequestEvmFaucetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListEvmSmartAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Accounts The list of Smart Accounts.
		Accounts []EvmSmartAccount `json:"accounts"`

		// NextPageToken The token for the next page of items, if any.
		NextPageToken *string `json:"nextPageToken,omitempty"`
	}
	JSON400 *Error
	JSON500 *InternalServerError
	JSON502 *BadGatewayError
	JSON503 *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r ListEvmSmartAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEvmSmartAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateEvmSmartAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *EvmSmartAccount
	JSON400      *Error
	JSON402      *PaymentMethodRequiredError
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r CreateEvmSmartAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateEvmSmartAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEvmSmartAccountByNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EvmSmartAccount
	JSON400      *Error
	JSON404      *Error
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r GetEvmSmartAccountByNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEvmSmartAccountByNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEvmSmartAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EvmSmartAccount
	JSON400      *Error
	JSON404      *Error
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r GetEvmSmartAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEvmSmartAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PrepareUserOperationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *EvmUserOperation
	JSON400      *Error
	JSON404      *Error
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r PrepareUserOperationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PrepareUserOperationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserOperationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EvmUserOperation
	JSON400      *Error
	JSON404      *Error
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r GetUserOperationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserOperationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendUserOperationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EvmUserOperation
	JSON400      *Error
	JSON402      *PaymentMethodRequiredError
	JSON404      *Error
	JSON429      *Error
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r SendUserOperationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendUserOperationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateEvmSwapQuoteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CreateSwapQuoteResponseWrapper
	JSON400      *Error
	JSON403      *Error
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r CreateEvmSwapQuoteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateEvmSwapQuoteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEvmSwapPriceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetSwapPriceResponseWrapper
	JSON400      *Error
	JSON403      *Error
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r GetEvmSwapPriceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEvmSwapPriceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListEvmTokenBalancesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Balances The list of EVM token balances.
		Balances []TokenBalance `json:"balances"`

		// NextPageToken The token for the next page of items, if any.
		NextPageToken *string `json:"nextPageToken,omitempty"`
	}
	JSON400 *Error
	JSON404 *Error
	JSON500 *InternalServerError
	JSON502 *BadGatewayError
	JSON503 *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r ListEvmTokenBalancesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEvmTokenBalancesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCryptoRailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]CryptoRail
	JSON401      *Error
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r GetCryptoRailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCryptoRailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPaymentMethodsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PaymentMethod
	JSON401      *Error
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r GetPaymentMethodsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPaymentMethodsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePaymentTransferQuoteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Transfer The transfer object.
		Transfer Transfer `json:"transfer"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON429 *Error
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreatePaymentTransferQuoteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePaymentTransferQuoteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPaymentTransferResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Transfer
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r GetPaymentTransferResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPaymentTransferResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExecutePaymentTransferQuoteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Transfer
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSON429      *Error
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r ExecutePaymentTransferQuoteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExecutePaymentTransferQuoteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextPageToken The token for the next page of items, if any.
		NextPageToken *string `json:"nextPageToken,omitempty"`

		// Policies The list of policies.
		Policies []Policy `json:"policies"`
	}
	JSON500 *InternalServerError
	JSON502 *BadGatewayError
	JSON503 *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r ListPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Policy
	JSON400      *Error
	JSON409      *AlreadyExistsError
	JSON422      *IdempotencyError
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r CreatePolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON404      *Error
	JSON409      *AlreadyExistsError
	JSON422      *IdempotencyError
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r DeletePolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPolicyByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Policy
	JSON404      *Error
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r GetPolicyByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPolicyByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Policy
	JSON400      *Error
	JSON404      *Error
	JSON409      *AlreadyExistsError
	JSON422      *IdempotencyError
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r UpdatePolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSolanaAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Accounts The list of Solana accounts.
		Accounts []SolanaAccount `json:"accounts"`

		// NextPageToken The token for the next page of items, if any.
		NextPageToken *string `json:"nextPageToken,omitempty"`
	}
	JSON500 *InternalServerError
	JSON502 *BadGatewayError
	JSON503 *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r ListSolanaAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSolanaAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSolanaAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SolanaAccount
	JSON400      *Error
	JSON401      *Error
	JSON402      *PaymentMethodRequiredError
	JSON409      *Error
	JSON422      *IdempotencyError
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r CreateSolanaAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSolanaAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSolanaAccountByNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SolanaAccount
	JSON400      *Error
	JSON404      *Error
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r GetSolanaAccountByNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSolanaAccountByNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExportSolanaAccountByNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// EncryptedPrivateKey The base64-encoded, encrypted private key of the Solana account which is a 32 byte raw private key. The private key is encrypted in transport using the exportEncryptionKey in the request.
		EncryptedPrivateKey string `json:"encryptedPrivateKey"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON402 *PaymentMethodRequiredError
	JSON404 *Error
	JSON422 *IdempotencyError
	JSON500 *InternalServerError
	JSON502 *BadGatewayError
	JSON503 *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r ExportSolanaAccountByNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExportSolanaAccountByNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSolanaAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SolanaAccount
	JSON400      *Error
	JSON404      *Error
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r GetSolanaAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSolanaAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSolanaAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SolanaAccount
	JSON400      *Error
	JSON404      *Error
	JSON409      *AlreadyExistsError
	JSON422      *IdempotencyError
	JSON500      *InternalServerError
	JSON502      *BadGatewayError
	JSON503      *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r UpdateSolanaAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSolanaAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExportSolanaAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// EncryptedPrivateKey The base64-encoded, encrypted private key of the Solana account which is a 32 byte raw private key. The private key is encrypted in transport using the exportEncryptionKey in the request.
		EncryptedPrivateKey string `json:"encryptedPrivateKey"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON402 *PaymentMethodRequiredError
	JSON404 *Error
	JSON422 *IdempotencyError
	JSON500 *InternalServerError
	JSON502 *BadGatewayError
	JSON503 *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r ExportSolanaAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExportSolanaAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SignSolanaMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Signature The signature of the message, as a base58 encoded string.
		Signature string `json:"signature"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON402 *PaymentMethodRequiredError
	JSON404 *Error
	JSON409 *AlreadyExistsError
	JSON422 *IdempotencyError
	JSON500 *InternalServerError
	JSON502 *BadGatewayError
	JSON503 *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r SignSolanaMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SignSolanaMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SignSolanaTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// SignedTransaction The base64 encoded signed transaction.
		SignedTransaction string `json:"signedTransaction"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON402 *PaymentMethodRequiredError
	JSON403 *Error
	JSON404 *Error
	JSON409 *AlreadyExistsError
	JSON422 *IdempotencyError
	JSON500 *InternalServerError
	JSON502 *BadGatewayError
	JSON503 *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r SignSolanaTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SignSolanaTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RequestSolanaFaucetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// TransactionSignature The signature identifying the transaction that requested the funds.
		TransactionSignature string `json:"transactionSignature"`
	}
	JSON400 *Error
	JSON403 *Error
	JSON429 *Error
	JSON500 *InternalServerError
	JSON502 *BadGatewayError
	JSON503 *ServiceUnavailableError
}

// Status returns HTTPResponse.Status
func (r RequestSolanaFaucetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RequestSolanaFaucetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListEvmAccountsWithResponse request returning *ListEvmAccountsResponse
func (c *ClientWithResponses) ListEvmAccountsWithResponse(ctx context.Context, params *ListEvmAccountsParams, reqEditors ...RequestEditorFn) (*ListEvmAccountsResponse, error) {
	rsp, err := c.ListEvmAccounts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListEvmAccountsResponse(rsp)
}

// CreateEvmAccountWithBodyWithResponse request with arbitrary body returning *CreateEvmAccountResponse
func (c *ClientWithResponses) CreateEvmAccountWithBodyWithResponse(ctx context.Context, params *CreateEvmAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEvmAccountResponse, error) {
	rsp, err := c.CreateEvmAccountWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEvmAccountResponse(rsp)
}

func (c *ClientWithResponses) CreateEvmAccountWithResponse(ctx context.Context, params *CreateEvmAccountParams, body CreateEvmAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEvmAccountResponse, error) {
	rsp, err := c.CreateEvmAccount(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEvmAccountResponse(rsp)
}

// GetEvmAccountByNameWithResponse request returning *GetEvmAccountByNameResponse
func (c *ClientWithResponses) GetEvmAccountByNameWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetEvmAccountByNameResponse, error) {
	rsp, err := c.GetEvmAccountByName(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEvmAccountByNameResponse(rsp)
}

// ExportEvmAccountByNameWithBodyWithResponse request with arbitrary body returning *ExportEvmAccountByNameResponse
func (c *ClientWithResponses) ExportEvmAccountByNameWithBodyWithResponse(ctx context.Context, name string, params *ExportEvmAccountByNameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExportEvmAccountByNameResponse, error) {
	rsp, err := c.ExportEvmAccountByNameWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportEvmAccountByNameResponse(rsp)
}

func (c *ClientWithResponses) ExportEvmAccountByNameWithResponse(ctx context.Context, name string, params *ExportEvmAccountByNameParams, body ExportEvmAccountByNameJSONRequestBody, reqEditors ...RequestEditorFn) (*ExportEvmAccountByNameResponse, error) {
	rsp, err := c.ExportEvmAccountByName(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportEvmAccountByNameResponse(rsp)
}

// ImportEvmAccountWithBodyWithResponse request with arbitrary body returning *ImportEvmAccountResponse
func (c *ClientWithResponses) ImportEvmAccountWithBodyWithResponse(ctx context.Context, params *ImportEvmAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ImportEvmAccountResponse, error) {
	rsp, err := c.ImportEvmAccountWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImportEvmAccountResponse(rsp)
}

func (c *ClientWithResponses) ImportEvmAccountWithResponse(ctx context.Context, params *ImportEvmAccountParams, body ImportEvmAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*ImportEvmAccountResponse, error) {
	rsp, err := c.ImportEvmAccount(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImportEvmAccountResponse(rsp)
}

// GetEvmAccountWithResponse request returning *GetEvmAccountResponse
func (c *ClientWithResponses) GetEvmAccountWithResponse(ctx context.Context, address string, reqEditors ...RequestEditorFn) (*GetEvmAccountResponse, error) {
	rsp, err := c.GetEvmAccount(ctx, address, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEvmAccountResponse(rsp)
}

// UpdateEvmAccountWithBodyWithResponse request with arbitrary body returning *UpdateEvmAccountResponse
func (c *ClientWithResponses) UpdateEvmAccountWithBodyWithResponse(ctx context.Context, address string, params *UpdateEvmAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEvmAccountResponse, error) {
	rsp, err := c.UpdateEvmAccountWithBody(ctx, address, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEvmAccountResponse(rsp)
}

func (c *ClientWithResponses) UpdateEvmAccountWithResponse(ctx context.Context, address string, params *UpdateEvmAccountParams, body UpdateEvmAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEvmAccountResponse, error) {
	rsp, err := c.UpdateEvmAccount(ctx, address, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEvmAccountResponse(rsp)
}

// ExportEvmAccountWithBodyWithResponse request with arbitrary body returning *ExportEvmAccountResponse
func (c *ClientWithResponses) ExportEvmAccountWithBodyWithResponse(ctx context.Context, address string, params *ExportEvmAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExportEvmAccountResponse, error) {
	rsp, err := c.ExportEvmAccountWithBody(ctx, address, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportEvmAccountResponse(rsp)
}

func (c *ClientWithResponses) ExportEvmAccountWithResponse(ctx context.Context, address string, params *ExportEvmAccountParams, body ExportEvmAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*ExportEvmAccountResponse, error) {
	rsp, err := c.ExportEvmAccount(ctx, address, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportEvmAccountResponse(rsp)
}

// SendEvmTransactionWithBodyWithResponse request with arbitrary body returning *SendEvmTransactionResponse
func (c *ClientWithResponses) SendEvmTransactionWithBodyWithResponse(ctx context.Context, address string, params *SendEvmTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendEvmTransactionResponse, error) {
	rsp, err := c.SendEvmTransactionWithBody(ctx, address, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendEvmTransactionResponse(rsp)
}

func (c *ClientWithResponses) SendEvmTransactionWithResponse(ctx context.Context, address string, params *SendEvmTransactionParams, body SendEvmTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*SendEvmTransactionResponse, error) {
	rsp, err := c.SendEvmTransaction(ctx, address, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendEvmTransactionResponse(rsp)
}

// SignEvmHashWithBodyWithResponse request with arbitrary body returning *SignEvmHashResponse
func (c *ClientWithResponses) SignEvmHashWithBodyWithResponse(ctx context.Context, address string, params *SignEvmHashParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SignEvmHashResponse, error) {
	rsp, err := c.SignEvmHashWithBody(ctx, address, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSignEvmHashResponse(rsp)
}

func (c *ClientWithResponses) SignEvmHashWithResponse(ctx context.Context, address string, params *SignEvmHashParams, body SignEvmHashJSONRequestBody, reqEditors ...RequestEditorFn) (*SignEvmHashResponse, error) {
	rsp, err := c.SignEvmHash(ctx, address, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSignEvmHashResponse(rsp)
}

// SignEvmMessageWithBodyWithResponse request with arbitrary body returning *SignEvmMessageResponse
func (c *ClientWithResponses) SignEvmMessageWithBodyWithResponse(ctx context.Context, address string, params *SignEvmMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SignEvmMessageResponse, error) {
	rsp, err := c.SignEvmMessageWithBody(ctx, address, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSignEvmMessageResponse(rsp)
}

func (c *ClientWithResponses) SignEvmMessageWithResponse(ctx context.Context, address string, params *SignEvmMessageParams, body SignEvmMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*SignEvmMessageResponse, error) {
	rsp, err := c.SignEvmMessage(ctx, address, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSignEvmMessageResponse(rsp)
}

// SignEvmTransactionWithBodyWithResponse request with arbitrary body returning *SignEvmTransactionResponse
func (c *ClientWithResponses) SignEvmTransactionWithBodyWithResponse(ctx context.Context, address string, params *SignEvmTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SignEvmTransactionResponse, error) {
	rsp, err := c.SignEvmTransactionWithBody(ctx, address, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSignEvmTransactionResponse(rsp)
}

func (c *ClientWithResponses) SignEvmTransactionWithResponse(ctx context.Context, address string, params *SignEvmTransactionParams, body SignEvmTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*SignEvmTransactionResponse, error) {
	rsp, err := c.SignEvmTransaction(ctx, address, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSignEvmTransactionResponse(rsp)
}

// SignEvmTypedDataWithBodyWithResponse request with arbitrary body returning *SignEvmTypedDataResponse
func (c *ClientWithResponses) SignEvmTypedDataWithBodyWithResponse(ctx context.Context, address string, params *SignEvmTypedDataParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SignEvmTypedDataResponse, error) {
	rsp, err := c.SignEvmTypedDataWithBody(ctx, address, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSignEvmTypedDataResponse(rsp)
}

func (c *ClientWithResponses) SignEvmTypedDataWithResponse(ctx context.Context, address string, params *SignEvmTypedDataParams, body SignEvmTypedDataJSONRequestBody, reqEditors ...RequestEditorFn) (*SignEvmTypedDataResponse, error) {
	rsp, err := c.SignEvmTypedData(ctx, address, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSignEvmTypedDataResponse(rsp)
}

// RequestEvmFaucetWithBodyWithResponse request with arbitrary body returning *RequestEvmFaucetResponse
func (c *ClientWithResponses) RequestEvmFaucetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RequestEvmFaucetResponse, error) {
	rsp, err := c.RequestEvmFaucetWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRequestEvmFaucetResponse(rsp)
}

func (c *ClientWithResponses) RequestEvmFaucetWithResponse(ctx context.Context, body RequestEvmFaucetJSONRequestBody, reqEditors ...RequestEditorFn) (*RequestEvmFaucetResponse, error) {
	rsp, err := c.RequestEvmFaucet(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRequestEvmFaucetResponse(rsp)
}

// ListEvmSmartAccountsWithResponse request returning *ListEvmSmartAccountsResponse
func (c *ClientWithResponses) ListEvmSmartAccountsWithResponse(ctx context.Context, params *ListEvmSmartAccountsParams, reqEditors ...RequestEditorFn) (*ListEvmSmartAccountsResponse, error) {
	rsp, err := c.ListEvmSmartAccounts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListEvmSmartAccountsResponse(rsp)
}

// CreateEvmSmartAccountWithBodyWithResponse request with arbitrary body returning *CreateEvmSmartAccountResponse
func (c *ClientWithResponses) CreateEvmSmartAccountWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEvmSmartAccountResponse, error) {
	rsp, err := c.CreateEvmSmartAccountWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEvmSmartAccountResponse(rsp)
}

func (c *ClientWithResponses) CreateEvmSmartAccountWithResponse(ctx context.Context, body CreateEvmSmartAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEvmSmartAccountResponse, error) {
	rsp, err := c.CreateEvmSmartAccount(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEvmSmartAccountResponse(rsp)
}

// GetEvmSmartAccountByNameWithResponse request returning *GetEvmSmartAccountByNameResponse
func (c *ClientWithResponses) GetEvmSmartAccountByNameWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetEvmSmartAccountByNameResponse, error) {
	rsp, err := c.GetEvmSmartAccountByName(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEvmSmartAccountByNameResponse(rsp)
}

// GetEvmSmartAccountWithResponse request returning *GetEvmSmartAccountResponse
func (c *ClientWithResponses) GetEvmSmartAccountWithResponse(ctx context.Context, address string, reqEditors ...RequestEditorFn) (*GetEvmSmartAccountResponse, error) {
	rsp, err := c.GetEvmSmartAccount(ctx, address, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEvmSmartAccountResponse(rsp)
}

// PrepareUserOperationWithBodyWithResponse request with arbitrary body returning *PrepareUserOperationResponse
func (c *ClientWithResponses) PrepareUserOperationWithBodyWithResponse(ctx context.Context, address string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PrepareUserOperationResponse, error) {
	rsp, err := c.PrepareUserOperationWithBody(ctx, address, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePrepareUserOperationResponse(rsp)
}

func (c *ClientWithResponses) PrepareUserOperationWithResponse(ctx context.Context, address string, body PrepareUserOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*PrepareUserOperationResponse, error) {
	rsp, err := c.PrepareUserOperation(ctx, address, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePrepareUserOperationResponse(rsp)
}

// GetUserOperationWithResponse request returning *GetUserOperationResponse
func (c *ClientWithResponses) GetUserOperationWithResponse(ctx context.Context, address string, userOpHash string, reqEditors ...RequestEditorFn) (*GetUserOperationResponse, error) {
	rsp, err := c.GetUserOperation(ctx, address, userOpHash, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserOperationResponse(rsp)
}

// SendUserOperationWithBodyWithResponse request with arbitrary body returning *SendUserOperationResponse
func (c *ClientWithResponses) SendUserOperationWithBodyWithResponse(ctx context.Context, address string, userOpHash string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendUserOperationResponse, error) {
	rsp, err := c.SendUserOperationWithBody(ctx, address, userOpHash, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendUserOperationResponse(rsp)
}

func (c *ClientWithResponses) SendUserOperationWithResponse(ctx context.Context, address string, userOpHash string, body SendUserOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*SendUserOperationResponse, error) {
	rsp, err := c.SendUserOperation(ctx, address, userOpHash, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendUserOperationResponse(rsp)
}

// CreateEvmSwapQuoteWithBodyWithResponse request with arbitrary body returning *CreateEvmSwapQuoteResponse
func (c *ClientWithResponses) CreateEvmSwapQuoteWithBodyWithResponse(ctx context.Context, params *CreateEvmSwapQuoteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEvmSwapQuoteResponse, error) {
	rsp, err := c.CreateEvmSwapQuoteWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEvmSwapQuoteResponse(rsp)
}

func (c *ClientWithResponses) CreateEvmSwapQuoteWithResponse(ctx context.Context, params *CreateEvmSwapQuoteParams, body CreateEvmSwapQuoteJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEvmSwapQuoteResponse, error) {
	rsp, err := c.CreateEvmSwapQuote(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEvmSwapQuoteResponse(rsp)
}

// GetEvmSwapPriceWithResponse request returning *GetEvmSwapPriceResponse
func (c *ClientWithResponses) GetEvmSwapPriceWithResponse(ctx context.Context, params *GetEvmSwapPriceParams, reqEditors ...RequestEditorFn) (*GetEvmSwapPriceResponse, error) {
	rsp, err := c.GetEvmSwapPrice(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEvmSwapPriceResponse(rsp)
}

// ListEvmTokenBalancesWithResponse request returning *ListEvmTokenBalancesResponse
func (c *ClientWithResponses) ListEvmTokenBalancesWithResponse(ctx context.Context, network ListEvmTokenBalancesNetwork, address string, params *ListEvmTokenBalancesParams, reqEditors ...RequestEditorFn) (*ListEvmTokenBalancesResponse, error) {
	rsp, err := c.ListEvmTokenBalances(ctx, network, address, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListEvmTokenBalancesResponse(rsp)
}

// GetCryptoRailsWithResponse request returning *GetCryptoRailsResponse
func (c *ClientWithResponses) GetCryptoRailsWithResponse(ctx context.Context, params *GetCryptoRailsParams, reqEditors ...RequestEditorFn) (*GetCryptoRailsResponse, error) {
	rsp, err := c.GetCryptoRails(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCryptoRailsResponse(rsp)
}

// GetPaymentMethodsWithResponse request returning *GetPaymentMethodsResponse
func (c *ClientWithResponses) GetPaymentMethodsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPaymentMethodsResponse, error) {
	rsp, err := c.GetPaymentMethods(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPaymentMethodsResponse(rsp)
}

// CreatePaymentTransferQuoteWithBodyWithResponse request with arbitrary body returning *CreatePaymentTransferQuoteResponse
func (c *ClientWithResponses) CreatePaymentTransferQuoteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePaymentTransferQuoteResponse, error) {
	rsp, err := c.CreatePaymentTransferQuoteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePaymentTransferQuoteResponse(rsp)
}

func (c *ClientWithResponses) CreatePaymentTransferQuoteWithResponse(ctx context.Context, body CreatePaymentTransferQuoteJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePaymentTransferQuoteResponse, error) {
	rsp, err := c.CreatePaymentTransferQuote(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePaymentTransferQuoteResponse(rsp)
}

// GetPaymentTransferWithResponse request returning *GetPaymentTransferResponse
func (c *ClientWithResponses) GetPaymentTransferWithResponse(ctx context.Context, transferId string, reqEditors ...RequestEditorFn) (*GetPaymentTransferResponse, error) {
	rsp, err := c.GetPaymentTransfer(ctx, transferId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPaymentTransferResponse(rsp)
}

// ExecutePaymentTransferQuoteWithResponse request returning *ExecutePaymentTransferQuoteResponse
func (c *ClientWithResponses) ExecutePaymentTransferQuoteWithResponse(ctx context.Context, transferId string, reqEditors ...RequestEditorFn) (*ExecutePaymentTransferQuoteResponse, error) {
	rsp, err := c.ExecutePaymentTransferQuote(ctx, transferId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExecutePaymentTransferQuoteResponse(rsp)
}

// ListPoliciesWithResponse request returning *ListPoliciesResponse
func (c *ClientWithResponses) ListPoliciesWithResponse(ctx context.Context, params *ListPoliciesParams, reqEditors ...RequestEditorFn) (*ListPoliciesResponse, error) {
	rsp, err := c.ListPolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPoliciesResponse(rsp)
}

// CreatePolicyWithBodyWithResponse request with arbitrary body returning *CreatePolicyResponse
func (c *ClientWithResponses) CreatePolicyWithBodyWithResponse(ctx context.Context, params *CreatePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePolicyResponse, error) {
	rsp, err := c.CreatePolicyWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePolicyResponse(rsp)
}

func (c *ClientWithResponses) CreatePolicyWithResponse(ctx context.Context, params *CreatePolicyParams, body CreatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePolicyResponse, error) {
	rsp, err := c.CreatePolicy(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePolicyResponse(rsp)
}

// DeletePolicyWithResponse request returning *DeletePolicyResponse
func (c *ClientWithResponses) DeletePolicyWithResponse(ctx context.Context, policyId string, params *DeletePolicyParams, reqEditors ...RequestEditorFn) (*DeletePolicyResponse, error) {
	rsp, err := c.DeletePolicy(ctx, policyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePolicyResponse(rsp)
}

// GetPolicyByIdWithResponse request returning *GetPolicyByIdResponse
func (c *ClientWithResponses) GetPolicyByIdWithResponse(ctx context.Context, policyId string, reqEditors ...RequestEditorFn) (*GetPolicyByIdResponse, error) {
	rsp, err := c.GetPolicyById(ctx, policyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPolicyByIdResponse(rsp)
}

// UpdatePolicyWithBodyWithResponse request with arbitrary body returning *UpdatePolicyResponse
func (c *ClientWithResponses) UpdatePolicyWithBodyWithResponse(ctx context.Context, policyId string, params *UpdatePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePolicyResponse, error) {
	rsp, err := c.UpdatePolicyWithBody(ctx, policyId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePolicyResponse(rsp)
}

func (c *ClientWithResponses) UpdatePolicyWithResponse(ctx context.Context, policyId string, params *UpdatePolicyParams, body UpdatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePolicyResponse, error) {
	rsp, err := c.UpdatePolicy(ctx, policyId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePolicyResponse(rsp)
}

// ListSolanaAccountsWithResponse request returning *ListSolanaAccountsResponse
func (c *ClientWithResponses) ListSolanaAccountsWithResponse(ctx context.Context, params *ListSolanaAccountsParams, reqEditors ...RequestEditorFn) (*ListSolanaAccountsResponse, error) {
	rsp, err := c.ListSolanaAccounts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSolanaAccountsResponse(rsp)
}

// CreateSolanaAccountWithBodyWithResponse request with arbitrary body returning *CreateSolanaAccountResponse
func (c *ClientWithResponses) CreateSolanaAccountWithBodyWithResponse(ctx context.Context, params *CreateSolanaAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSolanaAccountResponse, error) {
	rsp, err := c.CreateSolanaAccountWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSolanaAccountResponse(rsp)
}

func (c *ClientWithResponses) CreateSolanaAccountWithResponse(ctx context.Context, params *CreateSolanaAccountParams, body CreateSolanaAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSolanaAccountResponse, error) {
	rsp, err := c.CreateSolanaAccount(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSolanaAccountResponse(rsp)
}

// GetSolanaAccountByNameWithResponse request returning *GetSolanaAccountByNameResponse
func (c *ClientWithResponses) GetSolanaAccountByNameWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetSolanaAccountByNameResponse, error) {
	rsp, err := c.GetSolanaAccountByName(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSolanaAccountByNameResponse(rsp)
}

// ExportSolanaAccountByNameWithBodyWithResponse request with arbitrary body returning *ExportSolanaAccountByNameResponse
func (c *ClientWithResponses) ExportSolanaAccountByNameWithBodyWithResponse(ctx context.Context, name string, params *ExportSolanaAccountByNameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExportSolanaAccountByNameResponse, error) {
	rsp, err := c.ExportSolanaAccountByNameWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportSolanaAccountByNameResponse(rsp)
}

func (c *ClientWithResponses) ExportSolanaAccountByNameWithResponse(ctx context.Context, name string, params *ExportSolanaAccountByNameParams, body ExportSolanaAccountByNameJSONRequestBody, reqEditors ...RequestEditorFn) (*ExportSolanaAccountByNameResponse, error) {
	rsp, err := c.ExportSolanaAccountByName(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportSolanaAccountByNameResponse(rsp)
}

// GetSolanaAccountWithResponse request returning *GetSolanaAccountResponse
func (c *ClientWithResponses) GetSolanaAccountWithResponse(ctx context.Context, address string, reqEditors ...RequestEditorFn) (*GetSolanaAccountResponse, error) {
	rsp, err := c.GetSolanaAccount(ctx, address, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSolanaAccountResponse(rsp)
}

// UpdateSolanaAccountWithBodyWithResponse request with arbitrary body returning *UpdateSolanaAccountResponse
func (c *ClientWithResponses) UpdateSolanaAccountWithBodyWithResponse(ctx context.Context, address string, params *UpdateSolanaAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSolanaAccountResponse, error) {
	rsp, err := c.UpdateSolanaAccountWithBody(ctx, address, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSolanaAccountResponse(rsp)
}

func (c *ClientWithResponses) UpdateSolanaAccountWithResponse(ctx context.Context, address string, params *UpdateSolanaAccountParams, body UpdateSolanaAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSolanaAccountResponse, error) {
	rsp, err := c.UpdateSolanaAccount(ctx, address, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSolanaAccountResponse(rsp)
}

// ExportSolanaAccountWithBodyWithResponse request with arbitrary body returning *ExportSolanaAccountResponse
func (c *ClientWithResponses) ExportSolanaAccountWithBodyWithResponse(ctx context.Context, address string, params *ExportSolanaAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExportSolanaAccountResponse, error) {
	rsp, err := c.ExportSolanaAccountWithBody(ctx, address, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportSolanaAccountResponse(rsp)
}

func (c *ClientWithResponses) ExportSolanaAccountWithResponse(ctx context.Context, address string, params *ExportSolanaAccountParams, body ExportSolanaAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*ExportSolanaAccountResponse, error) {
	rsp, err := c.ExportSolanaAccount(ctx, address, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportSolanaAccountResponse(rsp)
}

// SignSolanaMessageWithBodyWithResponse request with arbitrary body returning *SignSolanaMessageResponse
func (c *ClientWithResponses) SignSolanaMessageWithBodyWithResponse(ctx context.Context, address string, params *SignSolanaMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SignSolanaMessageResponse, error) {
	rsp, err := c.SignSolanaMessageWithBody(ctx, address, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSignSolanaMessageResponse(rsp)
}

func (c *ClientWithResponses) SignSolanaMessageWithResponse(ctx context.Context, address string, params *SignSolanaMessageParams, body SignSolanaMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*SignSolanaMessageResponse, error) {
	rsp, err := c.SignSolanaMessage(ctx, address, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSignSolanaMessageResponse(rsp)
}

// SignSolanaTransactionWithBodyWithResponse request with arbitrary body returning *SignSolanaTransactionResponse
func (c *ClientWithResponses) SignSolanaTransactionWithBodyWithResponse(ctx context.Context, address string, params *SignSolanaTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SignSolanaTransactionResponse, error) {
	rsp, err := c.SignSolanaTransactionWithBody(ctx, address, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSignSolanaTransactionResponse(rsp)
}

func (c *ClientWithResponses) SignSolanaTransactionWithResponse(ctx context.Context, address string, params *SignSolanaTransactionParams, body SignSolanaTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*SignSolanaTransactionResponse, error) {
	rsp, err := c.SignSolanaTransaction(ctx, address, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSignSolanaTransactionResponse(rsp)
}

// RequestSolanaFaucetWithBodyWithResponse request with arbitrary body returning *RequestSolanaFaucetResponse
func (c *ClientWithResponses) RequestSolanaFaucetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RequestSolanaFaucetResponse, error) {
	rsp, err := c.RequestSolanaFaucetWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRequestSolanaFaucetResponse(rsp)
}

func (c *ClientWithResponses) RequestSolanaFaucetWithResponse(ctx context.Context, body RequestSolanaFaucetJSONRequestBody, reqEditors ...RequestEditorFn) (*RequestSolanaFaucetResponse, error) {
	rsp, err := c.RequestSolanaFaucet(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRequestSolanaFaucetResponse(rsp)
}

// ParseListEvmAccountsResponse parses an HTTP response from a ListEvmAccountsWithResponse call
func ParseListEvmAccountsResponse(rsp *http.Response) (*ListEvmAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListEvmAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Accounts The list of EVM accounts.
			Accounts []EvmAccount `json:"accounts"`

			// NextPageToken The token for the next page of items, if any.
			NextPageToken *string `json:"nextPageToken,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCreateEvmAccountResponse parses an HTTP response from a CreateEvmAccountWithResponse call
func ParseCreateEvmAccountResponse(rsp *http.Response) (*CreateEvmAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateEvmAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest EvmAccount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest PaymentMethodRequiredError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetEvmAccountByNameResponse parses an HTTP response from a GetEvmAccountByNameWithResponse call
func ParseGetEvmAccountByNameResponse(rsp *http.Response) (*GetEvmAccountByNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEvmAccountByNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EvmAccount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseExportEvmAccountByNameResponse parses an HTTP response from a ExportEvmAccountByNameWithResponse call
func ParseExportEvmAccountByNameResponse(rsp *http.Response) (*ExportEvmAccountByNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExportEvmAccountByNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// EncryptedPrivateKey The base64-encoded, encrypted private key of the EVM account which is a 32 byte raw private key. The private key is encrypted in transport using the exportEncryptionKey in the request.
			EncryptedPrivateKey string `json:"encryptedPrivateKey"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest PaymentMethodRequiredError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseImportEvmAccountResponse parses an HTTP response from a ImportEvmAccountWithResponse call
func ParseImportEvmAccountResponse(rsp *http.Response) (*ImportEvmAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ImportEvmAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest EvmAccount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest PaymentMethodRequiredError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetEvmAccountResponse parses an HTTP response from a GetEvmAccountWithResponse call
func ParseGetEvmAccountResponse(rsp *http.Response) (*GetEvmAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEvmAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EvmAccount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseUpdateEvmAccountResponse parses an HTTP response from a UpdateEvmAccountWithResponse call
func ParseUpdateEvmAccountResponse(rsp *http.Response) (*UpdateEvmAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateEvmAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EvmAccount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExistsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseExportEvmAccountResponse parses an HTTP response from a ExportEvmAccountWithResponse call
func ParseExportEvmAccountResponse(rsp *http.Response) (*ExportEvmAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExportEvmAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// EncryptedPrivateKey The base64-encoded, encrypted private key of the EVM account which is a 32 byte raw private key. The private key is encrypted in transport using the exportEncryptionKey in the request.
			EncryptedPrivateKey string `json:"encryptedPrivateKey"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest PaymentMethodRequiredError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSendEvmTransactionResponse parses an HTTP response from a SendEvmTransactionWithResponse call
func ParseSendEvmTransactionResponse(rsp *http.Response) (*SendEvmTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SendEvmTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// TransactionHash The hash of the transaction, as a 0x-prefixed hex string.
			TransactionHash string `json:"transactionHash"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest PaymentMethodRequiredError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExistsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSignEvmHashResponse parses an HTTP response from a SignEvmHashWithResponse call
func ParseSignEvmHashResponse(rsp *http.Response) (*SignEvmHashResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SignEvmHashResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Signature The signature of the hash, as a 0x-prefixed hex string.
			Signature string `json:"signature"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest PaymentMethodRequiredError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExistsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSignEvmMessageResponse parses an HTTP response from a SignEvmMessageWithResponse call
func ParseSignEvmMessageResponse(rsp *http.Response) (*SignEvmMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SignEvmMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Signature The signature of the message, as a 0x-prefixed hex string.
			Signature string `json:"signature"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest PaymentMethodRequiredError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExistsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSignEvmTransactionResponse parses an HTTP response from a SignEvmTransactionWithResponse call
func ParseSignEvmTransactionResponse(rsp *http.Response) (*SignEvmTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SignEvmTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// SignedTransaction The RLP-encoded signed transaction, as a 0x-prefixed hex string.
			SignedTransaction string `json:"signedTransaction"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest PaymentMethodRequiredError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExistsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSignEvmTypedDataResponse parses an HTTP response from a SignEvmTypedDataWithResponse call
func ParseSignEvmTypedDataResponse(rsp *http.Response) (*SignEvmTypedDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SignEvmTypedDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Signature The signature of the typed data, as a 0x-prefixed hex string.
			Signature string `json:"signature"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest PaymentMethodRequiredError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseRequestEvmFaucetResponse parses an HTTP response from a RequestEvmFaucetWithResponse call
func ParseRequestEvmFaucetResponse(rsp *http.Response) (*RequestEvmFaucetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RequestEvmFaucetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// TransactionHash The hash of the transaction that requested the funds.
			// **Note:** In rare cases, when gas conditions are unusually high, the transaction may not confirm, and the system may issue a replacement transaction to complete the faucet request. In these rare cases, the `transactionHash` will be out of sync with the actual faucet transaction that was confirmed onchain.
			TransactionHash string `json:"transactionHash"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseListEvmSmartAccountsResponse parses an HTTP response from a ListEvmSmartAccountsWithResponse call
func ParseListEvmSmartAccountsResponse(rsp *http.Response) (*ListEvmSmartAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListEvmSmartAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Accounts The list of Smart Accounts.
			Accounts []EvmSmartAccount `json:"accounts"`

			// NextPageToken The token for the next page of items, if any.
			NextPageToken *string `json:"nextPageToken,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCreateEvmSmartAccountResponse parses an HTTP response from a CreateEvmSmartAccountWithResponse call
func ParseCreateEvmSmartAccountResponse(rsp *http.Response) (*CreateEvmSmartAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateEvmSmartAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest EvmSmartAccount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest PaymentMethodRequiredError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetEvmSmartAccountByNameResponse parses an HTTP response from a GetEvmSmartAccountByNameWithResponse call
func ParseGetEvmSmartAccountByNameResponse(rsp *http.Response) (*GetEvmSmartAccountByNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEvmSmartAccountByNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EvmSmartAccount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetEvmSmartAccountResponse parses an HTTP response from a GetEvmSmartAccountWithResponse call
func ParseGetEvmSmartAccountResponse(rsp *http.Response) (*GetEvmSmartAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEvmSmartAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EvmSmartAccount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParsePrepareUserOperationResponse parses an HTTP response from a PrepareUserOperationWithResponse call
func ParsePrepareUserOperationResponse(rsp *http.Response) (*PrepareUserOperationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PrepareUserOperationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest EvmUserOperation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetUserOperationResponse parses an HTTP response from a GetUserOperationWithResponse call
func ParseGetUserOperationResponse(rsp *http.Response) (*GetUserOperationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserOperationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EvmUserOperation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSendUserOperationResponse parses an HTTP response from a SendUserOperationWithResponse call
func ParseSendUserOperationResponse(rsp *http.Response) (*SendUserOperationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SendUserOperationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EvmUserOperation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest PaymentMethodRequiredError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCreateEvmSwapQuoteResponse parses an HTTP response from a CreateEvmSwapQuoteWithResponse call
func ParseCreateEvmSwapQuoteResponse(rsp *http.Response) (*CreateEvmSwapQuoteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateEvmSwapQuoteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateSwapQuoteResponseWrapper
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetEvmSwapPriceResponse parses an HTTP response from a GetEvmSwapPriceWithResponse call
func ParseGetEvmSwapPriceResponse(rsp *http.Response) (*GetEvmSwapPriceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEvmSwapPriceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetSwapPriceResponseWrapper
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseListEvmTokenBalancesResponse parses an HTTP response from a ListEvmTokenBalancesWithResponse call
func ParseListEvmTokenBalancesResponse(rsp *http.Response) (*ListEvmTokenBalancesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListEvmTokenBalancesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Balances The list of EVM token balances.
			Balances []TokenBalance `json:"balances"`

			// NextPageToken The token for the next page of items, if any.
			NextPageToken *string `json:"nextPageToken,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetCryptoRailsResponse parses an HTTP response from a GetCryptoRailsWithResponse call
func ParseGetCryptoRailsResponse(rsp *http.Response) (*GetCryptoRailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCryptoRailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []CryptoRail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetPaymentMethodsResponse parses an HTTP response from a GetPaymentMethodsWithResponse call
func ParseGetPaymentMethodsResponse(rsp *http.Response) (*GetPaymentMethodsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPaymentMethodsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PaymentMethod
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCreatePaymentTransferQuoteResponse parses an HTTP response from a CreatePaymentTransferQuoteWithResponse call
func ParseCreatePaymentTransferQuoteResponse(rsp *http.Response) (*CreatePaymentTransferQuoteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePaymentTransferQuoteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Transfer The transfer object.
			Transfer Transfer `json:"transfer"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPaymentTransferResponse parses an HTTP response from a GetPaymentTransferWithResponse call
func ParseGetPaymentTransferResponse(rsp *http.Response) (*GetPaymentTransferResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPaymentTransferResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Transfer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseExecutePaymentTransferQuoteResponse parses an HTTP response from a ExecutePaymentTransferQuoteWithResponse call
func ParseExecutePaymentTransferQuoteResponse(rsp *http.Response) (*ExecutePaymentTransferQuoteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExecutePaymentTransferQuoteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Transfer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseListPoliciesResponse parses an HTTP response from a ListPoliciesWithResponse call
func ParseListPoliciesResponse(rsp *http.Response) (*ListPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextPageToken The token for the next page of items, if any.
			NextPageToken *string `json:"nextPageToken,omitempty"`

			// Policies The list of policies.
			Policies []Policy `json:"policies"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCreatePolicyResponse parses an HTTP response from a CreatePolicyWithResponse call
func ParseCreatePolicyResponse(rsp *http.Response) (*CreatePolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Policy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExistsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDeletePolicyResponse parses an HTTP response from a DeletePolicyWithResponse call
func ParseDeletePolicyResponse(rsp *http.Response) (*DeletePolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExistsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetPolicyByIdResponse parses an HTTP response from a GetPolicyByIdWithResponse call
func ParseGetPolicyByIdResponse(rsp *http.Response) (*GetPolicyByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPolicyByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Policy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseUpdatePolicyResponse parses an HTTP response from a UpdatePolicyWithResponse call
func ParseUpdatePolicyResponse(rsp *http.Response) (*UpdatePolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Policy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExistsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseListSolanaAccountsResponse parses an HTTP response from a ListSolanaAccountsWithResponse call
func ParseListSolanaAccountsResponse(rsp *http.Response) (*ListSolanaAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSolanaAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Accounts The list of Solana accounts.
			Accounts []SolanaAccount `json:"accounts"`

			// NextPageToken The token for the next page of items, if any.
			NextPageToken *string `json:"nextPageToken,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCreateSolanaAccountResponse parses an HTTP response from a CreateSolanaAccountWithResponse call
func ParseCreateSolanaAccountResponse(rsp *http.Response) (*CreateSolanaAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSolanaAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SolanaAccount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest PaymentMethodRequiredError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetSolanaAccountByNameResponse parses an HTTP response from a GetSolanaAccountByNameWithResponse call
func ParseGetSolanaAccountByNameResponse(rsp *http.Response) (*GetSolanaAccountByNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSolanaAccountByNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SolanaAccount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseExportSolanaAccountByNameResponse parses an HTTP response from a ExportSolanaAccountByNameWithResponse call
func ParseExportSolanaAccountByNameResponse(rsp *http.Response) (*ExportSolanaAccountByNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExportSolanaAccountByNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// EncryptedPrivateKey The base64-encoded, encrypted private key of the Solana account which is a 32 byte raw private key. The private key is encrypted in transport using the exportEncryptionKey in the request.
			EncryptedPrivateKey string `json:"encryptedPrivateKey"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest PaymentMethodRequiredError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetSolanaAccountResponse parses an HTTP response from a GetSolanaAccountWithResponse call
func ParseGetSolanaAccountResponse(rsp *http.Response) (*GetSolanaAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSolanaAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SolanaAccount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseUpdateSolanaAccountResponse parses an HTTP response from a UpdateSolanaAccountWithResponse call
func ParseUpdateSolanaAccountResponse(rsp *http.Response) (*UpdateSolanaAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSolanaAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SolanaAccount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExistsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseExportSolanaAccountResponse parses an HTTP response from a ExportSolanaAccountWithResponse call
func ParseExportSolanaAccountResponse(rsp *http.Response) (*ExportSolanaAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExportSolanaAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// EncryptedPrivateKey The base64-encoded, encrypted private key of the Solana account which is a 32 byte raw private key. The private key is encrypted in transport using the exportEncryptionKey in the request.
			EncryptedPrivateKey string `json:"encryptedPrivateKey"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest PaymentMethodRequiredError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSignSolanaMessageResponse parses an HTTP response from a SignSolanaMessageWithResponse call
func ParseSignSolanaMessageResponse(rsp *http.Response) (*SignSolanaMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SignSolanaMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Signature The signature of the message, as a base58 encoded string.
			Signature string `json:"signature"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest PaymentMethodRequiredError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExistsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSignSolanaTransactionResponse parses an HTTP response from a SignSolanaTransactionWithResponse call
func ParseSignSolanaTransactionResponse(rsp *http.Response) (*SignSolanaTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SignSolanaTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// SignedTransaction The base64 encoded signed transaction.
			SignedTransaction string `json:"signedTransaction"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest PaymentMethodRequiredError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExistsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseRequestSolanaFaucetResponse parses an HTTP response from a RequestSolanaFaucetWithResponse call
func ParseRequestSolanaFaucetResponse(rsp *http.Response) (*RequestSolanaFaucetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RequestSolanaFaucetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// TransactionSignature The signature identifying the transaction that requested the funds.
			TransactionSignature string `json:"transactionSignature"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest BadGatewayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}
