// Package openapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.16.3 DO NOT EDIT.
package openapi

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/oapi-codegen/runtime"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for ErrorType.
const (
	ErrorTypeAlreadyExists        ErrorType = "already_exists"
	ErrorTypeFaucetLimitExceeded  ErrorType = "faucet_limit_exceeded"
	ErrorTypeForbidden            ErrorType = "forbidden"
	ErrorTypeIdempotencyError     ErrorType = "idempotency_error"
	ErrorTypeInternalServerError  ErrorType = "internal_server_error"
	ErrorTypeInvalidRequest       ErrorType = "invalid_request"
	ErrorTypeInvalidSignature     ErrorType = "invalid_signature"
	ErrorTypeMalformedTransaction ErrorType = "malformed_transaction"
	ErrorTypeNotFound             ErrorType = "not_found"
	ErrorTypePolicyViolation      ErrorType = "policy_violation"
	ErrorTypeRateLimitExceeded    ErrorType = "rate_limit_exceeded"
	ErrorTypeRequestCanceled      ErrorType = "request_canceled"
	ErrorTypeTimedOut             ErrorType = "timed_out"
	ErrorTypeUnauthorized         ErrorType = "unauthorized"
)

// Defines values for EvmUserOperationNetwork.
const (
	EvmUserOperationNetworkBase        EvmUserOperationNetwork = "base"
	EvmUserOperationNetworkBaseSepolia EvmUserOperationNetwork = "base-sepolia"
)

// Defines values for EvmUserOperationStatus.
const (
	Broadcast EvmUserOperationStatus = "broadcast"
	Complete  EvmUserOperationStatus = "complete"
	Failed    EvmUserOperationStatus = "failed"
	Pending   EvmUserOperationStatus = "pending"
	Signed    EvmUserOperationStatus = "signed"
)

// Defines values for ListEvmTokenBalancesNetwork.
const (
	ListEvmTokenBalancesNetworkBase        ListEvmTokenBalancesNetwork = "base"
	ListEvmTokenBalancesNetworkBaseSepolia ListEvmTokenBalancesNetwork = "base-sepolia"
)

// Defines values for SendEvmTransactionJSONBodyNetwork.
const (
	SendEvmTransactionJSONBodyNetworkBase        SendEvmTransactionJSONBodyNetwork = "base"
	SendEvmTransactionJSONBodyNetworkBaseSepolia SendEvmTransactionJSONBodyNetwork = "base-sepolia"
)

// Defines values for SignEvmUserOperationJSONBodyNetwork.
const (
	SignEvmUserOperationJSONBodyNetworkBase        SignEvmUserOperationJSONBodyNetwork = "base"
	SignEvmUserOperationJSONBodyNetworkBaseSepolia SignEvmUserOperationJSONBodyNetwork = "base-sepolia"
)

// Defines values for RequestEvmFaucetJSONBodyNetwork.
const (
	RequestEvmFaucetJSONBodyNetworkBaseSepolia     RequestEvmFaucetJSONBodyNetwork = "base-sepolia"
	RequestEvmFaucetJSONBodyNetworkEthereumSepolia RequestEvmFaucetJSONBodyNetwork = "ethereum-sepolia"
)

// Defines values for RequestEvmFaucetJSONBodyToken.
const (
	RequestEvmFaucetJSONBodyTokenCbbtc RequestEvmFaucetJSONBodyToken = "cbbtc"
	RequestEvmFaucetJSONBodyTokenEth   RequestEvmFaucetJSONBodyToken = "eth"
	RequestEvmFaucetJSONBodyTokenEurc  RequestEvmFaucetJSONBodyToken = "eurc"
	RequestEvmFaucetJSONBodyTokenUsdc  RequestEvmFaucetJSONBodyToken = "usdc"
)

// Defines values for PrepareUserOperationJSONBodyNetwork.
const (
	PrepareUserOperationJSONBodyNetworkBase        PrepareUserOperationJSONBodyNetwork = "base"
	PrepareUserOperationJSONBodyNetworkBaseSepolia PrepareUserOperationJSONBodyNetwork = "base-sepolia"
)

// Defines values for RequestSolanaFaucetJSONBodyToken.
const (
	RequestSolanaFaucetJSONBodyTokenSol  RequestSolanaFaucetJSONBodyToken = "sol"
	RequestSolanaFaucetJSONBodyTokenUsdc RequestSolanaFaucetJSONBodyToken = "usdc"
)

// Error An error response including the code for the type of error and a human-readable message describing the error.
type Error struct {
	// CorrelationId A unique identifier for the request that generated the error. This can be used to help debug issues with the API.
	CorrelationId *string `json:"correlationId,omitempty"`

	// ErrorLink A link to the corresponding error documentation.
	ErrorLink *string `json:"errorLink,omitempty"`

	// ErrorMessage The error message.
	ErrorMessage string `json:"errorMessage"`

	// ErrorType The code that indicates the type of error that occurred. These error codes can be used to determine how to handle the error.
	ErrorType ErrorType `json:"errorType"`
}

// ErrorType The code that indicates the type of error that occurred. These error codes can be used to determine how to handle the error.
type ErrorType string

// EvmAccount defines model for EvmAccount.
type EvmAccount struct {
	// Address The 0x-prefixed, checksum EVM address.
	Address string `json:"address"`

	// Name An optional name for the account.
	// Account names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.
	// Account names are guaranteed to be unique across all EVM accounts in the developer's CDP Project.
	Name *string `json:"name,omitempty"`
}

// EvmCall defines model for EvmCall.
type EvmCall struct {
	// Data The call data to send. This is the hex-encoded data of the function call consisting of the method selector and the function arguments.
	Data string `json:"data"`

	// To The address the call is directed to.
	To string `json:"to"`

	// Value The amount of ETH to send with the call, in wei.
	Value string `json:"value"`
}

// EvmSmartAccount defines model for EvmSmartAccount.
type EvmSmartAccount struct {
	// Address The 0x-prefixed, checksum address of the Smart Account.
	Address string `json:"address"`

	// Name An optional name for the account.
	// Account names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.
	// Account names are guaranteed to be unique across all Smart Accounts in the developer's CDP Project.
	Name *string `json:"name,omitempty"`

	// Owners Today, only a single owner can be set for a Smart Account, but this is an array to allow having multiple owners in the future. The address is a 0x-prefixed, checksum address.
	Owners []string `json:"owners"`
}

// EvmUserOperation defines model for EvmUserOperation.
type EvmUserOperation struct {
	// Calls The list of calls in the user operation.
	Calls []EvmCall `json:"calls"`

	// Network The network the user operation is for.
	Network EvmUserOperationNetwork `json:"network"`

	// Status The status of the user operation.
	Status EvmUserOperationStatus `json:"status"`

	// TransactionHash The hash of the transaction that included this particular user operation. This gets set after the user operation is broadcasted and the transaction is included in a block.
	TransactionHash *string `json:"transactionHash,omitempty"`

	// UserOpHash The hash of the user operation. This is not the transaction hash, as a transaction consists of multiple user operations. The user operation hash is the hash of this particular user operation which gets signed by the owner of the Smart Account.
	UserOpHash string `json:"userOpHash"`
}

// EvmUserOperationNetwork The network the user operation is for.
type EvmUserOperationNetwork string

// EvmUserOperationStatus The status of the user operation.
type EvmUserOperationStatus string

// ListEvmTokenBalancesNetwork The name of the supported EVM networks in human-readable format.
type ListEvmTokenBalancesNetwork string

// ListResponse defines model for ListResponse.
type ListResponse struct {
	// NextPageToken The token for the next page of items, if any.
	NextPageToken *string `json:"nextPageToken,omitempty"`
}

// SolanaAccount defines model for SolanaAccount.
type SolanaAccount struct {
	// Address The base58 encoded Solana address.
	Address string `json:"address"`

	// Name An optional name for the account.
	// Account names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.
	// Account names are guaranteed to be unique across all Solana accounts in the developer's CDP Project.
	Name *string `json:"name,omitempty"`
}

// Token General information about a token. Includes the type, the network, and other identifying information.
type Token struct {
	// ContractAddress The contract address of the token.
	// For Ether, the contract address is `0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE` per [EIP-7528](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-7528.md). For ERC-20 tokens, this is the contract address where the token is deployed.
	ContractAddress string `json:"contractAddress"`

	// Name The name of this token (ex: "Solana", "Ether", "USD Coin").
	// The token name is not unique. It is possible for two different tokens to have the same name.
	// For native gas tokens, this name is defined via convention. As an example, for ETH on Ethereum mainnet, the name is "Ether". For ERC-20 tokens, this name is defined via configuration. `name` will be the string returned by `function name() public view returns (string)` on the underlying token contract.
	// Not all tokens have a name, as this function is [optional in the ERC-20 specification](https://eips.ethereum.org/EIPS/eip-20#name). This field will only be populated when the token's underlying ERC-20 contract has a `name()` function.
	// Further, this endpoint will only populate this value for a small subset of whitelisted ERC-20 tokens at this time. We intend to improve coverage in the future.
	Name *string `json:"name,omitempty"`

	// Network The name of the supported EVM networks in human-readable format.
	Network ListEvmTokenBalancesNetwork `json:"network"`

	// Symbol The symbol of this token (ex: SOL, ETH, USDC).
	// The token symbol is not unique. It is possible for two different tokens to have the same symbol.
	// For native gas tokens, this symbol is defined via convention. As an example, for ETH on Ethereum mainnet, the symbol is "ETH". For ERC-20 tokens, this symbol is defined via configuration. `symbol` will be the string returned by `function symbol() public view returns (string)` on the underlying token contract.
	// Not all tokens have a symbol, as this function is [optional in the ERC-20 specification](https://eips.ethereum.org/EIPS/eip-20#symbol). This field will only be populated when the token's underlying ERC-20 contract has a `symbol()` function.
	// Further, this endpoint will only populate this value for a small subset of whitelisted ERC-20 tokens at this time. We intend to improve coverage in the future.
	Symbol *string `json:"symbol,omitempty"`
}

// TokenAmount Amount of a given token.
type TokenAmount struct {
	// Amount The amount is denominated in the smallest indivisible unit of the token. For ETH, the smallest indivisible unit is Wei (10^-18 ETH). For ERC-20s, the smallest unit is the unit returned from `function totalSupply() public view returns (uint256)`.
	Amount string `json:"amount"`

	// Decimals 'decimals' is the exponential value N that satisfies the equation `amount * 10^-N = standard_denomination`. The standard denomination is the most commonly used denomination for the token.
	// - In the case of the native gas token, `decimals` is defined via convention. As an example, for ETH of Ethereum mainnet, the standard denomination is 10^-18 the smallest denomination (Wei). As such, for ETH on Ethereum mainnet, `decimals` is 18. - In the case of ERC-20 tokens, `decimals` is defined via configuration. `decimals` will be the number returned by `function decimals() public view returns (uint8)` on the underlying token contract.
	// Not all tokens have a `decimals` field, as this function is [optional in the ERC-20 specification](https://eips.ethereum.org/EIPS/eip-20#decimals). This field will be left empty if the underlying token contract doesn't implement `decimals`.
	// Further, this endpoint will only populate this value for a small subset of whitelisted ERC-20 tokens at this time. We intend to improve coverage in the future.
	Decimals int64 `json:"decimals"`
}

// TokenBalance defines model for TokenBalance.
type TokenBalance struct {
	// Amount Amount of a given token.
	Amount TokenAmount `json:"amount"`

	// Token General information about a token. Includes the type, the network, and other identifying information.
	Token Token `json:"token"`
}

// IdempotencyKey defines model for IdempotencyKey.
type IdempotencyKey = string

// XWalletAuth defines model for XWalletAuth.
type XWalletAuth = string

// AlreadyExistsError An error response including the code for the type of error and a human-readable message describing the error.
type AlreadyExistsError = Error

// IdempotencyError An error response including the code for the type of error and a human-readable message describing the error.
type IdempotencyError = Error

// InternalServerError An error response including the code for the type of error and a human-readable message describing the error.
type InternalServerError = Error

// ListEvmAccountsParams defines parameters for ListEvmAccounts.
type ListEvmAccountsParams struct {
	// PageSize The number of accounts to return per page.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// PageToken The token for the next page of accounts, if any.
	PageToken *string `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// CreateEvmAccountJSONBody defines parameters for CreateEvmAccount.
type CreateEvmAccountJSONBody struct {
	// Name An optional name for the account.
	// Account names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.
	// Account names must be unique across all EVM accounts in the developer's CDP Project.
	Name *string `json:"name,omitempty"`
}

// CreateEvmAccountParams defines parameters for CreateEvmAccount.
type CreateEvmAccountParams struct {
	// XWalletAuth A JWT signed using your Wallet Secret, encoded in base64. Refer to the
	// [Generate Wallet Token](https://docs.cdp.coinbase.com/api-v2/docs/authentication#2-generate-wallet-token)
	// section of our Authentication docs for more details on how to generate your Wallet Token.
	XWalletAuth *XWalletAuth `json:"X-Wallet-Auth,omitempty"`

	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-v2/docs/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// SendEvmTransactionJSONBody defines parameters for SendEvmTransaction.
type SendEvmTransactionJSONBody struct {
	// Network The network to send the transaction to.
	Network SendEvmTransactionJSONBodyNetwork `json:"network"`

	// Transaction The RLP-encoded transaction to sign and send, as a 0x-prefixed hex string.
	Transaction string `json:"transaction"`
}

// SendEvmTransactionParams defines parameters for SendEvmTransaction.
type SendEvmTransactionParams struct {
	// XWalletAuth A JWT signed using your Wallet Secret, encoded in base64. Refer to the
	// [Generate Wallet Token](https://docs.cdp.coinbase.com/api-v2/docs/authentication#2-generate-wallet-token)
	// section of our Authentication docs for more details on how to generate your Wallet Token.
	XWalletAuth *XWalletAuth `json:"X-Wallet-Auth,omitempty"`

	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-v2/docs/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// SendEvmTransactionJSONBodyNetwork defines parameters for SendEvmTransaction.
type SendEvmTransactionJSONBodyNetwork string

// SignEvmHashJSONBody defines parameters for SignEvmHash.
type SignEvmHashJSONBody struct {
	// Hash The arbitrary 32 byte hash to sign.
	Hash string `json:"hash"`
}

// SignEvmHashParams defines parameters for SignEvmHash.
type SignEvmHashParams struct {
	// XWalletAuth A JWT signed using your Wallet Secret, encoded in base64. Refer to the
	// [Generate Wallet Token](https://docs.cdp.coinbase.com/api-v2/docs/authentication#2-generate-wallet-token)
	// section of our Authentication docs for more details on how to generate your Wallet Token.
	XWalletAuth *XWalletAuth `json:"X-Wallet-Auth,omitempty"`

	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-v2/docs/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// SignEvmMessageJSONBody defines parameters for SignEvmMessage.
type SignEvmMessageJSONBody struct {
	// Message The message to sign.
	Message string `json:"message"`
}

// SignEvmMessageParams defines parameters for SignEvmMessage.
type SignEvmMessageParams struct {
	// XWalletAuth A JWT signed using your Wallet Secret, encoded in base64. Refer to the
	// [Generate Wallet Token](https://docs.cdp.coinbase.com/api-v2/docs/authentication#2-generate-wallet-token)
	// section of our Authentication docs for more details on how to generate your Wallet Token.
	XWalletAuth *XWalletAuth `json:"X-Wallet-Auth,omitempty"`

	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-v2/docs/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// SignEvmTransactionJSONBody defines parameters for SignEvmTransaction.
type SignEvmTransactionJSONBody struct {
	// Transaction The RLP-encoded transaction to sign, as a 0x-prefixed hex string.
	Transaction string `json:"transaction"`
}

// SignEvmTransactionParams defines parameters for SignEvmTransaction.
type SignEvmTransactionParams struct {
	// XWalletAuth A JWT signed using your Wallet Secret, encoded in base64. Refer to the
	// [Generate Wallet Token](https://docs.cdp.coinbase.com/api-v2/docs/authentication#2-generate-wallet-token)
	// section of our Authentication docs for more details on how to generate your Wallet Token.
	XWalletAuth *XWalletAuth `json:"X-Wallet-Auth,omitempty"`

	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-v2/docs/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// SignEvmUserOperationJSONBody defines parameters for SignEvmUserOperation.
type SignEvmUserOperationJSONBody struct {
	// Network The network to sign the user operation for.
	Network SignEvmUserOperationJSONBodyNetwork `json:"network"`

	// SmartAccountAddress The address of the Smart Account to sign the user operation for.
	SmartAccountAddress string `json:"smartAccountAddress"`

	// UserOpHash The hash of the user operation, as a 0x-prefixed hex string.
	UserOpHash string `json:"userOpHash"`
}

// SignEvmUserOperationParams defines parameters for SignEvmUserOperation.
type SignEvmUserOperationParams struct {
	// XWalletAuth A JWT signed using your Wallet Secret, encoded in base64. Refer to the
	// [Generate Wallet Token](https://docs.cdp.coinbase.com/api-v2/docs/authentication#2-generate-wallet-token)
	// section of our Authentication docs for more details on how to generate your Wallet Token.
	XWalletAuth *XWalletAuth `json:"X-Wallet-Auth,omitempty"`

	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-v2/docs/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// SignEvmUserOperationJSONBodyNetwork defines parameters for SignEvmUserOperation.
type SignEvmUserOperationJSONBodyNetwork string

// RequestEvmFaucetJSONBody defines parameters for RequestEvmFaucet.
type RequestEvmFaucetJSONBody struct {
	// Address The address to request funds to, which is a 0x-prefixed hexadecimal string.
	Address string `json:"address"`

	// Network The network to request funds from.
	Network RequestEvmFaucetJSONBodyNetwork `json:"network"`

	// Token The token to request funds for.
	Token RequestEvmFaucetJSONBodyToken `json:"token"`
}

// RequestEvmFaucetJSONBodyNetwork defines parameters for RequestEvmFaucet.
type RequestEvmFaucetJSONBodyNetwork string

// RequestEvmFaucetJSONBodyToken defines parameters for RequestEvmFaucet.
type RequestEvmFaucetJSONBodyToken string

// ListEvmSmartAccountsParams defines parameters for ListEvmSmartAccounts.
type ListEvmSmartAccountsParams struct {
	// PageSize The number of accounts to return per page.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// PageToken The token for the next page of accounts, if any.
	PageToken *string `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// CreateEvmSmartAccountJSONBody defines parameters for CreateEvmSmartAccount.
type CreateEvmSmartAccountJSONBody struct {
	// Owners Today, only a single owner can be set for a Smart Account, but this is an array to allow setting multiple owners in the future.
	Owners []string `json:"owners"`
}

// PrepareUserOperationJSONBody defines parameters for PrepareUserOperation.
type PrepareUserOperationJSONBody struct {
	// Calls The list of calls to make from the Smart Account.
	Calls []EvmCall `json:"calls"`

	// Network The network to prepare the user operation for.
	Network PrepareUserOperationJSONBodyNetwork `json:"network"`

	// PaymasterUrl The URL of the paymaster to use for the user operation.
	PaymasterUrl *string `json:"paymasterUrl,omitempty"`
}

// PrepareUserOperationJSONBodyNetwork defines parameters for PrepareUserOperation.
type PrepareUserOperationJSONBodyNetwork string

// SendUserOperationJSONBody defines parameters for SendUserOperation.
type SendUserOperationJSONBody struct {
	// Signature The hex-encoded signature of the user operation. This should be a 65-byte signature consisting of the `r`, `s`, and `v` values of the ECDSA signature. Note that the `v` value should conform to the `personal_sign` standard, which means it should be 27 or 28.
	Signature string `json:"signature"`
}

// ListEvmTokenBalancesParams defines parameters for ListEvmTokenBalances.
type ListEvmTokenBalancesParams struct {
	// PageSize The number of balances to return per page.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// PageToken The token for the next page of balances. Will be empty if there are no more balances to fetch.
	PageToken *string `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// ListSolanaAccountsParams defines parameters for ListSolanaAccounts.
type ListSolanaAccountsParams struct {
	// PageSize The number of accounts to return per page.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// PageToken The token for the next page of accounts, if any.
	PageToken *string `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// CreateSolanaAccountJSONBody defines parameters for CreateSolanaAccount.
type CreateSolanaAccountJSONBody struct {
	// Name An optional name for the account.
	// Account names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.
	// Account names must be unique across all Solana accounts in the developer's CDP Project.
	Name *string `json:"name,omitempty"`
}

// CreateSolanaAccountParams defines parameters for CreateSolanaAccount.
type CreateSolanaAccountParams struct {
	// XWalletAuth A JWT signed using your Wallet Secret, encoded in base64. Refer to the
	// [Generate Wallet Token](https://docs.cdp.coinbase.com/api-v2/docs/authentication#2-generate-wallet-token)
	// section of our Authentication docs for more details on how to generate your Wallet Token.
	XWalletAuth *XWalletAuth `json:"X-Wallet-Auth,omitempty"`

	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-v2/docs/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// SignSolanaMessageJSONBody defines parameters for SignSolanaMessage.
type SignSolanaMessageJSONBody struct {
	// Message The arbitrary message to sign.
	Message string `json:"message"`
}

// SignSolanaMessageParams defines parameters for SignSolanaMessage.
type SignSolanaMessageParams struct {
	// XWalletAuth A JWT signed using your Wallet Secret, encoded in base64. Refer to the
	// [Generate Wallet Token](https://docs.cdp.coinbase.com/api-v2/docs/authentication#2-generate-wallet-token)
	// section of our Authentication docs for more details on how to generate your Wallet Token.
	XWalletAuth *XWalletAuth `json:"X-Wallet-Auth,omitempty"`

	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-v2/docs/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// SignSolanaTransactionJSONBody defines parameters for SignSolanaTransaction.
type SignSolanaTransactionJSONBody struct {
	// Transaction The base64 encoded transaction to sign.
	Transaction string `json:"transaction"`
}

// SignSolanaTransactionParams defines parameters for SignSolanaTransaction.
type SignSolanaTransactionParams struct {
	// XWalletAuth A JWT signed using your Wallet Secret, encoded in base64. Refer to the
	// [Generate Wallet Token](https://docs.cdp.coinbase.com/api-v2/docs/authentication#2-generate-wallet-token)
	// section of our Authentication docs for more details on how to generate your Wallet Token.
	XWalletAuth *XWalletAuth `json:"X-Wallet-Auth,omitempty"`

	// XIdempotencyKey An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.
	// When included, duplicate requests with the same key will return identical responses.
	// Refer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-v2/docs/idempotency) for more information on using idempotency keys.
	XIdempotencyKey *IdempotencyKey `json:"X-Idempotency-Key,omitempty"`
}

// RequestSolanaFaucetJSONBody defines parameters for RequestSolanaFaucet.
type RequestSolanaFaucetJSONBody struct {
	// Address The address to request funds to, which is a base58-encoded string.
	Address string `json:"address"`

	// Token The token to request funds for.
	Token RequestSolanaFaucetJSONBodyToken `json:"token"`
}

// RequestSolanaFaucetJSONBodyToken defines parameters for RequestSolanaFaucet.
type RequestSolanaFaucetJSONBodyToken string

// CreateEvmAccountJSONRequestBody defines body for CreateEvmAccount for application/json ContentType.
type CreateEvmAccountJSONRequestBody CreateEvmAccountJSONBody

// SendEvmTransactionJSONRequestBody defines body for SendEvmTransaction for application/json ContentType.
type SendEvmTransactionJSONRequestBody SendEvmTransactionJSONBody

// SignEvmHashJSONRequestBody defines body for SignEvmHash for application/json ContentType.
type SignEvmHashJSONRequestBody SignEvmHashJSONBody

// SignEvmMessageJSONRequestBody defines body for SignEvmMessage for application/json ContentType.
type SignEvmMessageJSONRequestBody SignEvmMessageJSONBody

// SignEvmTransactionJSONRequestBody defines body for SignEvmTransaction for application/json ContentType.
type SignEvmTransactionJSONRequestBody SignEvmTransactionJSONBody

// SignEvmUserOperationJSONRequestBody defines body for SignEvmUserOperation for application/json ContentType.
type SignEvmUserOperationJSONRequestBody SignEvmUserOperationJSONBody

// RequestEvmFaucetJSONRequestBody defines body for RequestEvmFaucet for application/json ContentType.
type RequestEvmFaucetJSONRequestBody RequestEvmFaucetJSONBody

// CreateEvmSmartAccountJSONRequestBody defines body for CreateEvmSmartAccount for application/json ContentType.
type CreateEvmSmartAccountJSONRequestBody CreateEvmSmartAccountJSONBody

// PrepareUserOperationJSONRequestBody defines body for PrepareUserOperation for application/json ContentType.
type PrepareUserOperationJSONRequestBody PrepareUserOperationJSONBody

// SendUserOperationJSONRequestBody defines body for SendUserOperation for application/json ContentType.
type SendUserOperationJSONRequestBody SendUserOperationJSONBody

// CreateSolanaAccountJSONRequestBody defines body for CreateSolanaAccount for application/json ContentType.
type CreateSolanaAccountJSONRequestBody CreateSolanaAccountJSONBody

// SignSolanaMessageJSONRequestBody defines body for SignSolanaMessage for application/json ContentType.
type SignSolanaMessageJSONRequestBody SignSolanaMessageJSONBody

// SignSolanaTransactionJSONRequestBody defines body for SignSolanaTransaction for application/json ContentType.
type SignSolanaTransactionJSONRequestBody SignSolanaTransactionJSONBody

// RequestSolanaFaucetJSONRequestBody defines body for RequestSolanaFaucet for application/json ContentType.
type RequestSolanaFaucetJSONRequestBody RequestSolanaFaucetJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// CDPClient which conforms to the OpenAPI3 specification for this service.
type CDPClient struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*CDPClient) error

// Creates a new CDPClient, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*CDPClient, error) {
	// create a client with sane default values
	client := CDPClient{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *CDPClient) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *CDPClient) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListEvmAccounts request
	ListEvmAccounts(ctx context.Context, params *ListEvmAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateEvmAccountWithBody request with any body
	CreateEvmAccountWithBody(ctx context.Context, params *CreateEvmAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateEvmAccount(ctx context.Context, params *CreateEvmAccountParams, body CreateEvmAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEvmAccountByName request
	GetEvmAccountByName(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEvmAccount request
	GetEvmAccount(ctx context.Context, address string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendEvmTransactionWithBody request with any body
	SendEvmTransactionWithBody(ctx context.Context, address string, params *SendEvmTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SendEvmTransaction(ctx context.Context, address string, params *SendEvmTransactionParams, body SendEvmTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SignEvmHashWithBody request with any body
	SignEvmHashWithBody(ctx context.Context, address string, params *SignEvmHashParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SignEvmHash(ctx context.Context, address string, params *SignEvmHashParams, body SignEvmHashJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SignEvmMessageWithBody request with any body
	SignEvmMessageWithBody(ctx context.Context, address string, params *SignEvmMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SignEvmMessage(ctx context.Context, address string, params *SignEvmMessageParams, body SignEvmMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SignEvmTransactionWithBody request with any body
	SignEvmTransactionWithBody(ctx context.Context, address string, params *SignEvmTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SignEvmTransaction(ctx context.Context, address string, params *SignEvmTransactionParams, body SignEvmTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SignEvmUserOperationWithBody request with any body
	SignEvmUserOperationWithBody(ctx context.Context, address string, params *SignEvmUserOperationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SignEvmUserOperation(ctx context.Context, address string, params *SignEvmUserOperationParams, body SignEvmUserOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RequestEvmFaucetWithBody request with any body
	RequestEvmFaucetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RequestEvmFaucet(ctx context.Context, body RequestEvmFaucetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListEvmSmartAccounts request
	ListEvmSmartAccounts(ctx context.Context, params *ListEvmSmartAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateEvmSmartAccountWithBody request with any body
	CreateEvmSmartAccountWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateEvmSmartAccount(ctx context.Context, body CreateEvmSmartAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEvmSmartAccount request
	GetEvmSmartAccount(ctx context.Context, address string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PrepareUserOperationWithBody request with any body
	PrepareUserOperationWithBody(ctx context.Context, address string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PrepareUserOperation(ctx context.Context, address string, body PrepareUserOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserOperation request
	GetUserOperation(ctx context.Context, address string, userOpHash string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendUserOperationWithBody request with any body
	SendUserOperationWithBody(ctx context.Context, address string, userOpHash string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SendUserOperation(ctx context.Context, address string, userOpHash string, body SendUserOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListEvmTokenBalances request
	ListEvmTokenBalances(ctx context.Context, network ListEvmTokenBalancesNetwork, address string, params *ListEvmTokenBalancesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSolanaAccounts request
	ListSolanaAccounts(ctx context.Context, params *ListSolanaAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSolanaAccountWithBody request with any body
	CreateSolanaAccountWithBody(ctx context.Context, params *CreateSolanaAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSolanaAccount(ctx context.Context, params *CreateSolanaAccountParams, body CreateSolanaAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSolanaAccountByName request
	GetSolanaAccountByName(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSolanaAccount request
	GetSolanaAccount(ctx context.Context, address string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SignSolanaMessageWithBody request with any body
	SignSolanaMessageWithBody(ctx context.Context, address string, params *SignSolanaMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SignSolanaMessage(ctx context.Context, address string, params *SignSolanaMessageParams, body SignSolanaMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SignSolanaTransactionWithBody request with any body
	SignSolanaTransactionWithBody(ctx context.Context, address string, params *SignSolanaTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SignSolanaTransaction(ctx context.Context, address string, params *SignSolanaTransactionParams, body SignSolanaTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RequestSolanaFaucetWithBody request with any body
	RequestSolanaFaucetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RequestSolanaFaucet(ctx context.Context, body RequestSolanaFaucetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *CDPClient) ListEvmAccounts(ctx context.Context, params *ListEvmAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListEvmAccountsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) CreateEvmAccountWithBody(ctx context.Context, params *CreateEvmAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEvmAccountRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) CreateEvmAccount(ctx context.Context, params *CreateEvmAccountParams, body CreateEvmAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEvmAccountRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) GetEvmAccountByName(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEvmAccountByNameRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) GetEvmAccount(ctx context.Context, address string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEvmAccountRequest(c.Server, address)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SendEvmTransactionWithBody(ctx context.Context, address string, params *SendEvmTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendEvmTransactionRequestWithBody(c.Server, address, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SendEvmTransaction(ctx context.Context, address string, params *SendEvmTransactionParams, body SendEvmTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendEvmTransactionRequest(c.Server, address, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SignEvmHashWithBody(ctx context.Context, address string, params *SignEvmHashParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSignEvmHashRequestWithBody(c.Server, address, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SignEvmHash(ctx context.Context, address string, params *SignEvmHashParams, body SignEvmHashJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSignEvmHashRequest(c.Server, address, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SignEvmMessageWithBody(ctx context.Context, address string, params *SignEvmMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSignEvmMessageRequestWithBody(c.Server, address, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SignEvmMessage(ctx context.Context, address string, params *SignEvmMessageParams, body SignEvmMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSignEvmMessageRequest(c.Server, address, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SignEvmTransactionWithBody(ctx context.Context, address string, params *SignEvmTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSignEvmTransactionRequestWithBody(c.Server, address, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SignEvmTransaction(ctx context.Context, address string, params *SignEvmTransactionParams, body SignEvmTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSignEvmTransactionRequest(c.Server, address, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SignEvmUserOperationWithBody(ctx context.Context, address string, params *SignEvmUserOperationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSignEvmUserOperationRequestWithBody(c.Server, address, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SignEvmUserOperation(ctx context.Context, address string, params *SignEvmUserOperationParams, body SignEvmUserOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSignEvmUserOperationRequest(c.Server, address, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) RequestEvmFaucetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRequestEvmFaucetRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) RequestEvmFaucet(ctx context.Context, body RequestEvmFaucetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRequestEvmFaucetRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) ListEvmSmartAccounts(ctx context.Context, params *ListEvmSmartAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListEvmSmartAccountsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) CreateEvmSmartAccountWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEvmSmartAccountRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) CreateEvmSmartAccount(ctx context.Context, body CreateEvmSmartAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEvmSmartAccountRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) GetEvmSmartAccount(ctx context.Context, address string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEvmSmartAccountRequest(c.Server, address)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) PrepareUserOperationWithBody(ctx context.Context, address string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPrepareUserOperationRequestWithBody(c.Server, address, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) PrepareUserOperation(ctx context.Context, address string, body PrepareUserOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPrepareUserOperationRequest(c.Server, address, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) GetUserOperation(ctx context.Context, address string, userOpHash string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserOperationRequest(c.Server, address, userOpHash)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SendUserOperationWithBody(ctx context.Context, address string, userOpHash string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendUserOperationRequestWithBody(c.Server, address, userOpHash, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SendUserOperation(ctx context.Context, address string, userOpHash string, body SendUserOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendUserOperationRequest(c.Server, address, userOpHash, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) ListEvmTokenBalances(ctx context.Context, network ListEvmTokenBalancesNetwork, address string, params *ListEvmTokenBalancesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListEvmTokenBalancesRequest(c.Server, network, address, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) ListSolanaAccounts(ctx context.Context, params *ListSolanaAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSolanaAccountsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) CreateSolanaAccountWithBody(ctx context.Context, params *CreateSolanaAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSolanaAccountRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) CreateSolanaAccount(ctx context.Context, params *CreateSolanaAccountParams, body CreateSolanaAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSolanaAccountRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) GetSolanaAccountByName(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSolanaAccountByNameRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) GetSolanaAccount(ctx context.Context, address string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSolanaAccountRequest(c.Server, address)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SignSolanaMessageWithBody(ctx context.Context, address string, params *SignSolanaMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSignSolanaMessageRequestWithBody(c.Server, address, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SignSolanaMessage(ctx context.Context, address string, params *SignSolanaMessageParams, body SignSolanaMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSignSolanaMessageRequest(c.Server, address, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SignSolanaTransactionWithBody(ctx context.Context, address string, params *SignSolanaTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSignSolanaTransactionRequestWithBody(c.Server, address, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) SignSolanaTransaction(ctx context.Context, address string, params *SignSolanaTransactionParams, body SignSolanaTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSignSolanaTransactionRequest(c.Server, address, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) RequestSolanaFaucetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRequestSolanaFaucetRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *CDPClient) RequestSolanaFaucet(ctx context.Context, body RequestSolanaFaucetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRequestSolanaFaucetRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListEvmAccountsRequest generates requests for ListEvmAccounts
func NewListEvmAccountsRequest(server string, params *ListEvmAccountsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/accounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateEvmAccountRequest calls the generic CreateEvmAccount builder with application/json body
func NewCreateEvmAccountRequest(server string, params *CreateEvmAccountParams, body CreateEvmAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateEvmAccountRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateEvmAccountRequestWithBody generates requests for CreateEvmAccount with any type of body
func NewCreateEvmAccountRequestWithBody(server string, params *CreateEvmAccountParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/accounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XWalletAuth != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Wallet-Auth", runtime.ParamLocationHeader, *params.XWalletAuth)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Wallet-Auth", headerParam0)
		}

		if params.XIdempotencyKey != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam1)
		}

	}

	return req, nil
}

// NewGetEvmAccountByNameRequest generates requests for GetEvmAccountByName
func NewGetEvmAccountByNameRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/accounts/by-name/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEvmAccountRequest generates requests for GetEvmAccount
func NewGetEvmAccountRequest(server string, address string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/accounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSendEvmTransactionRequest calls the generic SendEvmTransaction builder with application/json body
func NewSendEvmTransactionRequest(server string, address string, params *SendEvmTransactionParams, body SendEvmTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSendEvmTransactionRequestWithBody(server, address, params, "application/json", bodyReader)
}

// NewSendEvmTransactionRequestWithBody generates requests for SendEvmTransaction with any type of body
func NewSendEvmTransactionRequestWithBody(server string, address string, params *SendEvmTransactionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/accounts/%s/send/transaction", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XWalletAuth != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Wallet-Auth", runtime.ParamLocationHeader, *params.XWalletAuth)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Wallet-Auth", headerParam0)
		}

		if params.XIdempotencyKey != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam1)
		}

	}

	return req, nil
}

// NewSignEvmHashRequest calls the generic SignEvmHash builder with application/json body
func NewSignEvmHashRequest(server string, address string, params *SignEvmHashParams, body SignEvmHashJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSignEvmHashRequestWithBody(server, address, params, "application/json", bodyReader)
}

// NewSignEvmHashRequestWithBody generates requests for SignEvmHash with any type of body
func NewSignEvmHashRequestWithBody(server string, address string, params *SignEvmHashParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/accounts/%s/sign", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XWalletAuth != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Wallet-Auth", runtime.ParamLocationHeader, *params.XWalletAuth)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Wallet-Auth", headerParam0)
		}

		if params.XIdempotencyKey != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam1)
		}

	}

	return req, nil
}

// NewSignEvmMessageRequest calls the generic SignEvmMessage builder with application/json body
func NewSignEvmMessageRequest(server string, address string, params *SignEvmMessageParams, body SignEvmMessageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSignEvmMessageRequestWithBody(server, address, params, "application/json", bodyReader)
}

// NewSignEvmMessageRequestWithBody generates requests for SignEvmMessage with any type of body
func NewSignEvmMessageRequestWithBody(server string, address string, params *SignEvmMessageParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/accounts/%s/sign/message", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XWalletAuth != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Wallet-Auth", runtime.ParamLocationHeader, *params.XWalletAuth)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Wallet-Auth", headerParam0)
		}

		if params.XIdempotencyKey != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam1)
		}

	}

	return req, nil
}

// NewSignEvmTransactionRequest calls the generic SignEvmTransaction builder with application/json body
func NewSignEvmTransactionRequest(server string, address string, params *SignEvmTransactionParams, body SignEvmTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSignEvmTransactionRequestWithBody(server, address, params, "application/json", bodyReader)
}

// NewSignEvmTransactionRequestWithBody generates requests for SignEvmTransaction with any type of body
func NewSignEvmTransactionRequestWithBody(server string, address string, params *SignEvmTransactionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/accounts/%s/sign/transaction", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XWalletAuth != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Wallet-Auth", runtime.ParamLocationHeader, *params.XWalletAuth)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Wallet-Auth", headerParam0)
		}

		if params.XIdempotencyKey != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam1)
		}

	}

	return req, nil
}

// NewSignEvmUserOperationRequest calls the generic SignEvmUserOperation builder with application/json body
func NewSignEvmUserOperationRequest(server string, address string, params *SignEvmUserOperationParams, body SignEvmUserOperationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSignEvmUserOperationRequestWithBody(server, address, params, "application/json", bodyReader)
}

// NewSignEvmUserOperationRequestWithBody generates requests for SignEvmUserOperation with any type of body
func NewSignEvmUserOperationRequestWithBody(server string, address string, params *SignEvmUserOperationParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/accounts/%s/sign/user-operation", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XWalletAuth != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Wallet-Auth", runtime.ParamLocationHeader, *params.XWalletAuth)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Wallet-Auth", headerParam0)
		}

		if params.XIdempotencyKey != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam1)
		}

	}

	return req, nil
}

// NewRequestEvmFaucetRequest calls the generic RequestEvmFaucet builder with application/json body
func NewRequestEvmFaucetRequest(server string, body RequestEvmFaucetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRequestEvmFaucetRequestWithBody(server, "application/json", bodyReader)
}

// NewRequestEvmFaucetRequestWithBody generates requests for RequestEvmFaucet with any type of body
func NewRequestEvmFaucetRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/faucet")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListEvmSmartAccountsRequest generates requests for ListEvmSmartAccounts
func NewListEvmSmartAccountsRequest(server string, params *ListEvmSmartAccountsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/smart-accounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateEvmSmartAccountRequest calls the generic CreateEvmSmartAccount builder with application/json body
func NewCreateEvmSmartAccountRequest(server string, body CreateEvmSmartAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateEvmSmartAccountRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateEvmSmartAccountRequestWithBody generates requests for CreateEvmSmartAccount with any type of body
func NewCreateEvmSmartAccountRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/smart-accounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetEvmSmartAccountRequest generates requests for GetEvmSmartAccount
func NewGetEvmSmartAccountRequest(server string, address string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/smart-accounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPrepareUserOperationRequest calls the generic PrepareUserOperation builder with application/json body
func NewPrepareUserOperationRequest(server string, address string, body PrepareUserOperationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPrepareUserOperationRequestWithBody(server, address, "application/json", bodyReader)
}

// NewPrepareUserOperationRequestWithBody generates requests for PrepareUserOperation with any type of body
func NewPrepareUserOperationRequestWithBody(server string, address string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/smart-accounts/%s/user-operations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUserOperationRequest generates requests for GetUserOperation
func NewGetUserOperationRequest(server string, address string, userOpHash string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userOpHash", runtime.ParamLocationPath, userOpHash)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/smart-accounts/%s/user-operations/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSendUserOperationRequest calls the generic SendUserOperation builder with application/json body
func NewSendUserOperationRequest(server string, address string, userOpHash string, body SendUserOperationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSendUserOperationRequestWithBody(server, address, userOpHash, "application/json", bodyReader)
}

// NewSendUserOperationRequestWithBody generates requests for SendUserOperation with any type of body
func NewSendUserOperationRequestWithBody(server string, address string, userOpHash string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userOpHash", runtime.ParamLocationPath, userOpHash)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/smart-accounts/%s/user-operations/%s/send", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListEvmTokenBalancesRequest generates requests for ListEvmTokenBalances
func NewListEvmTokenBalancesRequest(server string, network ListEvmTokenBalancesNetwork, address string, params *ListEvmTokenBalancesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "network", runtime.ParamLocationPath, network)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/evm/token-balances/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSolanaAccountsRequest generates requests for ListSolanaAccounts
func NewListSolanaAccountsRequest(server string, params *ListSolanaAccountsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/solana/accounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSolanaAccountRequest calls the generic CreateSolanaAccount builder with application/json body
func NewCreateSolanaAccountRequest(server string, params *CreateSolanaAccountParams, body CreateSolanaAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSolanaAccountRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateSolanaAccountRequestWithBody generates requests for CreateSolanaAccount with any type of body
func NewCreateSolanaAccountRequestWithBody(server string, params *CreateSolanaAccountParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/solana/accounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XWalletAuth != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Wallet-Auth", runtime.ParamLocationHeader, *params.XWalletAuth)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Wallet-Auth", headerParam0)
		}

		if params.XIdempotencyKey != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam1)
		}

	}

	return req, nil
}

// NewGetSolanaAccountByNameRequest generates requests for GetSolanaAccountByName
func NewGetSolanaAccountByNameRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/solana/accounts/by-name/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSolanaAccountRequest generates requests for GetSolanaAccount
func NewGetSolanaAccountRequest(server string, address string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/solana/accounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSignSolanaMessageRequest calls the generic SignSolanaMessage builder with application/json body
func NewSignSolanaMessageRequest(server string, address string, params *SignSolanaMessageParams, body SignSolanaMessageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSignSolanaMessageRequestWithBody(server, address, params, "application/json", bodyReader)
}

// NewSignSolanaMessageRequestWithBody generates requests for SignSolanaMessage with any type of body
func NewSignSolanaMessageRequestWithBody(server string, address string, params *SignSolanaMessageParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/solana/accounts/%s/sign/message", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XWalletAuth != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Wallet-Auth", runtime.ParamLocationHeader, *params.XWalletAuth)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Wallet-Auth", headerParam0)
		}

		if params.XIdempotencyKey != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam1)
		}

	}

	return req, nil
}

// NewSignSolanaTransactionRequest calls the generic SignSolanaTransaction builder with application/json body
func NewSignSolanaTransactionRequest(server string, address string, params *SignSolanaTransactionParams, body SignSolanaTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSignSolanaTransactionRequestWithBody(server, address, params, "application/json", bodyReader)
}

// NewSignSolanaTransactionRequestWithBody generates requests for SignSolanaTransaction with any type of body
func NewSignSolanaTransactionRequestWithBody(server string, address string, params *SignSolanaTransactionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/solana/accounts/%s/sign/transaction", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XWalletAuth != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Wallet-Auth", runtime.ParamLocationHeader, *params.XWalletAuth)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Wallet-Auth", headerParam0)
		}

		if params.XIdempotencyKey != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Idempotency-Key", runtime.ParamLocationHeader, *params.XIdempotencyKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Idempotency-Key", headerParam1)
		}

	}

	return req, nil
}

// NewRequestSolanaFaucetRequest calls the generic RequestSolanaFaucet builder with application/json body
func NewRequestSolanaFaucetRequest(server string, body RequestSolanaFaucetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRequestSolanaFaucetRequestWithBody(server, "application/json", bodyReader)
}

// NewRequestSolanaFaucetRequestWithBody generates requests for RequestSolanaFaucet with any type of body
func NewRequestSolanaFaucetRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/solana/faucet")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *CDPClient) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *CDPClient) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListEvmAccountsWithResponse request
	ListEvmAccountsWithResponse(ctx context.Context, params *ListEvmAccountsParams, reqEditors ...RequestEditorFn) (*ListEvmAccountsResponse, error)

	// CreateEvmAccountWithBodyWithResponse request with any body
	CreateEvmAccountWithBodyWithResponse(ctx context.Context, params *CreateEvmAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEvmAccountResponse, error)

	CreateEvmAccountWithResponse(ctx context.Context, params *CreateEvmAccountParams, body CreateEvmAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEvmAccountResponse, error)

	// GetEvmAccountByNameWithResponse request
	GetEvmAccountByNameWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetEvmAccountByNameResponse, error)

	// GetEvmAccountWithResponse request
	GetEvmAccountWithResponse(ctx context.Context, address string, reqEditors ...RequestEditorFn) (*GetEvmAccountResponse, error)

	// SendEvmTransactionWithBodyWithResponse request with any body
	SendEvmTransactionWithBodyWithResponse(ctx context.Context, address string, params *SendEvmTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendEvmTransactionResponse, error)

	SendEvmTransactionWithResponse(ctx context.Context, address string, params *SendEvmTransactionParams, body SendEvmTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*SendEvmTransactionResponse, error)

	// SignEvmHashWithBodyWithResponse request with any body
	SignEvmHashWithBodyWithResponse(ctx context.Context, address string, params *SignEvmHashParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SignEvmHashResponse, error)

	SignEvmHashWithResponse(ctx context.Context, address string, params *SignEvmHashParams, body SignEvmHashJSONRequestBody, reqEditors ...RequestEditorFn) (*SignEvmHashResponse, error)

	// SignEvmMessageWithBodyWithResponse request with any body
	SignEvmMessageWithBodyWithResponse(ctx context.Context, address string, params *SignEvmMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SignEvmMessageResponse, error)

	SignEvmMessageWithResponse(ctx context.Context, address string, params *SignEvmMessageParams, body SignEvmMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*SignEvmMessageResponse, error)

	// SignEvmTransactionWithBodyWithResponse request with any body
	SignEvmTransactionWithBodyWithResponse(ctx context.Context, address string, params *SignEvmTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SignEvmTransactionResponse, error)

	SignEvmTransactionWithResponse(ctx context.Context, address string, params *SignEvmTransactionParams, body SignEvmTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*SignEvmTransactionResponse, error)

	// SignEvmUserOperationWithBodyWithResponse request with any body
	SignEvmUserOperationWithBodyWithResponse(ctx context.Context, address string, params *SignEvmUserOperationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SignEvmUserOperationResponse, error)

	SignEvmUserOperationWithResponse(ctx context.Context, address string, params *SignEvmUserOperationParams, body SignEvmUserOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*SignEvmUserOperationResponse, error)

	// RequestEvmFaucetWithBodyWithResponse request with any body
	RequestEvmFaucetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RequestEvmFaucetResponse, error)

	RequestEvmFaucetWithResponse(ctx context.Context, body RequestEvmFaucetJSONRequestBody, reqEditors ...RequestEditorFn) (*RequestEvmFaucetResponse, error)

	// ListEvmSmartAccountsWithResponse request
	ListEvmSmartAccountsWithResponse(ctx context.Context, params *ListEvmSmartAccountsParams, reqEditors ...RequestEditorFn) (*ListEvmSmartAccountsResponse, error)

	// CreateEvmSmartAccountWithBodyWithResponse request with any body
	CreateEvmSmartAccountWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEvmSmartAccountResponse, error)

	CreateEvmSmartAccountWithResponse(ctx context.Context, body CreateEvmSmartAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEvmSmartAccountResponse, error)

	// GetEvmSmartAccountWithResponse request
	GetEvmSmartAccountWithResponse(ctx context.Context, address string, reqEditors ...RequestEditorFn) (*GetEvmSmartAccountResponse, error)

	// PrepareUserOperationWithBodyWithResponse request with any body
	PrepareUserOperationWithBodyWithResponse(ctx context.Context, address string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PrepareUserOperationResponse, error)

	PrepareUserOperationWithResponse(ctx context.Context, address string, body PrepareUserOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*PrepareUserOperationResponse, error)

	// GetUserOperationWithResponse request
	GetUserOperationWithResponse(ctx context.Context, address string, userOpHash string, reqEditors ...RequestEditorFn) (*GetUserOperationResponse, error)

	// SendUserOperationWithBodyWithResponse request with any body
	SendUserOperationWithBodyWithResponse(ctx context.Context, address string, userOpHash string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendUserOperationResponse, error)

	SendUserOperationWithResponse(ctx context.Context, address string, userOpHash string, body SendUserOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*SendUserOperationResponse, error)

	// ListEvmTokenBalancesWithResponse request
	ListEvmTokenBalancesWithResponse(ctx context.Context, network ListEvmTokenBalancesNetwork, address string, params *ListEvmTokenBalancesParams, reqEditors ...RequestEditorFn) (*ListEvmTokenBalancesResponse, error)

	// ListSolanaAccountsWithResponse request
	ListSolanaAccountsWithResponse(ctx context.Context, params *ListSolanaAccountsParams, reqEditors ...RequestEditorFn) (*ListSolanaAccountsResponse, error)

	// CreateSolanaAccountWithBodyWithResponse request with any body
	CreateSolanaAccountWithBodyWithResponse(ctx context.Context, params *CreateSolanaAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSolanaAccountResponse, error)

	CreateSolanaAccountWithResponse(ctx context.Context, params *CreateSolanaAccountParams, body CreateSolanaAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSolanaAccountResponse, error)

	// GetSolanaAccountByNameWithResponse request
	GetSolanaAccountByNameWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetSolanaAccountByNameResponse, error)

	// GetSolanaAccountWithResponse request
	GetSolanaAccountWithResponse(ctx context.Context, address string, reqEditors ...RequestEditorFn) (*GetSolanaAccountResponse, error)

	// SignSolanaMessageWithBodyWithResponse request with any body
	SignSolanaMessageWithBodyWithResponse(ctx context.Context, address string, params *SignSolanaMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SignSolanaMessageResponse, error)

	SignSolanaMessageWithResponse(ctx context.Context, address string, params *SignSolanaMessageParams, body SignSolanaMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*SignSolanaMessageResponse, error)

	// SignSolanaTransactionWithBodyWithResponse request with any body
	SignSolanaTransactionWithBodyWithResponse(ctx context.Context, address string, params *SignSolanaTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SignSolanaTransactionResponse, error)

	SignSolanaTransactionWithResponse(ctx context.Context, address string, params *SignSolanaTransactionParams, body SignSolanaTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*SignSolanaTransactionResponse, error)

	// RequestSolanaFaucetWithBodyWithResponse request with any body
	RequestSolanaFaucetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RequestSolanaFaucetResponse, error)

	RequestSolanaFaucetWithResponse(ctx context.Context, body RequestSolanaFaucetJSONRequestBody, reqEditors ...RequestEditorFn) (*RequestSolanaFaucetResponse, error)
}

type ListEvmAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Accounts The list of EVM accounts.
		Accounts []EvmAccount `json:"accounts"`

		// NextPageToken The token for the next page of items, if any.
		NextPageToken *string `json:"nextPageToken,omitempty"`
	}
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListEvmAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEvmAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateEvmAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *EvmAccount
	JSON400      *Error
	JSON401      *Error
	JSON409      *Error
	JSON422      *IdempotencyError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateEvmAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateEvmAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEvmAccountByNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EvmAccount
	JSON400      *Error
	JSON404      *Error
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetEvmAccountByNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEvmAccountByNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEvmAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EvmAccount
	JSON400      *Error
	JSON404      *Error
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetEvmAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEvmAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendEvmTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// TransactionHash The hash of the transaction, as a 0x-prefixed hex string.
		TransactionHash string `json:"transactionHash"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON404 *Error
	JSON409 *AlreadyExistsError
	JSON422 *IdempotencyError
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SendEvmTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendEvmTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SignEvmHashResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Signature The signature of the hash, as a 0x-prefixed hex string.
		Signature string `json:"signature"`
	}
	JSON400 *Error
	JSON404 *Error
	JSON409 *AlreadyExistsError
	JSON422 *IdempotencyError
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SignEvmHashResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SignEvmHashResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SignEvmMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Signature The signature of the message, as a 0x-prefixed hex string.
		Signature string `json:"signature"`
	}
	JSON401 *Error
	JSON404 *Error
	JSON409 *AlreadyExistsError
	JSON422 *IdempotencyError
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SignEvmMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SignEvmMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SignEvmTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// SignedTransaction The RLP-encoded signed transaction, as a 0x-prefixed hex string.
		SignedTransaction string `json:"signedTransaction"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON404 *Error
	JSON409 *AlreadyExistsError
	JSON422 *IdempotencyError
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SignEvmTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SignEvmTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SignEvmUserOperationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Signature The signed user operation, as a 0x-prefixed hex string.
		Signature string `json:"signature"`
	}
	JSON401 *Error
	JSON404 *Error
	JSON422 *IdempotencyError
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SignEvmUserOperationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SignEvmUserOperationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RequestEvmFaucetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// TransactionHash The hash of the transaction that requested the funds.
		// **Note:** In rare cases, when gas conditions are unusually high, the transaction may not confirm, and the system may issue a replacement transaction to complete the faucet request. In these rare cases, the `transactionHash` will be out of sync with the actual faucet transaction that was confirmed onchain.
		TransactionHash string `json:"transactionHash"`
	}
	JSON400 *Error
	JSON403 *Error
	JSON429 *Error
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r RequestEvmFaucetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RequestEvmFaucetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListEvmSmartAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Accounts The list of Smart Accounts.
		Accounts []EvmSmartAccount `json:"accounts"`

		// NextPageToken The token for the next page of items, if any.
		NextPageToken *string `json:"nextPageToken,omitempty"`
	}
	JSON400 *Error
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListEvmSmartAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEvmSmartAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateEvmSmartAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *EvmSmartAccount
	JSON400      *Error
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateEvmSmartAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateEvmSmartAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEvmSmartAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EvmSmartAccount
	JSON400      *Error
	JSON404      *Error
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetEvmSmartAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEvmSmartAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PrepareUserOperationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *EvmUserOperation
	JSON400      *Error
	JSON404      *Error
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PrepareUserOperationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PrepareUserOperationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserOperationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EvmUserOperation
	JSON400      *Error
	JSON404      *Error
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetUserOperationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserOperationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendUserOperationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EvmUserOperation
	JSON400      *Error
	JSON404      *Error
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SendUserOperationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendUserOperationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListEvmTokenBalancesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Balances The list of EVM token balances.
		Balances []TokenBalance `json:"balances"`

		// NextPageToken The token for the next page of items, if any.
		NextPageToken *string `json:"nextPageToken,omitempty"`
	}
	JSON400 *Error
	JSON404 *Error
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListEvmTokenBalancesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEvmTokenBalancesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSolanaAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Accounts The list of Solana accounts.
		Accounts []SolanaAccount `json:"accounts"`

		// NextPageToken The token for the next page of items, if any.
		NextPageToken *string `json:"nextPageToken,omitempty"`
	}
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListSolanaAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSolanaAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSolanaAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SolanaAccount
	JSON400      *Error
	JSON401      *Error
	JSON409      *Error
	JSON422      *IdempotencyError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateSolanaAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSolanaAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSolanaAccountByNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SolanaAccount
	JSON400      *Error
	JSON404      *Error
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetSolanaAccountByNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSolanaAccountByNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSolanaAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SolanaAccount
	JSON400      *Error
	JSON404      *Error
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetSolanaAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSolanaAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SignSolanaMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Signature The signature of the message, as a base58 encoded string.
		Signature string `json:"signature"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON404 *Error
	JSON409 *AlreadyExistsError
	JSON422 *IdempotencyError
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SignSolanaMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SignSolanaMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SignSolanaTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// SignedTransaction The base64 encoded signed transaction.
		SignedTransaction string `json:"signedTransaction"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON404 *Error
	JSON409 *AlreadyExistsError
	JSON422 *IdempotencyError
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SignSolanaTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SignSolanaTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RequestSolanaFaucetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// TransactionSignature The signature identifying the transaction that requested the funds.
		TransactionSignature string `json:"transactionSignature"`
	}
	JSON400 *Error
	JSON403 *Error
	JSON429 *Error
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r RequestSolanaFaucetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RequestSolanaFaucetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListEvmAccountsWithResponse request returning *ListEvmAccountsResponse
func (c *ClientWithResponses) ListEvmAccountsWithResponse(ctx context.Context, params *ListEvmAccountsParams, reqEditors ...RequestEditorFn) (*ListEvmAccountsResponse, error) {
	rsp, err := c.ListEvmAccounts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListEvmAccountsResponse(rsp)
}

// CreateEvmAccountWithBodyWithResponse request with arbitrary body returning *CreateEvmAccountResponse
func (c *ClientWithResponses) CreateEvmAccountWithBodyWithResponse(ctx context.Context, params *CreateEvmAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEvmAccountResponse, error) {
	rsp, err := c.CreateEvmAccountWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEvmAccountResponse(rsp)
}

func (c *ClientWithResponses) CreateEvmAccountWithResponse(ctx context.Context, params *CreateEvmAccountParams, body CreateEvmAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEvmAccountResponse, error) {
	rsp, err := c.CreateEvmAccount(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEvmAccountResponse(rsp)
}

// GetEvmAccountByNameWithResponse request returning *GetEvmAccountByNameResponse
func (c *ClientWithResponses) GetEvmAccountByNameWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetEvmAccountByNameResponse, error) {
	rsp, err := c.GetEvmAccountByName(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEvmAccountByNameResponse(rsp)
}

// GetEvmAccountWithResponse request returning *GetEvmAccountResponse
func (c *ClientWithResponses) GetEvmAccountWithResponse(ctx context.Context, address string, reqEditors ...RequestEditorFn) (*GetEvmAccountResponse, error) {
	rsp, err := c.GetEvmAccount(ctx, address, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEvmAccountResponse(rsp)
}

// SendEvmTransactionWithBodyWithResponse request with arbitrary body returning *SendEvmTransactionResponse
func (c *ClientWithResponses) SendEvmTransactionWithBodyWithResponse(ctx context.Context, address string, params *SendEvmTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendEvmTransactionResponse, error) {
	rsp, err := c.SendEvmTransactionWithBody(ctx, address, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendEvmTransactionResponse(rsp)
}

func (c *ClientWithResponses) SendEvmTransactionWithResponse(ctx context.Context, address string, params *SendEvmTransactionParams, body SendEvmTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*SendEvmTransactionResponse, error) {
	rsp, err := c.SendEvmTransaction(ctx, address, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendEvmTransactionResponse(rsp)
}

// SignEvmHashWithBodyWithResponse request with arbitrary body returning *SignEvmHashResponse
func (c *ClientWithResponses) SignEvmHashWithBodyWithResponse(ctx context.Context, address string, params *SignEvmHashParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SignEvmHashResponse, error) {
	rsp, err := c.SignEvmHashWithBody(ctx, address, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSignEvmHashResponse(rsp)
}

func (c *ClientWithResponses) SignEvmHashWithResponse(ctx context.Context, address string, params *SignEvmHashParams, body SignEvmHashJSONRequestBody, reqEditors ...RequestEditorFn) (*SignEvmHashResponse, error) {
	rsp, err := c.SignEvmHash(ctx, address, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSignEvmHashResponse(rsp)
}

// SignEvmMessageWithBodyWithResponse request with arbitrary body returning *SignEvmMessageResponse
func (c *ClientWithResponses) SignEvmMessageWithBodyWithResponse(ctx context.Context, address string, params *SignEvmMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SignEvmMessageResponse, error) {
	rsp, err := c.SignEvmMessageWithBody(ctx, address, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSignEvmMessageResponse(rsp)
}

func (c *ClientWithResponses) SignEvmMessageWithResponse(ctx context.Context, address string, params *SignEvmMessageParams, body SignEvmMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*SignEvmMessageResponse, error) {
	rsp, err := c.SignEvmMessage(ctx, address, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSignEvmMessageResponse(rsp)
}

// SignEvmTransactionWithBodyWithResponse request with arbitrary body returning *SignEvmTransactionResponse
func (c *ClientWithResponses) SignEvmTransactionWithBodyWithResponse(ctx context.Context, address string, params *SignEvmTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SignEvmTransactionResponse, error) {
	rsp, err := c.SignEvmTransactionWithBody(ctx, address, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSignEvmTransactionResponse(rsp)
}

func (c *ClientWithResponses) SignEvmTransactionWithResponse(ctx context.Context, address string, params *SignEvmTransactionParams, body SignEvmTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*SignEvmTransactionResponse, error) {
	rsp, err := c.SignEvmTransaction(ctx, address, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSignEvmTransactionResponse(rsp)
}

// SignEvmUserOperationWithBodyWithResponse request with arbitrary body returning *SignEvmUserOperationResponse
func (c *ClientWithResponses) SignEvmUserOperationWithBodyWithResponse(ctx context.Context, address string, params *SignEvmUserOperationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SignEvmUserOperationResponse, error) {
	rsp, err := c.SignEvmUserOperationWithBody(ctx, address, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSignEvmUserOperationResponse(rsp)
}

func (c *ClientWithResponses) SignEvmUserOperationWithResponse(ctx context.Context, address string, params *SignEvmUserOperationParams, body SignEvmUserOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*SignEvmUserOperationResponse, error) {
	rsp, err := c.SignEvmUserOperation(ctx, address, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSignEvmUserOperationResponse(rsp)
}

// RequestEvmFaucetWithBodyWithResponse request with arbitrary body returning *RequestEvmFaucetResponse
func (c *ClientWithResponses) RequestEvmFaucetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RequestEvmFaucetResponse, error) {
	rsp, err := c.RequestEvmFaucetWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRequestEvmFaucetResponse(rsp)
}

func (c *ClientWithResponses) RequestEvmFaucetWithResponse(ctx context.Context, body RequestEvmFaucetJSONRequestBody, reqEditors ...RequestEditorFn) (*RequestEvmFaucetResponse, error) {
	rsp, err := c.RequestEvmFaucet(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRequestEvmFaucetResponse(rsp)
}

// ListEvmSmartAccountsWithResponse request returning *ListEvmSmartAccountsResponse
func (c *ClientWithResponses) ListEvmSmartAccountsWithResponse(ctx context.Context, params *ListEvmSmartAccountsParams, reqEditors ...RequestEditorFn) (*ListEvmSmartAccountsResponse, error) {
	rsp, err := c.ListEvmSmartAccounts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListEvmSmartAccountsResponse(rsp)
}

// CreateEvmSmartAccountWithBodyWithResponse request with arbitrary body returning *CreateEvmSmartAccountResponse
func (c *ClientWithResponses) CreateEvmSmartAccountWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEvmSmartAccountResponse, error) {
	rsp, err := c.CreateEvmSmartAccountWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEvmSmartAccountResponse(rsp)
}

func (c *ClientWithResponses) CreateEvmSmartAccountWithResponse(ctx context.Context, body CreateEvmSmartAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEvmSmartAccountResponse, error) {
	rsp, err := c.CreateEvmSmartAccount(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEvmSmartAccountResponse(rsp)
}

// GetEvmSmartAccountWithResponse request returning *GetEvmSmartAccountResponse
func (c *ClientWithResponses) GetEvmSmartAccountWithResponse(ctx context.Context, address string, reqEditors ...RequestEditorFn) (*GetEvmSmartAccountResponse, error) {
	rsp, err := c.GetEvmSmartAccount(ctx, address, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEvmSmartAccountResponse(rsp)
}

// PrepareUserOperationWithBodyWithResponse request with arbitrary body returning *PrepareUserOperationResponse
func (c *ClientWithResponses) PrepareUserOperationWithBodyWithResponse(ctx context.Context, address string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PrepareUserOperationResponse, error) {
	rsp, err := c.PrepareUserOperationWithBody(ctx, address, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePrepareUserOperationResponse(rsp)
}

func (c *ClientWithResponses) PrepareUserOperationWithResponse(ctx context.Context, address string, body PrepareUserOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*PrepareUserOperationResponse, error) {
	rsp, err := c.PrepareUserOperation(ctx, address, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePrepareUserOperationResponse(rsp)
}

// GetUserOperationWithResponse request returning *GetUserOperationResponse
func (c *ClientWithResponses) GetUserOperationWithResponse(ctx context.Context, address string, userOpHash string, reqEditors ...RequestEditorFn) (*GetUserOperationResponse, error) {
	rsp, err := c.GetUserOperation(ctx, address, userOpHash, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserOperationResponse(rsp)
}

// SendUserOperationWithBodyWithResponse request with arbitrary body returning *SendUserOperationResponse
func (c *ClientWithResponses) SendUserOperationWithBodyWithResponse(ctx context.Context, address string, userOpHash string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendUserOperationResponse, error) {
	rsp, err := c.SendUserOperationWithBody(ctx, address, userOpHash, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendUserOperationResponse(rsp)
}

func (c *ClientWithResponses) SendUserOperationWithResponse(ctx context.Context, address string, userOpHash string, body SendUserOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*SendUserOperationResponse, error) {
	rsp, err := c.SendUserOperation(ctx, address, userOpHash, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendUserOperationResponse(rsp)
}

// ListEvmTokenBalancesWithResponse request returning *ListEvmTokenBalancesResponse
func (c *ClientWithResponses) ListEvmTokenBalancesWithResponse(ctx context.Context, network ListEvmTokenBalancesNetwork, address string, params *ListEvmTokenBalancesParams, reqEditors ...RequestEditorFn) (*ListEvmTokenBalancesResponse, error) {
	rsp, err := c.ListEvmTokenBalances(ctx, network, address, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListEvmTokenBalancesResponse(rsp)
}

// ListSolanaAccountsWithResponse request returning *ListSolanaAccountsResponse
func (c *ClientWithResponses) ListSolanaAccountsWithResponse(ctx context.Context, params *ListSolanaAccountsParams, reqEditors ...RequestEditorFn) (*ListSolanaAccountsResponse, error) {
	rsp, err := c.ListSolanaAccounts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSolanaAccountsResponse(rsp)
}

// CreateSolanaAccountWithBodyWithResponse request with arbitrary body returning *CreateSolanaAccountResponse
func (c *ClientWithResponses) CreateSolanaAccountWithBodyWithResponse(ctx context.Context, params *CreateSolanaAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSolanaAccountResponse, error) {
	rsp, err := c.CreateSolanaAccountWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSolanaAccountResponse(rsp)
}

func (c *ClientWithResponses) CreateSolanaAccountWithResponse(ctx context.Context, params *CreateSolanaAccountParams, body CreateSolanaAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSolanaAccountResponse, error) {
	rsp, err := c.CreateSolanaAccount(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSolanaAccountResponse(rsp)
}

// GetSolanaAccountByNameWithResponse request returning *GetSolanaAccountByNameResponse
func (c *ClientWithResponses) GetSolanaAccountByNameWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetSolanaAccountByNameResponse, error) {
	rsp, err := c.GetSolanaAccountByName(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSolanaAccountByNameResponse(rsp)
}

// GetSolanaAccountWithResponse request returning *GetSolanaAccountResponse
func (c *ClientWithResponses) GetSolanaAccountWithResponse(ctx context.Context, address string, reqEditors ...RequestEditorFn) (*GetSolanaAccountResponse, error) {
	rsp, err := c.GetSolanaAccount(ctx, address, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSolanaAccountResponse(rsp)
}

// SignSolanaMessageWithBodyWithResponse request with arbitrary body returning *SignSolanaMessageResponse
func (c *ClientWithResponses) SignSolanaMessageWithBodyWithResponse(ctx context.Context, address string, params *SignSolanaMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SignSolanaMessageResponse, error) {
	rsp, err := c.SignSolanaMessageWithBody(ctx, address, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSignSolanaMessageResponse(rsp)
}

func (c *ClientWithResponses) SignSolanaMessageWithResponse(ctx context.Context, address string, params *SignSolanaMessageParams, body SignSolanaMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*SignSolanaMessageResponse, error) {
	rsp, err := c.SignSolanaMessage(ctx, address, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSignSolanaMessageResponse(rsp)
}

// SignSolanaTransactionWithBodyWithResponse request with arbitrary body returning *SignSolanaTransactionResponse
func (c *ClientWithResponses) SignSolanaTransactionWithBodyWithResponse(ctx context.Context, address string, params *SignSolanaTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SignSolanaTransactionResponse, error) {
	rsp, err := c.SignSolanaTransactionWithBody(ctx, address, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSignSolanaTransactionResponse(rsp)
}

func (c *ClientWithResponses) SignSolanaTransactionWithResponse(ctx context.Context, address string, params *SignSolanaTransactionParams, body SignSolanaTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*SignSolanaTransactionResponse, error) {
	rsp, err := c.SignSolanaTransaction(ctx, address, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSignSolanaTransactionResponse(rsp)
}

// RequestSolanaFaucetWithBodyWithResponse request with arbitrary body returning *RequestSolanaFaucetResponse
func (c *ClientWithResponses) RequestSolanaFaucetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RequestSolanaFaucetResponse, error) {
	rsp, err := c.RequestSolanaFaucetWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRequestSolanaFaucetResponse(rsp)
}

func (c *ClientWithResponses) RequestSolanaFaucetWithResponse(ctx context.Context, body RequestSolanaFaucetJSONRequestBody, reqEditors ...RequestEditorFn) (*RequestSolanaFaucetResponse, error) {
	rsp, err := c.RequestSolanaFaucet(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRequestSolanaFaucetResponse(rsp)
}

// ParseListEvmAccountsResponse parses an HTTP response from a ListEvmAccountsWithResponse call
func ParseListEvmAccountsResponse(rsp *http.Response) (*ListEvmAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListEvmAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Accounts The list of EVM accounts.
			Accounts []EvmAccount `json:"accounts"`

			// NextPageToken The token for the next page of items, if any.
			NextPageToken *string `json:"nextPageToken,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateEvmAccountResponse parses an HTTP response from a CreateEvmAccountWithResponse call
func ParseCreateEvmAccountResponse(rsp *http.Response) (*CreateEvmAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateEvmAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest EvmAccount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetEvmAccountByNameResponse parses an HTTP response from a GetEvmAccountByNameWithResponse call
func ParseGetEvmAccountByNameResponse(rsp *http.Response) (*GetEvmAccountByNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEvmAccountByNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EvmAccount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetEvmAccountResponse parses an HTTP response from a GetEvmAccountWithResponse call
func ParseGetEvmAccountResponse(rsp *http.Response) (*GetEvmAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEvmAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EvmAccount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSendEvmTransactionResponse parses an HTTP response from a SendEvmTransactionWithResponse call
func ParseSendEvmTransactionResponse(rsp *http.Response) (*SendEvmTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SendEvmTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// TransactionHash The hash of the transaction, as a 0x-prefixed hex string.
			TransactionHash string `json:"transactionHash"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExistsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSignEvmHashResponse parses an HTTP response from a SignEvmHashWithResponse call
func ParseSignEvmHashResponse(rsp *http.Response) (*SignEvmHashResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SignEvmHashResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Signature The signature of the hash, as a 0x-prefixed hex string.
			Signature string `json:"signature"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExistsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSignEvmMessageResponse parses an HTTP response from a SignEvmMessageWithResponse call
func ParseSignEvmMessageResponse(rsp *http.Response) (*SignEvmMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SignEvmMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Signature The signature of the message, as a 0x-prefixed hex string.
			Signature string `json:"signature"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExistsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSignEvmTransactionResponse parses an HTTP response from a SignEvmTransactionWithResponse call
func ParseSignEvmTransactionResponse(rsp *http.Response) (*SignEvmTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SignEvmTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// SignedTransaction The RLP-encoded signed transaction, as a 0x-prefixed hex string.
			SignedTransaction string `json:"signedTransaction"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExistsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSignEvmUserOperationResponse parses an HTTP response from a SignEvmUserOperationWithResponse call
func ParseSignEvmUserOperationResponse(rsp *http.Response) (*SignEvmUserOperationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SignEvmUserOperationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Signature The signed user operation, as a 0x-prefixed hex string.
			Signature string `json:"signature"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRequestEvmFaucetResponse parses an HTTP response from a RequestEvmFaucetWithResponse call
func ParseRequestEvmFaucetResponse(rsp *http.Response) (*RequestEvmFaucetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RequestEvmFaucetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// TransactionHash The hash of the transaction that requested the funds.
			// **Note:** In rare cases, when gas conditions are unusually high, the transaction may not confirm, and the system may issue a replacement transaction to complete the faucet request. In these rare cases, the `transactionHash` will be out of sync with the actual faucet transaction that was confirmed onchain.
			TransactionHash string `json:"transactionHash"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListEvmSmartAccountsResponse parses an HTTP response from a ListEvmSmartAccountsWithResponse call
func ParseListEvmSmartAccountsResponse(rsp *http.Response) (*ListEvmSmartAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListEvmSmartAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Accounts The list of Smart Accounts.
			Accounts []EvmSmartAccount `json:"accounts"`

			// NextPageToken The token for the next page of items, if any.
			NextPageToken *string `json:"nextPageToken,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateEvmSmartAccountResponse parses an HTTP response from a CreateEvmSmartAccountWithResponse call
func ParseCreateEvmSmartAccountResponse(rsp *http.Response) (*CreateEvmSmartAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateEvmSmartAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest EvmSmartAccount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetEvmSmartAccountResponse parses an HTTP response from a GetEvmSmartAccountWithResponse call
func ParseGetEvmSmartAccountResponse(rsp *http.Response) (*GetEvmSmartAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEvmSmartAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EvmSmartAccount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePrepareUserOperationResponse parses an HTTP response from a PrepareUserOperationWithResponse call
func ParsePrepareUserOperationResponse(rsp *http.Response) (*PrepareUserOperationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PrepareUserOperationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest EvmUserOperation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUserOperationResponse parses an HTTP response from a GetUserOperationWithResponse call
func ParseGetUserOperationResponse(rsp *http.Response) (*GetUserOperationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserOperationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EvmUserOperation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSendUserOperationResponse parses an HTTP response from a SendUserOperationWithResponse call
func ParseSendUserOperationResponse(rsp *http.Response) (*SendUserOperationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SendUserOperationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EvmUserOperation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListEvmTokenBalancesResponse parses an HTTP response from a ListEvmTokenBalancesWithResponse call
func ParseListEvmTokenBalancesResponse(rsp *http.Response) (*ListEvmTokenBalancesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListEvmTokenBalancesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Balances The list of EVM token balances.
			Balances []TokenBalance `json:"balances"`

			// NextPageToken The token for the next page of items, if any.
			NextPageToken *string `json:"nextPageToken,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListSolanaAccountsResponse parses an HTTP response from a ListSolanaAccountsWithResponse call
func ParseListSolanaAccountsResponse(rsp *http.Response) (*ListSolanaAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSolanaAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Accounts The list of Solana accounts.
			Accounts []SolanaAccount `json:"accounts"`

			// NextPageToken The token for the next page of items, if any.
			NextPageToken *string `json:"nextPageToken,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateSolanaAccountResponse parses an HTTP response from a CreateSolanaAccountWithResponse call
func ParseCreateSolanaAccountResponse(rsp *http.Response) (*CreateSolanaAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSolanaAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SolanaAccount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSolanaAccountByNameResponse parses an HTTP response from a GetSolanaAccountByNameWithResponse call
func ParseGetSolanaAccountByNameResponse(rsp *http.Response) (*GetSolanaAccountByNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSolanaAccountByNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SolanaAccount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSolanaAccountResponse parses an HTTP response from a GetSolanaAccountWithResponse call
func ParseGetSolanaAccountResponse(rsp *http.Response) (*GetSolanaAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSolanaAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SolanaAccount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSignSolanaMessageResponse parses an HTTP response from a SignSolanaMessageWithResponse call
func ParseSignSolanaMessageResponse(rsp *http.Response) (*SignSolanaMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SignSolanaMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Signature The signature of the message, as a base58 encoded string.
			Signature string `json:"signature"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExistsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSignSolanaTransactionResponse parses an HTTP response from a SignSolanaTransactionWithResponse call
func ParseSignSolanaTransactionResponse(rsp *http.Response) (*SignSolanaTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SignSolanaTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// SignedTransaction The base64 encoded signed transaction.
			SignedTransaction string `json:"signedTransaction"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExistsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest IdempotencyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRequestSolanaFaucetResponse parses an HTTP response from a RequestSolanaFaucetWithResponse call
func ParseRequestSolanaFaucetResponse(rsp *http.Response) (*RequestSolanaFaucetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RequestSolanaFaucetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// TransactionSignature The signature identifying the transaction that requested the funds.
			TransactionSignature string `json:"transactionSignature"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}
